//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 1 storyboards.
  struct storyboard {
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 41 colors.
  struct color {
    /// Color `color0x1D1D20`.
    static let color0x1D1D20 = Rswift.ColorResource(bundle: R.hostingBundle, name: "color0x1D1D20")
    /// Color `colorAccentGradientEnd`.
    static let colorAccentGradientEnd = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorAccentGradientEnd")
    /// Color `colorAccentGradientStart`.
    static let colorAccentGradientStart = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorAccentGradientStart")
    /// Color `colorAccentSelected`.
    static let colorAccentSelected = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorAccentSelected")
    /// Color `colorAccent`.
    static let colorAccent = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorAccent")
    /// Color `colorAlmostBlack`.
    static let colorAlmostBlack = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorAlmostBlack")
    /// Color `colorBlack24`.
    static let colorBlack24 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorBlack24")
    /// Color `colorBlack`.
    static let colorBlack = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorBlack")
    /// Color `colorBlurOverlay`.
    static let colorBlurOverlay = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorBlurOverlay")
    /// Color `colorBlurSeparator`.
    static let colorBlurSeparator = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorBlurSeparator")
    /// Color `colorCoral`.
    static let colorCoral = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorCoral")
    /// Color `colorCrimson`.
    static let colorCrimson = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorCrimson")
    /// Color `colorDarkBlue`.
    static let colorDarkBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorDarkBlue")
    /// Color `colorDarkGray`.
    static let colorDarkGray = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorDarkGray")
    /// Color `colorDarkInactive`.
    static let colorDarkInactive = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorDarkInactive")
    /// Color `colorDisabledBackground`.
    static let colorDisabledBackground = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorDisabledBackground")
    /// Color `colorGradientDisabled`.
    static let colorGradientDisabled = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorGradientDisabled")
    /// Color `colorGray`.
    static let colorGray = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorGray")
    /// Color `colorGreen24`.
    static let colorGreen24 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorGreen24")
    /// Color `colorGreen`.
    static let colorGreen = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorGreen")
    /// Color `colorHighlightedAccent`.
    static let colorHighlightedAccent = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorHighlightedAccent")
    /// Color `colorLightGray`.
    static let colorLightGray = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorLightGray")
    /// Color `colorNovaBlue`.
    static let colorNovaBlue = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorNovaBlue")
    /// Color `colorRed12`.
    static let colorRed12 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorRed12")
    /// Color `colorRed40`.
    static let colorRed40 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorRed40")
    /// Color `colorRed`.
    static let colorRed = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorRed")
    /// Color `colorScrim`.
    static let colorScrim = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorScrim")
    /// Color `colorSkeletonEnd`.
    static let colorSkeletonEnd = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorSkeletonEnd")
    /// Color `colorSkeletonStart`.
    static let colorSkeletonStart = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorSkeletonStart")
    /// Color `colorStrokeGray`.
    static let colorStrokeGray = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorStrokeGray")
    /// Color `colorTransparentText`.
    static let colorTransparentText = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorTransparentText")
    /// Color `colorWhite16`.
    static let colorWhite16 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite16")
    /// Color `colorWhite24`.
    static let colorWhite24 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite24")
    /// Color `colorWhite32`.
    static let colorWhite32 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite32")
    /// Color `colorWhite40`.
    static let colorWhite40 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite40")
    /// Color `colorWhite48`.
    static let colorWhite48 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite48")
    /// Color `colorWhite80`.
    static let colorWhite80 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite80")
    /// Color `colorWhite8`.
    static let colorWhite8 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite8")
    /// Color `colorWhite`.
    static let colorWhite = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorWhite")
    /// Color `colorYellow12`.
    static let colorYellow12 = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorYellow12")
    /// Color `colorYellow`.
    static let colorYellow = Rswift.ColorResource(bundle: R.hostingBundle, name: "colorYellow")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "color0x1D1D20", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func color0x1D1D20(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.color0x1D1D20, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorAccent", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorAccent(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorAccent, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorAccentGradientEnd", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorAccentGradientEnd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorAccentGradientEnd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorAccentGradientStart", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorAccentGradientStart(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorAccentGradientStart, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorAccentSelected", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorAccentSelected(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorAccentSelected, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorAlmostBlack", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorAlmostBlack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorAlmostBlack, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorBlack", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorBlack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorBlack, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorBlack24", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorBlack24(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorBlack24, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorBlurOverlay", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorBlurOverlay(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorBlurOverlay, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorBlurSeparator", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorBlurSeparator(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorBlurSeparator, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorCoral", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorCoral(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorCoral, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorCrimson", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorCrimson(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorCrimson, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorDarkBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorDarkBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorDarkBlue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorDarkGray", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorDarkGray(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorDarkGray, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorDarkInactive", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorDarkInactive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorDarkInactive, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorDisabledBackground", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorDisabledBackground(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorDisabledBackground, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorGradientDisabled", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorGradientDisabled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorGradientDisabled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorGray", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorGray(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorGray, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorGreen", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorGreen(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorGreen, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorGreen24", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorGreen24(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorGreen24, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorHighlightedAccent", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorHighlightedAccent(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorHighlightedAccent, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorLightGray", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorLightGray(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorLightGray, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorNovaBlue", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorNovaBlue(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorNovaBlue, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorRed", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorRed(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorRed, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorRed12", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorRed12(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorRed12, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorRed40", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorRed40(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorRed40, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorScrim", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorScrim(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorScrim, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorSkeletonEnd", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorSkeletonEnd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorSkeletonEnd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorSkeletonStart", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorSkeletonStart(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorSkeletonStart, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorStrokeGray", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorStrokeGray(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorStrokeGray, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorTransparentText", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorTransparentText(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorTransparentText, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite16", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite16(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite16, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite24", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite24(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite24, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite32", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite32(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite32, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite40", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite40(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite40, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite48", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite48(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite48, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite8", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite8(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite8, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorWhite80", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorWhite80(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorWhite80, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorYellow", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorYellow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorYellow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "colorYellow12", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func colorYellow12(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.colorYellow12, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "color0x1D1D20", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func color0x1D1D20(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.color0x1D1D20.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorAccent", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorAccent(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorAccent.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorAccentGradientEnd", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorAccentGradientEnd(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorAccentGradientEnd.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorAccentGradientStart", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorAccentGradientStart(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorAccentGradientStart.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorAccentSelected", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorAccentSelected(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorAccentSelected.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorAlmostBlack", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorAlmostBlack(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorAlmostBlack.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorBlack", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorBlack(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorBlack.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorBlack24", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorBlack24(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorBlack24.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorBlurOverlay", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorBlurOverlay(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorBlurOverlay.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorBlurSeparator", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorBlurSeparator(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorBlurSeparator.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorCoral", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorCoral(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorCoral.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorCrimson", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorCrimson(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorCrimson.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorDarkBlue", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorDarkBlue(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorDarkBlue.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorDarkGray", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorDarkGray(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorDarkGray.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorDarkInactive", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorDarkInactive(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorDarkInactive.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorDisabledBackground", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorDisabledBackground(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorDisabledBackground.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorGradientDisabled", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorGradientDisabled(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorGradientDisabled.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorGray", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorGray(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorGray.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorGreen", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorGreen(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorGreen.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorGreen24", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorGreen24(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorGreen24.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorHighlightedAccent", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorHighlightedAccent(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorHighlightedAccent.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorLightGray", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorLightGray(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorLightGray.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorNovaBlue", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorNovaBlue(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorNovaBlue.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorRed", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorRed(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorRed.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorRed12", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorRed12(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorRed12.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorRed40", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorRed40(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorRed40.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorScrim", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorScrim(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorScrim.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorSkeletonEnd", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorSkeletonEnd(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorSkeletonEnd.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorSkeletonStart", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorSkeletonStart(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorSkeletonStart.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorStrokeGray", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorStrokeGray(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorStrokeGray.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorTransparentText", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorTransparentText(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorTransparentText.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite16", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite16(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite16.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite24", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite24(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite24.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite32", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite32(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite32.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite40", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite40(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite40.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite48", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite48(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite48.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite8", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite8(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite8.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorWhite80", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorWhite80(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorWhite80.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorYellow", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorYellow(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorYellow.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "colorYellow12", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func colorYellow12(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.colorYellow12.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 18 files.
  struct file {
    /// Resource file `CIKeys.stencil`.
    static let ciKeysStencil = Rswift.FileResource(bundle: R.hostingBundle, name: "CIKeys", pathExtension: "stencil")
    /// Resource file `PublicSans-Bold.otf`.
    static let publicSansBoldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "PublicSans-Bold", pathExtension: "otf")
    /// Resource file `PublicSans-ExtraBold.otf`.
    static let publicSansExtraBoldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "PublicSans-ExtraBold", pathExtension: "otf")
    /// Resource file `PublicSans-ExtraLight.otf`.
    static let publicSansExtraLightOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "PublicSans-ExtraLight", pathExtension: "otf")
    /// Resource file `PublicSans-Medium.otf`.
    static let publicSansMediumOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "PublicSans-Medium", pathExtension: "otf")
    /// Resource file `PublicSans-Regular.otf`.
    static let publicSansRegularOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "PublicSans-Regular", pathExtension: "otf")
    /// Resource file `PublicSans-SemiBold.otf`.
    static let publicSansSemiBoldOtf = Rswift.FileResource(bundle: R.hostingBundle, name: "PublicSans-SemiBold", pathExtension: "otf")
    /// Resource file `metamask_min.js`.
    static let metamask_minJs = Rswift.FileResource(bundle: R.hostingBundle, name: "metamask_min", pathExtension: "js")
    /// Resource file `nova_min.js`.
    static let nova_minJs = Rswift.FileResource(bundle: R.hostingBundle, name: "nova_min", pathExtension: "js")
    /// Resource file `novawallet.debug.xcconfig`.
    static let novawalletDebugXcconfig = Rswift.FileResource(bundle: R.hostingBundle, name: "novawallet.debug", pathExtension: "xcconfig")
    /// Resource file `novawallet.dev.xcconfig`.
    static let novawalletDevXcconfig = Rswift.FileResource(bundle: R.hostingBundle, name: "novawallet.dev", pathExtension: "xcconfig")
    /// Resource file `novawallet.release.xcconfig`.
    static let novawalletReleaseXcconfig = Rswift.FileResource(bundle: R.hostingBundle, name: "novawallet.release", pathExtension: "xcconfig")
    /// Resource file `novawallet.staging.xcconfig`.
    static let novawalletStagingXcconfig = Rswift.FileResource(bundle: R.hostingBundle, name: "novawallet.staging", pathExtension: "xcconfig")
    /// Resource file `runtime-default.json`.
    static let runtimeDefaultJson = Rswift.FileResource(bundle: R.hostingBundle, name: "runtime-default", pathExtension: "json")
    /// Resource file `runtime-kusama.json`.
    static let runtimeKusamaJson = Rswift.FileResource(bundle: R.hostingBundle, name: "runtime-kusama", pathExtension: "json")
    /// Resource file `runtime-polkadot.json`.
    static let runtimePolkadotJson = Rswift.FileResource(bundle: R.hostingBundle, name: "runtime-polkadot", pathExtension: "json")
    /// Resource file `runtime-rococo.json`.
    static let runtimeRococoJson = Rswift.FileResource(bundle: R.hostingBundle, name: "runtime-rococo", pathExtension: "json")
    /// Resource file `runtime-westend.json`.
    static let runtimeWestendJson = Rswift.FileResource(bundle: R.hostingBundle, name: "runtime-westend", pathExtension: "json")

    /// `bundle.url(forResource: "CIKeys", withExtension: "stencil")`
    static func ciKeysStencil(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.ciKeysStencil
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "PublicSans-Bold", withExtension: "otf")`
    static func publicSansBoldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.publicSansBoldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "PublicSans-ExtraBold", withExtension: "otf")`
    static func publicSansExtraBoldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.publicSansExtraBoldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "PublicSans-ExtraLight", withExtension: "otf")`
    static func publicSansExtraLightOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.publicSansExtraLightOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "PublicSans-Medium", withExtension: "otf")`
    static func publicSansMediumOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.publicSansMediumOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "PublicSans-Regular", withExtension: "otf")`
    static func publicSansRegularOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.publicSansRegularOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "PublicSans-SemiBold", withExtension: "otf")`
    static func publicSansSemiBoldOtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.publicSansSemiBoldOtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "metamask_min", withExtension: "js")`
    static func metamask_minJs(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.metamask_minJs
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "nova_min", withExtension: "js")`
    static func nova_minJs(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.nova_minJs
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "novawallet.debug", withExtension: "xcconfig")`
    static func novawalletDebugXcconfig(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.novawalletDebugXcconfig
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "novawallet.dev", withExtension: "xcconfig")`
    static func novawalletDevXcconfig(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.novawalletDevXcconfig
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "novawallet.release", withExtension: "xcconfig")`
    static func novawalletReleaseXcconfig(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.novawalletReleaseXcconfig
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "novawallet.staging", withExtension: "xcconfig")`
    static func novawalletStagingXcconfig(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.novawalletStagingXcconfig
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "runtime-default", withExtension: "json")`
    static func runtimeDefaultJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.runtimeDefaultJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "runtime-kusama", withExtension: "json")`
    static func runtimeKusamaJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.runtimeKusamaJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "runtime-polkadot", withExtension: "json")`
    static func runtimePolkadotJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.runtimePolkadotJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "runtime-rococo", withExtension: "json")`
    static func runtimeRococoJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.runtimeRococoJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "runtime-westend", withExtension: "json")`
    static func runtimeWestendJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.runtimeWestendJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 6 fonts.
  struct font: Rswift.Validatable {
    /// Font `PublicSans-Bold`.
    static let publicSansBold = Rswift.FontResource(fontName: "PublicSans-Bold")
    /// Font `PublicSans-ExtraBold`.
    static let publicSansExtraBold = Rswift.FontResource(fontName: "PublicSans-ExtraBold")
    /// Font `PublicSans-ExtraLight`.
    static let publicSansExtraLight = Rswift.FontResource(fontName: "PublicSans-ExtraLight")
    /// Font `PublicSans-Medium`.
    static let publicSansMedium = Rswift.FontResource(fontName: "PublicSans-Medium")
    /// Font `PublicSans-Regular`.
    static let publicSansRegular = Rswift.FontResource(fontName: "PublicSans-Regular")
    /// Font `PublicSans-SemiBold`.
    static let publicSansSemiBold = Rswift.FontResource(fontName: "PublicSans-SemiBold")

    /// `UIFont(name: "PublicSans-Bold", size: ...)`
    static func publicSansBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: publicSansBold, size: size)
    }

    /// `UIFont(name: "PublicSans-ExtraBold", size: ...)`
    static func publicSansExtraBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: publicSansExtraBold, size: size)
    }

    /// `UIFont(name: "PublicSans-ExtraLight", size: ...)`
    static func publicSansExtraLight(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: publicSansExtraLight, size: size)
    }

    /// `UIFont(name: "PublicSans-Medium", size: ...)`
    static func publicSansMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: publicSansMedium, size: size)
    }

    /// `UIFont(name: "PublicSans-Regular", size: ...)`
    static func publicSansRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: publicSansRegular, size: size)
    }

    /// `UIFont(name: "PublicSans-SemiBold", size: ...)`
    static func publicSansSemiBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: publicSansSemiBold, size: size)
    }

    static func validate() throws {
      if R.font.publicSansBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'PublicSans-Bold' could not be loaded, is 'PublicSans-Bold.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.publicSansExtraBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'PublicSans-ExtraBold' could not be loaded, is 'PublicSans-ExtraBold.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.publicSansExtraLight(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'PublicSans-ExtraLight' could not be loaded, is 'PublicSans-ExtraLight.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.publicSansMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'PublicSans-Medium' could not be loaded, is 'PublicSans-Medium.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.publicSansRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'PublicSans-Regular' could not be loaded, is 'PublicSans-Regular.otf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.publicSansSemiBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'PublicSans-SemiBold' could not be loaded, is 'PublicSans-SemiBold.otf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 133 images.
  struct image {
    /// Image `iconAboutArrow`.
    static let iconAboutArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconAboutArrow")
    /// Image `iconAccount`.
    static let iconAccount = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconAccount")
    /// Image `iconActionIndicator`.
    static let iconActionIndicator = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconActionIndicator")
    /// Image `iconAddressPlaceholder`.
    static let iconAddressPlaceholder = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconAddressPlaceholder")
    /// Image `iconAlert`.
    static let iconAlert = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconAlert")
    /// Image `iconAlgoItem`.
    static let iconAlgoItem = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconAlgoItem")
    /// Image `iconArrowUp`.
    static let iconArrowUp = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconArrowUp")
    /// Image `iconAssetsSettings`.
    static let iconAssetsSettings = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconAssetsSettings")
    /// Image `iconBack`.
    static let iconBack = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBack")
    /// Image `iconBannerCalendar`.
    static let iconBannerCalendar = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBannerCalendar")
    /// Image `iconBannerShield`.
    static let iconBannerShield = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBannerShield")
    /// Image `iconBannerStar`.
    static let iconBannerStar = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBannerStar")
    /// Image `iconBondMore`.
    static let iconBondMore = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBondMore")
    /// Image `iconBonus`.
    static let iconBonus = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBonus")
    /// Image `iconBrowserBack`.
    static let iconBrowserBack = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBrowserBack")
    /// Image `iconBrowserForward`.
    static let iconBrowserForward = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBrowserForward")
    /// Image `iconBrowserSecurity`.
    static let iconBrowserSecurity = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBrowserSecurity")
    /// Image `iconBuy`.
    static let iconBuy = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconBuy")
    /// Image `iconCellClose`.
    static let iconCellClose = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconCellClose")
    /// Image `iconCheckboxEmpty`.
    static let iconCheckboxEmpty = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconCheckboxEmpty")
    /// Image `iconCheckbox`.
    static let iconCheckbox = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconCheckbox")
    /// Image `iconCheckmark`.
    static let iconCheckmark = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconCheckmark")
    /// Image `iconChevronRight`.
    static let iconChevronRight = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconChevronRight")
    /// Image `iconClearField`.
    static let iconClearField = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconClearField")
    /// Image `iconClose`.
    static let iconClose = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconClose")
    /// Image `iconCopy`.
    static let iconCopy = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconCopy")
    /// Image `iconDappAccess`.
    static let iconDappAccess = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconDappAccess")
    /// Image `iconDappExtension`.
    static let iconDappExtension = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconDappExtension")
    /// Image `iconDefaultDapp`.
    static let iconDefaultDapp = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconDefaultDapp")
    /// Image `iconEmail`.
    static let iconEmail = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconEmail")
    /// Image `iconEmptyHistory`.
    static let iconEmptyHistory = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconEmptyHistory")
    /// Image `iconEmptySearch`.
    static let iconEmptySearch = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconEmptySearch")
    /// Image `iconErrorFilled`.
    static let iconErrorFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconErrorFilled")
    /// Image `iconEye`.
    static let iconEye = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconEye")
    /// Image `iconFavButtonSel`.
    static let iconFavButtonSel = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFavButtonSel")
    /// Image `iconFavButton`.
    static let iconFavButton = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFavButton")
    /// Image `iconFavNotSelected`.
    static let iconFavNotSelected = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFavNotSelected")
    /// Image `iconFavSelected`.
    static let iconFavSelected = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFavSelected")
    /// Image `iconFavToolbarSel`.
    static let iconFavToolbarSel = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFavToolbarSel")
    /// Image `iconFavToolbar`.
    static let iconFavToolbar = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFavToolbar")
    /// Image `iconFilterActive`.
    static let iconFilterActive = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFilterActive")
    /// Image `iconFilter`.
    static let iconFilter = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconFilter")
    /// Image `iconGithub`.
    static let iconGithub = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconGithub")
    /// Image `iconImagePlaceholder`.
    static let iconImagePlaceholder = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconImagePlaceholder")
    /// Image `iconImportWallet`.
    static let iconImportWallet = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconImportWallet")
    /// Image `iconIncomingTransfer`.
    static let iconIncomingTransfer = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconIncomingTransfer")
    /// Image `iconInfoFilled`.
    static let iconInfoFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconInfoFilled")
    /// Image `iconInfo`.
    static let iconInfo = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconInfo")
    /// Image `iconInvalid`.
    static let iconInvalid = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconInvalid")
    /// Image `iconKeyboardOff`.
    static let iconKeyboardOff = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconKeyboardOff")
    /// Image `iconKsmAsset`.
    static let iconKsmAsset = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconKsmAsset")
    /// Image `iconKsmSmallBg`.
    static let iconKsmSmallBg = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconKsmSmallBg")
    /// Image `iconLanguage`.
    static let iconLanguage = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconLanguage")
    /// Image `iconLightPending`.
    static let iconLightPending = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconLightPending")
    /// Image `iconLinkChevron`.
    static let iconLinkChevron = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconLinkChevron")
    /// Image `iconList`.
    static let iconList = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconList")
    /// Image `iconLoadingError`.
    static let iconLoadingError = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconLoadingError")
    /// Image `iconLoadingIndicator`.
    static let iconLoadingIndicator = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconLoadingIndicator")
    /// Image `iconLock`.
    static let iconLock = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconLock")
    /// Image `iconMnemonic`.
    static let iconMnemonic = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconMnemonic")
    /// Image `iconMoonPay`.
    static let iconMoonPay = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconMoonPay")
    /// Image `iconMore`.
    static let iconMore = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconMore")
    /// Image `iconNetworks`.
    static let iconNetworks = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconNetworks")
    /// Image `iconNoEye`.
    static let iconNoEye = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconNoEye")
    /// Image `iconNovaSmall`.
    static let iconNovaSmall = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconNovaSmall")
    /// Image `iconOptions`.
    static let iconOptions = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconOptions")
    /// Image `iconOutgoingTransfer`.
    static let iconOutgoingTransfer = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconOutgoingTransfer")
    /// Image `iconPendingRewards`.
    static let iconPendingRewards = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconPendingRewards")
    /// Image `iconPending`.
    static let iconPending = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconPending")
    /// Image `iconPinCode`.
    static let iconPinCode = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconPinCode")
    /// Image `iconPlusFilled`.
    static let iconPlusFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconPlusFilled")
    /// Image `iconPolkadotSmallBg`.
    static let iconPolkadotSmallBg = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconPolkadotSmallBg")
    /// Image `iconQRFrame`.
    static let iconQRFrame = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconQRFrame")
    /// Image `iconRadioButtonSelected`.
    static let iconRadioButtonSelected = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRadioButtonSelected")
    /// Image `iconRadioButtonUnselected`.
    static let iconRadioButtonUnselected = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRadioButtonUnselected")
    /// Image `iconRamp`.
    static let iconRamp = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRamp")
    /// Image `iconReceive`.
    static let iconReceive = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconReceive")
    /// Image `iconRedeem`.
    static let iconRedeem = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRedeem")
    /// Image `iconRefresh`.
    static let iconRefresh = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRefresh")
    /// Image `iconRestoreJson`.
    static let iconRestoreJson = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRestoreJson")
    /// Image `iconRetry`.
    static let iconRetry = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRetry")
    /// Image `iconRewardOperation`.
    static let iconRewardOperation = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconRewardOperation")
    /// Image `iconScanQr`.
    static let iconScanQr = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconScanQr")
    /// Image `iconSearchHappy`.
    static let iconSearchHappy = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSearchHappy")
    /// Image `iconSearchWhite`.
    static let iconSearchWhite = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSearchWhite")
    /// Image `iconSearch`.
    static let iconSearch = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSearch")
    /// Image `iconSeed`.
    static let iconSeed = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSeed")
    /// Image `iconSend`.
    static let iconSend = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSend")
    /// Image `iconShare`.
    static let iconShare = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconShare")
    /// Image `iconSlash`.
    static let iconSlash = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSlash")
    /// Image `iconSmallAdd`.
    static let iconSmallAdd = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSmallAdd")
    /// Image `iconSmallArrowDown`.
    static let iconSmallArrowDown = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSmallArrowDown")
    /// Image `iconSmallArrow`.
    static let iconSmallArrow = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSmallArrow")
    /// Image `iconStakingTransactionType`.
    static let iconStakingTransactionType = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconStakingTransactionType")
    /// Image `iconStarGray16`.
    static let iconStarGray16 = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconStarGray16")
    /// Image `iconStarGray32`.
    static let iconStarGray32 = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconStarGray32")
    /// Image `iconStar`.
    static let iconStar = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconStar")
    /// Image `iconStartSearch`.
    static let iconStartSearch = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconStartSearch")
    /// Image `iconSubid`.
    static let iconSubid = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconSubid")
    /// Image `iconTabCrowloanFilled`.
    static let iconTabCrowloanFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabCrowloanFilled")
    /// Image `iconTabCrowloan`.
    static let iconTabCrowloan = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabCrowloan")
    /// Image `iconTabDAppsFilled`.
    static let iconTabDAppsFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabDAppsFilled")
    /// Image `iconTabDApps`.
    static let iconTabDApps = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabDApps")
    /// Image `iconTabSettingsFilled`.
    static let iconTabSettingsFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabSettingsFilled")
    /// Image `iconTabSettings`.
    static let iconTabSettings = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabSettings")
    /// Image `iconTabStakingFilled`.
    static let iconTabStakingFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabStakingFilled")
    /// Image `iconTabStaking`.
    static let iconTabStaking = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabStaking")
    /// Image `iconTabWalletFilled`.
    static let iconTabWalletFilled = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabWalletFilled")
    /// Image `iconTabWallet`.
    static let iconTabWallet = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTabWallet")
    /// Image `iconTelegram`.
    static let iconTelegram = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTelegram")
    /// Image `iconTerms`.
    static let iconTerms = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTerms")
    /// Image `iconTransak`.
    static let iconTransak = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTransak")
    /// Image `iconTransferScan`.
    static let iconTransferScan = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTransferScan")
    /// Image `iconTwitter`.
    static let iconTwitter = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconTwitter")
    /// Image `iconUnbond`.
    static let iconUnbond = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconUnbond")
    /// Image `iconUpload`.
    static let iconUpload = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconUpload")
    /// Image `iconValidBig`.
    static let iconValidBig = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconValidBig")
    /// Image `iconValid`.
    static let iconValid = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconValid")
    /// Image `iconValidators`.
    static let iconValidators = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconValidators")
    /// Image `iconWallet`.
    static let iconWallet = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconWallet")
    /// Image `iconWallets`.
    static let iconWallets = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconWallets")
    /// Image `iconWarningApp`.
    static let iconWarningApp = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconWarningApp")
    /// Image `iconWarning`.
    static let iconWarning = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconWarning")
    /// Image `iconWebsite`.
    static let iconWebsite = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconWebsite")
    /// Image `iconWestendSmallBg`.
    static let iconWestendSmallBg = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconWestendSmallBg")
    /// Image `iconYoutube`.
    static let iconYoutube = Rswift.ImageResource(bundle: R.hostingBundle, name: "iconYoutube")
    /// Image `imageDapps`.
    static let imageDapps = Rswift.ImageResource(bundle: R.hostingBundle, name: "imageDapps")
    /// Image `imageStakingReward`.
    static let imageStakingReward = Rswift.ImageResource(bundle: R.hostingBundle, name: "imageStakingReward")
    /// Image `logo`.
    static let logo = Rswift.ImageResource(bundle: R.hostingBundle, name: "logo")
    /// Image `novabg-splash`.
    static let novabgSplash = Rswift.ImageResource(bundle: R.hostingBundle, name: "novabg-splash")
    /// Image `pinBackspace`.
    static let pinBackspace = Rswift.ImageResource(bundle: R.hostingBundle, name: "pinBackspace")
    /// Image `pinFaceId`.
    static let pinFaceId = Rswift.ImageResource(bundle: R.hostingBundle, name: "pinFaceId")
    /// Image `pinFingerprint`.
    static let pinFingerprint = Rswift.ImageResource(bundle: R.hostingBundle, name: "pinFingerprint")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconAboutArrow", bundle: ..., traitCollection: ...)`
    static func iconAboutArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconAboutArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconAccount", bundle: ..., traitCollection: ...)`
    static func iconAccount(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconAccount, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconActionIndicator", bundle: ..., traitCollection: ...)`
    static func iconActionIndicator(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconActionIndicator, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconAddressPlaceholder", bundle: ..., traitCollection: ...)`
    static func iconAddressPlaceholder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconAddressPlaceholder, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconAlert", bundle: ..., traitCollection: ...)`
    static func iconAlert(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconAlert, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconAlgoItem", bundle: ..., traitCollection: ...)`
    static func iconAlgoItem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconAlgoItem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconArrowUp", bundle: ..., traitCollection: ...)`
    static func iconArrowUp(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconArrowUp, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconAssetsSettings", bundle: ..., traitCollection: ...)`
    static func iconAssetsSettings(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconAssetsSettings, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBack", bundle: ..., traitCollection: ...)`
    static func iconBack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBack, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBannerCalendar", bundle: ..., traitCollection: ...)`
    static func iconBannerCalendar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBannerCalendar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBannerShield", bundle: ..., traitCollection: ...)`
    static func iconBannerShield(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBannerShield, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBannerStar", bundle: ..., traitCollection: ...)`
    static func iconBannerStar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBannerStar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBondMore", bundle: ..., traitCollection: ...)`
    static func iconBondMore(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBondMore, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBonus", bundle: ..., traitCollection: ...)`
    static func iconBonus(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBonus, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBrowserBack", bundle: ..., traitCollection: ...)`
    static func iconBrowserBack(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBrowserBack, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBrowserForward", bundle: ..., traitCollection: ...)`
    static func iconBrowserForward(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBrowserForward, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBrowserSecurity", bundle: ..., traitCollection: ...)`
    static func iconBrowserSecurity(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBrowserSecurity, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconBuy", bundle: ..., traitCollection: ...)`
    static func iconBuy(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconBuy, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconCellClose", bundle: ..., traitCollection: ...)`
    static func iconCellClose(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconCellClose, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconCheckbox", bundle: ..., traitCollection: ...)`
    static func iconCheckbox(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconCheckbox, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconCheckboxEmpty", bundle: ..., traitCollection: ...)`
    static func iconCheckboxEmpty(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconCheckboxEmpty, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconCheckmark", bundle: ..., traitCollection: ...)`
    static func iconCheckmark(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconCheckmark, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconChevronRight", bundle: ..., traitCollection: ...)`
    static func iconChevronRight(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconChevronRight, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconClearField", bundle: ..., traitCollection: ...)`
    static func iconClearField(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconClearField, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconClose", bundle: ..., traitCollection: ...)`
    static func iconClose(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconClose, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconCopy", bundle: ..., traitCollection: ...)`
    static func iconCopy(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconCopy, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconDappAccess", bundle: ..., traitCollection: ...)`
    static func iconDappAccess(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconDappAccess, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconDappExtension", bundle: ..., traitCollection: ...)`
    static func iconDappExtension(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconDappExtension, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconDefaultDapp", bundle: ..., traitCollection: ...)`
    static func iconDefaultDapp(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconDefaultDapp, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconEmail", bundle: ..., traitCollection: ...)`
    static func iconEmail(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconEmail, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconEmptyHistory", bundle: ..., traitCollection: ...)`
    static func iconEmptyHistory(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconEmptyHistory, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconEmptySearch", bundle: ..., traitCollection: ...)`
    static func iconEmptySearch(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconEmptySearch, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconErrorFilled", bundle: ..., traitCollection: ...)`
    static func iconErrorFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconErrorFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconEye", bundle: ..., traitCollection: ...)`
    static func iconEye(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconEye, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFavButton", bundle: ..., traitCollection: ...)`
    static func iconFavButton(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFavButton, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFavButtonSel", bundle: ..., traitCollection: ...)`
    static func iconFavButtonSel(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFavButtonSel, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFavNotSelected", bundle: ..., traitCollection: ...)`
    static func iconFavNotSelected(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFavNotSelected, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFavSelected", bundle: ..., traitCollection: ...)`
    static func iconFavSelected(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFavSelected, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFavToolbar", bundle: ..., traitCollection: ...)`
    static func iconFavToolbar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFavToolbar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFavToolbarSel", bundle: ..., traitCollection: ...)`
    static func iconFavToolbarSel(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFavToolbarSel, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFilter", bundle: ..., traitCollection: ...)`
    static func iconFilter(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFilter, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconFilterActive", bundle: ..., traitCollection: ...)`
    static func iconFilterActive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconFilterActive, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconGithub", bundle: ..., traitCollection: ...)`
    static func iconGithub(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconGithub, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconImagePlaceholder", bundle: ..., traitCollection: ...)`
    static func iconImagePlaceholder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconImagePlaceholder, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconImportWallet", bundle: ..., traitCollection: ...)`
    static func iconImportWallet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconImportWallet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconIncomingTransfer", bundle: ..., traitCollection: ...)`
    static func iconIncomingTransfer(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconIncomingTransfer, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconInfo", bundle: ..., traitCollection: ...)`
    static func iconInfo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconInfo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconInfoFilled", bundle: ..., traitCollection: ...)`
    static func iconInfoFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconInfoFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconInvalid", bundle: ..., traitCollection: ...)`
    static func iconInvalid(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconInvalid, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconKeyboardOff", bundle: ..., traitCollection: ...)`
    static func iconKeyboardOff(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconKeyboardOff, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconKsmAsset", bundle: ..., traitCollection: ...)`
    static func iconKsmAsset(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconKsmAsset, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconKsmSmallBg", bundle: ..., traitCollection: ...)`
    static func iconKsmSmallBg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconKsmSmallBg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconLanguage", bundle: ..., traitCollection: ...)`
    static func iconLanguage(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconLanguage, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconLightPending", bundle: ..., traitCollection: ...)`
    static func iconLightPending(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconLightPending, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconLinkChevron", bundle: ..., traitCollection: ...)`
    static func iconLinkChevron(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconLinkChevron, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconList", bundle: ..., traitCollection: ...)`
    static func iconList(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconList, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconLoadingError", bundle: ..., traitCollection: ...)`
    static func iconLoadingError(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconLoadingError, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconLoadingIndicator", bundle: ..., traitCollection: ...)`
    static func iconLoadingIndicator(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconLoadingIndicator, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconLock", bundle: ..., traitCollection: ...)`
    static func iconLock(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconLock, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconMnemonic", bundle: ..., traitCollection: ...)`
    static func iconMnemonic(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconMnemonic, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconMoonPay", bundle: ..., traitCollection: ...)`
    static func iconMoonPay(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconMoonPay, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconMore", bundle: ..., traitCollection: ...)`
    static func iconMore(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconMore, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconNetworks", bundle: ..., traitCollection: ...)`
    static func iconNetworks(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconNetworks, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconNoEye", bundle: ..., traitCollection: ...)`
    static func iconNoEye(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconNoEye, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconNovaSmall", bundle: ..., traitCollection: ...)`
    static func iconNovaSmall(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconNovaSmall, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconOptions", bundle: ..., traitCollection: ...)`
    static func iconOptions(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconOptions, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconOutgoingTransfer", bundle: ..., traitCollection: ...)`
    static func iconOutgoingTransfer(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconOutgoingTransfer, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconPending", bundle: ..., traitCollection: ...)`
    static func iconPending(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconPending, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconPendingRewards", bundle: ..., traitCollection: ...)`
    static func iconPendingRewards(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconPendingRewards, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconPinCode", bundle: ..., traitCollection: ...)`
    static func iconPinCode(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconPinCode, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconPlusFilled", bundle: ..., traitCollection: ...)`
    static func iconPlusFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconPlusFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconPolkadotSmallBg", bundle: ..., traitCollection: ...)`
    static func iconPolkadotSmallBg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconPolkadotSmallBg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconQRFrame", bundle: ..., traitCollection: ...)`
    static func iconQRFrame(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconQRFrame, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRadioButtonSelected", bundle: ..., traitCollection: ...)`
    static func iconRadioButtonSelected(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRadioButtonSelected, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRadioButtonUnselected", bundle: ..., traitCollection: ...)`
    static func iconRadioButtonUnselected(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRadioButtonUnselected, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRamp", bundle: ..., traitCollection: ...)`
    static func iconRamp(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRamp, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconReceive", bundle: ..., traitCollection: ...)`
    static func iconReceive(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconReceive, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRedeem", bundle: ..., traitCollection: ...)`
    static func iconRedeem(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRedeem, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRefresh", bundle: ..., traitCollection: ...)`
    static func iconRefresh(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRefresh, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRestoreJson", bundle: ..., traitCollection: ...)`
    static func iconRestoreJson(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRestoreJson, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRetry", bundle: ..., traitCollection: ...)`
    static func iconRetry(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRetry, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconRewardOperation", bundle: ..., traitCollection: ...)`
    static func iconRewardOperation(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconRewardOperation, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconScanQr", bundle: ..., traitCollection: ...)`
    static func iconScanQr(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconScanQr, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSearch", bundle: ..., traitCollection: ...)`
    static func iconSearch(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSearch, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSearchHappy", bundle: ..., traitCollection: ...)`
    static func iconSearchHappy(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSearchHappy, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSearchWhite", bundle: ..., traitCollection: ...)`
    static func iconSearchWhite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSearchWhite, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSeed", bundle: ..., traitCollection: ...)`
    static func iconSeed(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSeed, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSend", bundle: ..., traitCollection: ...)`
    static func iconSend(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSend, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconShare", bundle: ..., traitCollection: ...)`
    static func iconShare(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconShare, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSlash", bundle: ..., traitCollection: ...)`
    static func iconSlash(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSlash, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSmallAdd", bundle: ..., traitCollection: ...)`
    static func iconSmallAdd(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSmallAdd, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSmallArrow", bundle: ..., traitCollection: ...)`
    static func iconSmallArrow(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSmallArrow, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSmallArrowDown", bundle: ..., traitCollection: ...)`
    static func iconSmallArrowDown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSmallArrowDown, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconStakingTransactionType", bundle: ..., traitCollection: ...)`
    static func iconStakingTransactionType(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconStakingTransactionType, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconStar", bundle: ..., traitCollection: ...)`
    static func iconStar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconStar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconStarGray16", bundle: ..., traitCollection: ...)`
    static func iconStarGray16(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconStarGray16, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconStarGray32", bundle: ..., traitCollection: ...)`
    static func iconStarGray32(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconStarGray32, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconStartSearch", bundle: ..., traitCollection: ...)`
    static func iconStartSearch(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconStartSearch, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconSubid", bundle: ..., traitCollection: ...)`
    static func iconSubid(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconSubid, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabCrowloan", bundle: ..., traitCollection: ...)`
    static func iconTabCrowloan(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabCrowloan, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabCrowloanFilled", bundle: ..., traitCollection: ...)`
    static func iconTabCrowloanFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabCrowloanFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabDApps", bundle: ..., traitCollection: ...)`
    static func iconTabDApps(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabDApps, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabDAppsFilled", bundle: ..., traitCollection: ...)`
    static func iconTabDAppsFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabDAppsFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabSettings", bundle: ..., traitCollection: ...)`
    static func iconTabSettings(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabSettings, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabSettingsFilled", bundle: ..., traitCollection: ...)`
    static func iconTabSettingsFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabSettingsFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabStaking", bundle: ..., traitCollection: ...)`
    static func iconTabStaking(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabStaking, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabStakingFilled", bundle: ..., traitCollection: ...)`
    static func iconTabStakingFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabStakingFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabWallet", bundle: ..., traitCollection: ...)`
    static func iconTabWallet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabWallet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTabWalletFilled", bundle: ..., traitCollection: ...)`
    static func iconTabWalletFilled(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTabWalletFilled, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTelegram", bundle: ..., traitCollection: ...)`
    static func iconTelegram(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTelegram, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTerms", bundle: ..., traitCollection: ...)`
    static func iconTerms(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTerms, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTransak", bundle: ..., traitCollection: ...)`
    static func iconTransak(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTransak, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTransferScan", bundle: ..., traitCollection: ...)`
    static func iconTransferScan(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTransferScan, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconTwitter", bundle: ..., traitCollection: ...)`
    static func iconTwitter(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconTwitter, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconUnbond", bundle: ..., traitCollection: ...)`
    static func iconUnbond(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconUnbond, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconUpload", bundle: ..., traitCollection: ...)`
    static func iconUpload(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconUpload, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconValid", bundle: ..., traitCollection: ...)`
    static func iconValid(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconValid, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconValidBig", bundle: ..., traitCollection: ...)`
    static func iconValidBig(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconValidBig, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconValidators", bundle: ..., traitCollection: ...)`
    static func iconValidators(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconValidators, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconWallet", bundle: ..., traitCollection: ...)`
    static func iconWallet(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconWallet, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconWallets", bundle: ..., traitCollection: ...)`
    static func iconWallets(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconWallets, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconWarning", bundle: ..., traitCollection: ...)`
    static func iconWarning(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconWarning, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconWarningApp", bundle: ..., traitCollection: ...)`
    static func iconWarningApp(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconWarningApp, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconWebsite", bundle: ..., traitCollection: ...)`
    static func iconWebsite(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconWebsite, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconWestendSmallBg", bundle: ..., traitCollection: ...)`
    static func iconWestendSmallBg(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconWestendSmallBg, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "iconYoutube", bundle: ..., traitCollection: ...)`
    static func iconYoutube(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.iconYoutube, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "imageDapps", bundle: ..., traitCollection: ...)`
    static func imageDapps(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.imageDapps, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "imageStakingReward", bundle: ..., traitCollection: ...)`
    static func imageStakingReward(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.imageStakingReward, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "logo", bundle: ..., traitCollection: ...)`
    static func logo(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.logo, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "novabg-splash", bundle: ..., traitCollection: ...)`
    static func novabgSplash(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.novabgSplash, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pinBackspace", bundle: ..., traitCollection: ...)`
    static func pinBackspace(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pinBackspace, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pinFaceId", bundle: ..., traitCollection: ...)`
    static func pinFaceId(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pinFaceId, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pinFingerprint", bundle: ..., traitCollection: ...)`
    static func pinFingerprint(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pinFingerprint, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 21 nibs.
  struct nib {
    /// Nib `AccountConfirmViewController`.
    static let accountConfirmViewController = _R.nib._AccountConfirmViewController()
    /// Nib `AccountManagementViewController`.
    static let accountManagementViewController = _R.nib._AccountManagementViewController()
    /// Nib `AssetDetailsView`.
    static let assetDetailsView = _R.nib._AssetDetailsView()
    /// Nib `DetailsDisplayTableViewCell`.
    static let detailsDisplayTableViewCell = _R.nib._DetailsDisplayTableViewCell()
    /// Nib `IconWithTitleTableViewCell`.
    static let iconWithTitleTableViewCell = _R.nib._IconWithTitleTableViewCell()
    /// Nib `ModalPickerViewController`.
    static let modalPickerViewController = _R.nib._ModalPickerViewController()
    /// Nib `OnbordingMain`.
    static let onbordingMain = _R.nib._OnbordingMain()
    /// Nib `PinSetupViewController`.
    static let pinSetupViewController = _R.nib._PinSetupViewController()
    /// Nib `PurchaseProviderPickerTableViewCell`.
    static let purchaseProviderPickerTableViewCell = _R.nib._PurchaseProviderPickerTableViewCell()
    /// Nib `SelectionListViewController`.
    static let selectionListViewController = _R.nib._SelectionListViewController()
    /// Nib `StakingMainViewController`.
    static let stakingMainViewController = _R.nib._StakingMainViewController()
    /// Nib `TitleWithSubtitleTableViewCell`.
    static let titleWithSubtitleTableViewCell = _R.nib._TitleWithSubtitleTableViewCell()
    /// Nib `WalletAmountView`.
    static let walletAmountView = _R.nib._WalletAmountView()
    /// Nib `WalletCompoundDetailsView`.
    static let walletCompoundDetailsView = _R.nib._WalletCompoundDetailsView()
    /// Nib `WalletManagementViewController`.
    static let walletManagementViewController = _R.nib._WalletManagementViewController()
    /// Nib `WalletSingleActionAccessoryView`.
    static let walletSingleActionAccessoryView = _R.nib._WalletSingleActionAccessoryView()
    /// Nib `WalletTokenView`.
    static let walletTokenView = _R.nib._WalletTokenView()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AccountConfirmViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.accountConfirmViewController) instead")
    static func accountConfirmViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.accountConfirmViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AccountManagementViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.accountManagementViewController) instead")
    static func accountManagementViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.accountManagementViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "AssetDetailsView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.assetDetailsView) instead")
    static func assetDetailsView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.assetDetailsView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "DetailsDisplayTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.detailsDisplayTableViewCell) instead")
    static func detailsDisplayTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.detailsDisplayTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "IconWithTitleTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.iconWithTitleTableViewCell) instead")
    static func iconWithTitleTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.iconWithTitleTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "ModalPickerViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.modalPickerViewController) instead")
    static func modalPickerViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.modalPickerViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "OnbordingMain", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.onbordingMain) instead")
    static func onbordingMain(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.onbordingMain)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PinSetupViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.pinSetupViewController) instead")
    static func pinSetupViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.pinSetupViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PurchaseProviderPickerTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.purchaseProviderPickerTableViewCell) instead")
    static func purchaseProviderPickerTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.purchaseProviderPickerTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SelectionListViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.selectionListViewController) instead")
    static func selectionListViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.selectionListViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "StakingMainViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.stakingMainViewController) instead")
    static func stakingMainViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.stakingMainViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TitleWithSubtitleTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.titleWithSubtitleTableViewCell) instead")
    static func titleWithSubtitleTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.titleWithSubtitleTableViewCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "WalletAmountView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.walletAmountView) instead")
    static func walletAmountView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.walletAmountView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "WalletCompoundDetailsView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.walletCompoundDetailsView) instead")
    static func walletCompoundDetailsView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.walletCompoundDetailsView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "WalletManagementViewController", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.walletManagementViewController) instead")
    static func walletManagementViewController(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.walletManagementViewController)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "WalletSingleActionAccessoryView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.walletSingleActionAccessoryView) instead")
    static func walletSingleActionAccessoryView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.walletSingleActionAccessoryView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "WalletTokenView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.walletTokenView) instead")
    static func walletTokenView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.walletTokenView)
    }
    #endif

    static func accountConfirmViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.accountConfirmViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func accountManagementViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.accountManagementViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func modalPickerViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.modalPickerViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func onbordingMain(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.onbordingMain.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func pinSetupViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.pinSetupViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func selectionListViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.selectionListViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func stakingMainViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.stakingMainViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func walletAmountView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.walletAmountView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func walletManagementViewController(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.walletManagementViewController.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    static func walletTokenView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
      return R.nib.walletTokenView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 4 reuse identifiers.
  struct reuseIdentifier {
    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 2 localization tables.
  struct string {
    /// This `R.string.infoPlist` struct is generated, and contains static references to 4 localization keys.
    struct infoPlist {
      /// en translation: Camera is used to capture QR code
      ///
      /// Locales: en, ru
      static let nsCameraUsageDescription = Rswift.StringResource(key: "NSCameraUsageDescription", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Face ID is used to authorize in application
      ///
      /// Locales: en, ru
      static let nsFaceIDUsageDescription = Rswift.StringResource(key: "NSFaceIDUsageDescription", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Load photos from library
      ///
      /// Locales: en, ru
      static let nsPhotoLibraryUsageDescription = Rswift.StringResource(key: "NSPhotoLibraryUsageDescription", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Save transfer request as a qr code
      ///
      /// Locales: en, ru
      static let nsPhotoLibraryAddUsageDescription = Rswift.StringResource(key: "NSPhotoLibraryAddUsageDescription", tableName: "InfoPlist", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)

      /// en translation: Camera is used to capture QR code
      ///
      /// Locales: en, ru
      static func nsCameraUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSCameraUsageDescription", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "NSCameraUsageDescription"
        }

        return NSLocalizedString("NSCameraUsageDescription", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      /// en translation: Face ID is used to authorize in application
      ///
      /// Locales: en, ru
      static func nsFaceIDUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSFaceIDUsageDescription", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "NSFaceIDUsageDescription"
        }

        return NSLocalizedString("NSFaceIDUsageDescription", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      /// en translation: Load photos from library
      ///
      /// Locales: en, ru
      static func nsPhotoLibraryUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSPhotoLibraryUsageDescription", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "NSPhotoLibraryUsageDescription"
        }

        return NSLocalizedString("NSPhotoLibraryUsageDescription", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      /// en translation: Save transfer request as a qr code
      ///
      /// Locales: en, ru
      static func nsPhotoLibraryAddUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSPhotoLibraryAddUsageDescription", tableName: "InfoPlist", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "InfoPlist", preferredLanguages: preferredLanguages) else {
          return "NSPhotoLibraryAddUsageDescription"
        }

        return NSLocalizedString("NSPhotoLibraryAddUsageDescription", tableName: "InfoPlist", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    /// This `R.string.localizable` struct is generated, and contains static references to 761 localization keys.
    struct localizable {
      /// en translation: 
      ///
      /// Locales: en, ru
      static let usernameSetupHint = Rswift.StringResource(key: "username.setup.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 
      ///
      /// Locales: en, ru
      static let usernameSetupTitle = Rswift.StringResource(key: "username.setup.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: #%@
      ///
      /// Locales: en, ru
      static let commonEraFormat = Rswift.StringResource(key: "common.era.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: #%@ Edition of %@
      ///
      /// Locales: en, ru
      static let nftListItemLimitedFormat = Rswift.StringResource(key: "nft.list.item.limited.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static let commonDaysFormat = Rswift.StringResource(key: "common.days.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static let commonDaysLeftFormat = Rswift.StringResource(key: "common.days.left.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static let commonHoursFormat = Rswift.StringResource(key: "common.hours.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static let stakingAnalyticsValidatorsErasCounter = Rswift.StringResource(key: "staking.analytics.validators.eras.counter", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ (max %@)
      ///
      /// Locales: en, ru
      static let stakingValidatorInfoNominators = Rswift.StringResource(key: "staking.validator.info.nominators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ (via %@)
      ///
      /// Locales: en, ru
      static let crowdloanCustomContribFormat = Rswift.StringResource(key: "crowdloan.custom.contrib.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ account
      ///
      /// Locales: en, ru
      static let accountNotFoundActionsTitle = Rswift.StringResource(key: "account.not.found.actions.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ avg.
      ///
      /// Locales: en, ru
      static let stakingAnalyticsAvg = Rswift.StringResource(key: "staking.analytics.avg", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ left
      ///
      /// Locales: en, ru
      static let commonTimeLeftFormat = Rswift.StringResource(key: "common.time.left.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ monthly
      ///
      /// Locales: en, ru
      static let stakingMonthPeriodFormat = Rswift.StringResource(key: "staking.month.period.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ network
      ///
      /// Locales: en, ru
      static let stakingMainNetworkTitle = Rswift.StringResource(key: "staking.main.network.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ of %@
      ///
      /// Locales: en, ru
      static let stakingRecommendedValidatorsCounter = Rswift.StringResource(key: "staking.recommended.validators.counter", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ reward destination
      ///
      /// Locales: en, ru
      static let crowdloanRewardDestinationFormat = Rswift.StringResource(key: "crowdloan.reward.destination.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ rewarded
      ///
      /// Locales: en, ru
      static let stakingMaxNominatorRewardedFormat = Rswift.StringResource(key: "staking.max.nominator.rewarded.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ yearly
      ///
      /// Locales: en, ru
      static let stakingYearPeriodFormat = Rswift.StringResource(key: "staking.year.period.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@'s crowdloan website
      ///
      /// Locales: en, ru
      static let crowdloanLearn_v2_2_0 = Rswift.StringResource(key: "crowdloan.learn_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %li of %li eras
      ///
      /// Locales: en, ru
      static let stakingAnalyticsEraRange = Rswift.StringResource(key: "staking.analytics.era.range", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: (BTC/ETH compatible)
      ///
      /// Locales: en, ru
      static let ecdsaSelectionSubtitle = Rswift.StringResource(key: "ecdsa.selection.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 12, 15, 18, 21 or 24-word phrase
      ///
      /// Locales: en, ru
      static let secretTypeMnemonicSubtitle = Rswift.StringResource(key: "secret.type.mnemonic.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 128 hex symbols
      ///
      /// Locales: en, ru
      static let accountImportEthereumSeedPlaceholder_v2_2_0 = Rswift.StringResource(key: "account.import.ethereum.seed.placeholder_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 1y
      ///
      /// Locales: en, ru
      static let stakingAnalyticsPeriod1y = Rswift.StringResource(key: "staking.analytics.period.1y", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 30d
      ///
      /// Locales: en, ru
      static let stakingAnalyticsPeriod30d = Rswift.StringResource(key: "staking.analytics.period.30d", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 64 hex symbols
      ///
      /// Locales: en, ru
      static let accountImportSubstrateSeedPlaceholder_v2_2_0 = Rswift.StringResource(key: "account.import.substrate.seed.placeholder_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 7 days rewards
      ///
      /// Locales: en, ru
      static let stakingAnalytics7daysRewards = Rswift.StringResource(key: "staking.analytics.7days.rewards", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: 7d
      ///
      /// Locales: en, ru
      static let stakingAnalyticsPeriod7d = Rswift.StringResource(key: "staking.analytics.period.7d", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: About
      ///
      /// Locales: en, ru
      static let aboutTitle = Rswift.StringResource(key: "about.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: About
      ///
      /// Locales: en, ru
      static let profileAboutTitle = Rswift.StringResource(key: "profile.about.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: About crowdloans
      ///
      /// Locales: en, ru
      static let crowdloanAboutCrowdloans = Rswift.StringResource(key: "crowdloan.about.crowdloans", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: About rewards
      ///
      /// Locales: en, ru
      static let stakingAboutRewards = Rswift.StringResource(key: "staking.about.rewards", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: About staking
      ///
      /// Locales: en, ru
      static let stakingNetworkInfoTitle = Rswift.StringResource(key: "staking.network.info.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account
      ///
      /// Locales: en, ru
      static let accountInfoTitle = Rswift.StringResource(key: "account.info.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account
      ///
      /// Locales: en, ru
      static let commonAccount = Rswift.StringResource(key: "common.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account address
      ///
      /// Locales: en, ru
      static let commonAccountAddress = Rswift.StringResource(key: "common.account.address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account address or account name
      ///
      /// Locales: en, ru
      static let walletContactsSearchPlaceholder = Rswift.StringResource(key: "wallet.contacts.search.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account already exists. Please, try another one.
      ///
      /// Locales: en, ru
      static let accountAddAlreadyExistsMessage = Rswift.StringResource(key: "account.add.already.exists.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account is not found
      ///
      /// Locales: en, ru
      static let accountNotFoundCaption = Rswift.StringResource(key: "account.not.found.caption", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Account needed
      ///
      /// Locales: en, ru
      static let accountNeededTitle = Rswift.StringResource(key: "account.needed.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Accounts
      ///
      /// Locales: en, ru
      static let profileAccountsTitle = Rswift.StringResource(key: "profile.accounts.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Accounts with custom secret
      ///
      /// Locales: en, ru
      static let chainAccountsSectionTitleCustomSecret = Rswift.StringResource(key: "chain.accounts.section.title.custom.secret", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Accounts with shared secret
      ///
      /// Locales: en, ru
      static let chainAccountsSectionTitleSharedSecret = Rswift.StringResource(key: "chain.accounts.section.title.shared.secret", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Active
      ///
      /// Locales: en, ru
      static let crowdloanActiveSection = Rswift.StringResource(key: "crowdloan.active.section", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Active
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusActive = Rswift.StringResource(key: "staking.nominator.status.active", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Active crowdloans  will appear here
      ///
      /// Locales: en, ru
      static let crowdloanPlaceholder = Rswift.StringResource(key: "crowdloan.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Active nominators
      ///
      /// Locales: en, ru
      static let stakingMainActiveNominatorsTitle = Rswift.StringResource(key: "staking.main.active.nominators.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Active status
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusAlertActiveTitle = Rswift.StringResource(key: "staking.nominator.status.alert.active.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Active validators without your stake assignment
      ///
      /// Locales: en, ru
      static let stakingYourNotAllocatedDescription_v2_2_0 = Rswift.StringResource(key: "staking.your.not.allocated.description_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Activity
      ///
      /// Locales: en, ru
      static let stakingAnalyticsActivity = Rswift.StringResource(key: "staking.analytics.activity", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Add
      ///
      /// Locales: en, ru
      static let commonAdd = Rswift.StringResource(key: "common.add", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Add account
      ///
      /// Locales: en, ru
      static let accountsAddAccount = Rswift.StringResource(key: "accounts.add.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Add connection
      ///
      /// Locales: en, ru
      static let connectionsAddConnection = Rswift.StringResource(key: "connections.add.connection", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Add controller account %@ to the application to perform this action.
      ///
      /// Locales: en, ru
      static let stakingAddController = Rswift.StringResource(key: "staking.add.controller", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Add to favorites
      ///
      /// Locales: en, ru
      static let dappFavoriteAddTitle = Rswift.StringResource(key: "dapp.favorite.add.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Add wallet
      ///
      /// Locales: en, ru
      static let walletAddButtonTitle = Rswift.StringResource(key: "wallet.add.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Address
      ///
      /// Locales: en, ru
      static let commonAddress = Rswift.StringResource(key: "common.address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Address format is invalid. Make sure that address belongs to the right network
      ///
      /// Locales: en, ru
      static let walletSearchEmptyTitle_v1100 = Rswift.StringResource(key: "wallet.search.empty.title_v1.10.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Address in transaction (%@) doesn't match the address in the wallet (%@)
      ///
      /// Locales: en, ru
      static let dappConfirmationAddressMismatch = Rswift.StringResource(key: "dapp.confirmation.address.mismatch", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Advanced
      ///
      /// Locales: en, ru
      static let commonAdvanced = Rswift.StringResource(key: "common.advanced", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: After unstaking period don't forget to redeem your tokens
      ///
      /// Locales: en, ru
      static let stakingHintRedeem_v2_2_0 = Rswift.StringResource(key: "staking.hint.redeem_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: After unstaking period you will need to redeem your tokens.
      ///
      /// Locales: en, ru
      static let stakingHintRedeem = Rswift.StringResource(key: "staking.hint.redeem", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Agree with Terms and Conditions
      ///
      /// Locales: en, ru
      static let karuraTermsAction = Rswift.StringResource(key: "karura.terms.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Alerts
      ///
      /// Locales: en, ru
      static let stakingAlertsTitle = Rswift.StringResource(key: "staking.alerts.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: All
      ///
      /// Locales: en, ru
      static let commonAll = Rswift.StringResource(key: "common.all", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: All
      ///
      /// Locales: en, ru
      static let stakingAnalyticsPeriodAll = Rswift.StringResource(key: "staking.analytics.period.all", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: All unstaking
      ///
      /// Locales: en, ru
      static let stakingRebondActionAll = Rswift.StringResource(key: "staking.rebond.action.all", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Allocation with current validators
      ///
      /// Locales: en, ru
      static let stakingAnalyticsStakeAllocation = Rswift.StringResource(key: "staking.analytics.stake.allocation", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Allow
      ///
      /// Locales: en, ru
      static let commonAllow = Rswift.StringResource(key: "common.allow", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Allow %@ to access your account addresses?
      ///
      /// Locales: en, ru
      static let dappAuthTitle = Rswift.StringResource(key: "dapp.auth.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Already have a wallet
      ///
      /// Locales: en, ru
      static let onboardingRestoreWallet = Rswift.StringResource(key: "onboarding.restore.wallet", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Already have an account
      ///
      /// Locales: en, ru
      static let onboardingRestoreChainAccount = Rswift.StringResource(key: "onboarding.restore.chain.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Although rewards are usually distributed by validators, Nova Wallet helps by alerting if there are any unpaid rewards that are close to expiring. You will receive alerts about this and other activities on the staking screen.
      ///
      /// Locales: en, ru
      static let stakingStoryRewardPage2 = Rswift.StringResource(key: "staking.story.reward.page.2", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Amount
      ///
      /// Locales: en, ru
      static let walletSendAmountTitle = Rswift.StringResource(key: "wallet.send.amount.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Amount is too low
      ///
      /// Locales: en, ru
      static let amountTooLow = Rswift.StringResource(key: "amount.too.low", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Amount is too low
      ///
      /// Locales: en, ru
      static let walletSendDeadRecipientTitle = Rswift.StringResource(key: "wallet.send.dead.recipient.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Amount you want to return to stake is greater than unstaking balance
      ///
      /// Locales: en, ru
      static let stakingRebondInsufficientBondings = Rswift.StringResource(key: "staking.rebond.insufficient.bondings", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Analytics
      ///
      /// Locales: en, ru
      static let stakingAnalyticsTitle = Rswift.StringResource(key: "staking.analytics.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: App version
      ///
      /// Locales: en, ru
      static let aboutVersion = Rswift.StringResource(key: "about.version", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Applied
      ///
      /// Locales: en, ru
      static let commonApplied = Rswift.StringResource(key: "common.applied", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Apply
      ///
      /// Locales: en, ru
      static let commonApply = Rswift.StringResource(key: "common.apply", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Apply bonus
      ///
      /// Locales: en, ru
      static let crowdloanHavenotAppliedBonusApply = Rswift.StringResource(key: "crowdloan.havenot.applied.bonus.apply", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Approve this request if you trust the application
      ///
      /// Locales: en, ru
      static let dappAuthSubtitle = Rswift.StringResource(key: "dapp.auth.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Approve this request if you trust the application. Check the transaction details.
      ///
      /// Locales: en, ru
      static let dappConfirmSubtitle = Rswift.StringResource(key: "dapp.confirm.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Are you sure you want to cancel this operation?
      ///
      /// Locales: en, ru
      static let commonCancelOperationMessage = Rswift.StringResource(key: "common.cancel.operation.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Are you sure you want to close this screen? Your changes will not be applied.
      ///
      /// Locales: en, ru
      static let dappBrowserCloseConfirmation = Rswift.StringResource(key: "dapp.browser.close.confirmation", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Are you sure?
      ///
      /// Locales: en, ru
      static let commonConfirmationTitle = Rswift.StringResource(key: "common.confirmation.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Asset
      ///
      /// Locales: en, ru
      static let walletSendAssetTitle = Rswift.StringResource(key: "wallet.send.asset.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Assets
      ///
      /// Locales: en, ru
      static let tabbarAssetsTitle = Rswift.StringResource(key: "tabbar.assets.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Assets value
      ///
      /// Locales: en, ru
      static let walletAssetsTotalTitle = Rswift.StringResource(key: "wallet.assets.total.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Astar referral code should be a valid Polkadot address
      ///
      /// Locales: en, ru
      static let crowdloanAstarInvalidReferralMessage = Rswift.StringResource(key: "crowdloan.astar.invalid.referral.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Attention!
      ///
      /// Locales: en, ru
      static let commonNoScreenshotTitle_v2_2_0 = Rswift.StringResource(key: "common.no.screenshot.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Authenticate to access the account
      ///
      /// Locales: en, ru
      static let askBiometryReason = Rswift.StringResource(key: "ask.biometry.reason", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Authorized websites
      ///
      /// Locales: en, ru
      static let dappAuthorizedTitle = Rswift.StringResource(key: "dapp.authorized.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Available balance
      ///
      /// Locales: en, ru
      static let walletSendAvailableBalance = Rswift.StringResource(key: "wallet.send.available.balance", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Available: %@
      ///
      /// Locales: en, ru
      static let commonAvailableFormat = Rswift.StringResource(key: "common.available.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Average APY
      ///
      /// Locales: en, ru
      static let stakingRewardInfoAvg = Rswift.StringResource(key: "staking.reward.info.avg", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Awesome! You have no unpaid rewards
      ///
      /// Locales: en, ru
      static let stakingRewardPayoutsEmptyRewards_2_2_0 = Rswift.StringResource(key: "staking.reward.payouts.empty.rewards_2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Back to operation
      ///
      /// Locales: en, ru
      static let commonKeepEditingAction = Rswift.StringResource(key: "common.keep.editing.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Backup mnemonic
      ///
      /// Locales: en, ru
      static let accountCreateTitle = Rswift.StringResource(key: "account.create.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Balance
      ///
      /// Locales: en, ru
      static let commonBalance = Rswift.StringResource(key: "common.balance", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Balance
      ///
      /// Locales: en, ru
      static let stakingBalanceTitle_v2_2_0 = Rswift.StringResource(key: "staking.balance.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Balance details
      ///
      /// Locales: en, ru
      static let walletSendBalanceDetails = Rswift.StringResource(key: "wallet.send.balance.details", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Be careful
      ///
      /// Locales: en, ru
      static let accountExportWarningTitle = Rswift.StringResource(key: "account.export.warning.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Bonded: %@
      ///
      /// Locales: en, ru
      static let stakingBondedFormat = Rswift.StringResource(key: "staking.bonded.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Bonus
      ///
      /// Locales: en, ru
      static let commonBonus = Rswift.StringResource(key: "common.bonus", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Bonus signature verification failed. Please, try again later.
      ///
      /// Locales: en, ru
      static let crowdloanBonusVerificationError = Rswift.StringResource(key: "crowdloan.bonus.verification.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Browse the web using  your accounts from Nova Wallet
      ///
      /// Locales: en, ru
      static let dappsDecorationSubtitle_2_4_3 = Rswift.StringResource(key: "dapps.decoration.subtitle_2_4_3", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Browser
      ///
      /// Locales: en, ru
      static let tabbarDappsTitle_2_4_3 = Rswift.StringResource(key: "tabbar.dapps.title_2_4_3", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Buy
      ///
      /// Locales: en, ru
      static let walletAssetBuy = Rswift.StringResource(key: "wallet.asset.buy", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Buy with
      ///
      /// Locales: en, ru
      static let walletAssetBuyWith = Rswift.StringResource(key: "wallet.asset.buy.with", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: By continuing, you agree to our  Terms and Conditions and Privacy Policy
      ///
      /// Locales: en, ru
      static let onboardingTermsAndConditions1_v2_2_0 = Rswift.StringResource(key: "onboarding.terms.and.conditions.1_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Call
      ///
      /// Locales: en, ru
      static let commonCall = Rswift.StringResource(key: "common.call", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Camera Access
      ///
      /// Locales: en, ru
      static let qrScanErrorCameraTitle = Rswift.StringResource(key: "qr.scan.error.camera.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Camera is used to capture QR code
      ///
      /// Locales: en, ru
      static let nsCameraUsageDescription = Rswift.StringResource(key: "NSCameraUsageDescription", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Can't establish connection with node. Please, try another one.
      ///
      /// Locales: en, ru
      static let connectionAddInvalidError = Rswift.StringResource(key: "connection.add.invalid.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Can't extract recipient address
      ///
      /// Locales: en, ru
      static let recepientScanError = Rswift.StringResource(key: "recepient.scan.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Can't process selected image
      ///
      /// Locales: en, ru
      static let qrScanErrorInvalidImage = Rswift.StringResource(key: "qr.scan.error.invalid.image", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Can't stake less than minimal value (%@)
      ///
      /// Locales: en, ru
      static let stakingSetupAmountTooLow = Rswift.StringResource(key: "staking.setup.amount.too.low", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cancel
      ///
      /// Locales: en, ru
      static let commonCancel = Rswift.StringResource(key: "common.cancel", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cancel operation
      ///
      /// Locales: en, ru
      static let commonCancelOperationAction = Rswift.StringResource(key: "common.cancel.operation.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cannot contribute chosen amount since resulting raised amount will exceed crowdloan cap. Maximum allowed contribution is %@.
      ///
      /// Locales: en, ru
      static let crowdloanCapReachedAmountMessage = Rswift.StringResource(key: "crowdloan.cap.reached.amount.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cannot contribute to selected crowdloan  since its cap is already reached.
      ///
      /// Locales: en, ru
      static let crowdloanCapReachedRaisedMessage = Rswift.StringResource(key: "crowdloan.cap.reached.raised.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cannot contribute to selected crowdloan since it is already ended.
      ///
      /// Locales: en, ru
      static let crowdloanEndedMessage = Rswift.StringResource(key: "crowdloan.ended.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cannot import account with Ethereum secret into the network with Substrate encryption
      ///
      /// Locales: en, ru
      static let importJsonUnsupportedSubstrateCryptoMessage = Rswift.StringResource(key: "import.json.unsupported.substrate.crypto.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cannot import account with Substrate secret into the network with Ethereum encryption
      ///
      /// Locales: en, ru
      static let importJsonUnsupportedEthereumCryptoMessage = Rswift.StringResource(key: "import.json.unsupported.ethereum.crypto.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Cannot start staking
      ///
      /// Locales: en, ru
      static let stakingMaxNominatorsReachedTitle = Rswift.StringResource(key: "staking.max.nominators.reached.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change
      ///
      /// Locales: en, ru
      static let commonChange = Rswift.StringResource(key: "common.change", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change %@ account
      ///
      /// Locales: en, ru
      static let accountActionsChangeSheetTitle = Rswift.StringResource(key: "account.actions.change.sheet.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change PIN code
      ///
      /// Locales: en, ru
      static let profilePincodeChangeTitle = Rswift.StringResource(key: "profile.pincode.change.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change account
      ///
      /// Locales: en, ru
      static let accountActionsChangeTitle = Rswift.StringResource(key: "account.actions.change.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change controller
      ///
      /// Locales: en, ru
      static let stakingControllerConfirmTitle = Rswift.StringResource(key: "staking.controller.confirm.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change password
      ///
      /// Locales: en, ru
      static let commonChangePassword = Rswift.StringResource(key: "common.change.password", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change validators
      ///
      /// Locales: en, ru
      static let stakingChangeValidators = Rswift.StringResource(key: "staking.change.validators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Change your validators.
      ///
      /// Locales: en, ru
      static let stakingChangeYourValidators = Rswift.StringResource(key: "staking.change.your.validators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Changed
      ///
      /// Locales: en, ru
      static let commonChanged = Rswift.StringResource(key: "common.changed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Choose action
      ///
      /// Locales: en, ru
      static let commonChooseAction = Rswift.StringResource(key: "common.choose.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Choose custom validators 
      ///
      /// Locales: en, ru
      static let stakingRecommendedCustomTitle = Rswift.StringResource(key: "staking.recommended.custom.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Choose network
      ///
      /// Locales: en, ru
      static let commonChooseNetwork = Rswift.StringResource(key: "common.choose.network", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Choose parachains to contribute your %@. You'll get back your contributed tokens, and if parachain wins a slot, you'll receive rewards after the end of the auction
      ///
      /// Locales: en, ru
      static let crowdloanListSectionFormat_v2_2_0 = Rswift.StringResource(key: "crowdloan.list.section.format_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Choose words in the right order
      ///
      /// Locales: en, ru
      static let accountConfirmationDetails = Rswift.StringResource(key: "account.confirmation.details", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Choose your validators carefully, as they should act proficiently and honest. Basing your decision purely on the profitability could lead to reduced rewards or even loss of stake
      ///
      /// Locales: en, ru
      static let stakingSelectValidatorsCustomDesc_2_2_0 = Rswift.StringResource(key: "staking.select.validators.custom.desc_2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Clear filters
      ///
      /// Locales: en, ru
      static let stakingCustomClearButtonTitle = Rswift.StringResource(key: "staking.custom.clear.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Close
      ///
      /// Locales: en, ru
      static let commonClose = Rswift.StringResource(key: "common.close", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Collection
      ///
      /// Locales: en, ru
      static let nftCollectionTitle = Rswift.StringResource(key: "nft.collection.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Community
      ///
      /// Locales: en, ru
      static let settingsCommunity = Rswift.StringResource(key: "settings.community", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Completed
      ///
      /// Locales: en, ru
      static let crowdloanCompletedSection = Rswift.StringResource(key: "crowdloan.completed.section", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Completed
      ///
      /// Locales: en, ru
      static let transactionStatusCompleted = Rswift.StringResource(key: "transaction.status.completed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm
      ///
      /// Locales: en, ru
      static let commonConfirm = Rswift.StringResource(key: "common.confirm", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm %@ deletion.
      ///
      /// Locales: en, ru
      static let connectionDeleteDescription = Rswift.StringResource(key: "connection.delete.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm mnemonic
      ///
      /// Locales: en, ru
      static let accountConfirmationTitle = Rswift.StringResource(key: "account.confirmation.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm password
      ///
      /// Locales: en, ru
      static let commonConfirmPassword = Rswift.StringResource(key: "common.confirm.password", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm password...
      ///
      /// Locales: en, ru
      static let exportPasswordProceedConfirmTitle = Rswift.StringResource(key: "export.password.proceed.confirm.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm transfer
      ///
      /// Locales: en, ru
      static let walletSendConfirmTitle = Rswift.StringResource(key: "wallet.send.confirm.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirm your pin code
      ///
      /// Locales: en, ru
      static let pincodeConfirmYourPinCode = Rswift.StringResource(key: "pincode.confirm.your.pin.code", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirmation
      ///
      /// Locales: en, ru
      static let commonConfirmTitle = Rswift.StringResource(key: "common.confirm.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Confirmed
      ///
      /// Locales: en, ru
      static let commonConfirmed = Rswift.StringResource(key: "common.confirmed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Connect to the Polkadot & Kusama ecosystem web applications using accounts in Nova Wallet
      ///
      /// Locales: en, ru
      static let dappsDecorationSubtitle = Rswift.StringResource(key: "dapps.decoration.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Connected
      ///
      /// Locales: en, ru
      static let networkStatusConnected = Rswift.StringResource(key: "network.status.connected", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Connecting
      ///
      /// Locales: en, ru
      static let networkStatusConnecting = Rswift.StringResource(key: "network.status.connecting", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Connection Failed
      ///
      /// Locales: en, ru
      static let connectionErrorTitle = Rswift.StringResource(key: "connection.error.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Contact Us
      ///
      /// Locales: en, ru
      static let aboutContactUs = Rswift.StringResource(key: "about.contact.us", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Contacts
      ///
      /// Locales: en, ru
      static let walletSearchContacts = Rswift.StringResource(key: "wallet.search.contacts", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Continue
      ///
      /// Locales: en, ru
      static let commonContinue = Rswift.StringResource(key: "common.continue", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Contribute to crowdloan
      ///
      /// Locales: en, ru
      static let crowdloanContributeTitle = Rswift.StringResource(key: "crowdloan.contribute.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Contribution amount is too small
      ///
      /// Locales: en, ru
      static let crowdloanTooSmallContributionTitle = Rswift.StringResource(key: "crowdloan.too.small.contribution.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Controller
      ///
      /// Locales: en, ru
      static let stakingController = Rswift.StringResource(key: "staking.controller", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Controller account
      ///
      /// Locales: en, ru
      static let stakingControllerAccountTitle = Rswift.StringResource(key: "staking.controller.account.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Controller can unstake, redeem, return to stake, change rewards destination and validators.
      ///
      /// Locales: en, ru
      static let stakingControllerCanHint = Rswift.StringResource(key: "staking.controller.can.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Controller is used to: unstake, redeem, return to stake, change validators and set rewards destination
      ///
      /// Locales: en, ru
      static let stakingControllerCanHint_v2_2_0 = Rswift.StringResource(key: "staking.controller.can.hint_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Copied to clipboard
      ///
      /// Locales: en, ru
      static let commonCopied = Rswift.StringResource(key: "common.copied", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Copy address
      ///
      /// Locales: en, ru
      static let commonCopyAddress = Rswift.StringResource(key: "common.copy.address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Copy hash
      ///
      /// Locales: en, ru
      static let transactionDetailsCopyHash = Rswift.StringResource(key: "transaction.details.copy.hash", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Copy id
      ///
      /// Locales: en, ru
      static let commonCopyId = Rswift.StringResource(key: "common.copy.id", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Couldn't extract data from the database. Please, try again later.
      ///
      /// Locales: en, ru
      static let commonDbSubscriptionError = Rswift.StringResource(key: "common.db.subscription.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create a new account
      ///
      /// Locales: en, ru
      static let accountUsernameSetupTitle = Rswift.StringResource(key: "account.username.setup.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create a new account
      ///
      /// Locales: en, ru
      static let onboardingCreateChainAccount = Rswift.StringResource(key: "onboarding.create.chain.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create a new wallet
      ///
      /// Locales: en, ru
      static let onboardingCreateWallet = Rswift.StringResource(key: "onboarding.create.wallet", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create a new wallet
      ///
      /// Locales: en, ru
      static let walletUsernameSetupTitle = Rswift.StringResource(key: "wallet.username.setup.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create account
      ///
      /// Locales: en, ru
      static let accountCreateOptionTitle = Rswift.StringResource(key: "account.create.option.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create account
      ///
      /// Locales: en, ru
      static let onboardingCreateAccount = Rswift.StringResource(key: "onboarding.create.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create pin code
      ///
      /// Locales: en, ru
      static let pincodeCreateTopTitle = Rswift.StringResource(key: "pincode.create.top.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create wallet name
      ///
      /// Locales: en, ru
      static let walletNicknameCreateTitle_v2_2_0 = Rswift.StringResource(key: "wallet.nickname.create.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Create wallet nickname
      ///
      /// Locales: en, ru
      static let walletNicknameCreateTitle = Rswift.StringResource(key: "wallet.nickname.create.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Created by
      ///
      /// Locales: en, ru
      static let nftIssuerTitle = Rswift.StringResource(key: "nft.issuer.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Crowdloan cap exceeded
      ///
      /// Locales: en, ru
      static let crowdloanCapReachedTitle = Rswift.StringResource(key: "crowdloan.cap.reached.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Crowdloan info
      ///
      /// Locales: en, ru
      static let crowdloanInfo = Rswift.StringResource(key: "crowdloan.info", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Crowdloan is ended
      ///
      /// Locales: en, ru
      static let crowdloanEndedTitle = Rswift.StringResource(key: "crowdloan.ended.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Crowdloans
      ///
      /// Locales: en, ru
      static let tabbarCrowdloanTitle = Rswift.StringResource(key: "tabbar.crowdloan.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Crowdloans
      ///
      /// Locales: en, ru
      static let tabbarCrowdloanTitle_v190 = Rswift.StringResource(key: "tabbar.crowdloan.title_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Crowdloans will be displayed here
      ///
      /// Locales: en, ru
      static let crowdloanEmptyMessage_v2_2_0 = Rswift.StringResource(key: "crowdloan.empty.message_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Custom
      ///
      /// Locales: en, ru
      static let connectionManagementCustomTitle = Rswift.StringResource(key: "connection.management.custom.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Custom amount
      ///
      /// Locales: en, ru
      static let stakingRebondActionCustom = Rswift.StringResource(key: "staking.rebond.action.custom", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: DApp
      ///
      /// Locales: en, ru
      static let commonDapp = Rswift.StringResource(key: "common.dapp", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: DApp communication failed with reason: %@
      ///
      /// Locales: en, ru
      static let dappUnexpectedErrorFormat = Rswift.StringResource(key: "dapp.unexpected.error.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: DApps
      ///
      /// Locales: en, ru
      static let dappSearchAppSection = Rswift.StringResource(key: "dapp.search.app.section", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: DApps
      ///
      /// Locales: en, ru
      static let tabbarDappsTitle = Rswift.StringResource(key: "tabbar.dapps.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Date
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsDate = Rswift.StringResource(key: "staking.reward.details.date", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Date
      ///
      /// Locales: en, ru
      static let transactionDetailDate = Rswift.StringResource(key: "transaction.detail.date", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Default
      ///
      /// Locales: en, ru
      static let connectionManagementDefaultTitle = Rswift.StringResource(key: "connection.management.default.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Delete
      ///
      /// Locales: en, ru
      static let connectionDeleteConfirm = Rswift.StringResource(key: "connection.delete.confirm", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Delete network?
      ///
      /// Locales: en, ru
      static let connectionDeleteTitle = Rswift.StringResource(key: "connection.delete.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Democracy
      ///
      /// Locales: en, ru
      static let walletAccountLocksDemocracy = Rswift.StringResource(key: "wallet.account.locks.democracy", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Deselect all
      ///
      /// Locales: en, ru
      static let stakingCustomDeselectButtonTitle = Rswift.StringResource(key: "staking.custom.deselect.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Details
      ///
      /// Locales: en, ru
      static let commonDetails = Rswift.StringResource(key: "common.details", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Direct
      ///
      /// Locales: en, ru
      static let crowdloanAcalaDirect = Rswift.StringResource(key: "crowdloan.acala.direct", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Do not take screenshots
      ///
      /// Locales: en, ru
      static let commonNoScreenshotTitle = Rswift.StringResource(key: "common.no.screenshot.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Do not take screenshots, which may be collected by third-party malware
      ///
      /// Locales: en, ru
      static let commonNoScreenshotMessage = Rswift.StringResource(key: "common.no.screenshot.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Do not use clipboard or screenshots on your mobile device, try to find secure methods for backup (e.g. paper)
      ///
      /// Locales: en, ru
      static let accountCreateDetails_v2_2_0 = Rswift.StringResource(key: "account.create.details_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Done
      ///
      /// Locales: en, ru
      static let commonDone = Rswift.StringResource(key: "common.done", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: During unstaking period tokens produce no rewards
      ///
      /// Locales: en, ru
      static let stakingHintNoRewards_V2_2_0 = Rswift.StringResource(key: "staking.hint.no.rewards_ v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: ECDSA
      ///
      /// Locales: en, ru
      static let ecdsaSelectionTitle = Rswift.StringResource(key: "ecdsa.selection.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Earnings with restake
      ///
      /// Locales: en, ru
      static let stakingRewardInfoTitle = Rswift.StringResource(key: "staking.reward.info.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Edit
      ///
      /// Locales: en, ru
      static let commonEdit = Rswift.StringResource(key: "common.edit", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Edwards
      ///
      /// Locales: en, ru
      static let ed25519SelectionTitle = Rswift.StringResource(key: "ed25519.selection.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Elected
      ///
      /// Locales: en, ru
      static let stakingValidatorStatusElected = Rswift.StringResource(key: "staking.validator.status.elected", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Elected (%@)
      ///
      /// Locales: en, ru
      static let stakingYourElectedFormat = Rswift.StringResource(key: "staking.your.elected.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Elections
      ///
      /// Locales: en, ru
      static let walletAccountLocksElections = Rswift.StringResource(key: "wallet.account.locks.elections", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Element name
      ///
      /// Locales: en, ru
      static let identityRiotNameTitle = Rswift.StringResource(key: "identity.riot.name.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Email
      ///
      /// Locales: en, ru
      static let identityEmailTitle = Rswift.StringResource(key: "identity.email.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Email
      ///
      /// Locales: en, ru
      static let settingsEmail = Rswift.StringResource(key: "settings.email", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter PIN code
      ///
      /// Locales: en, ru
      static let pincodeEnterPinCode = Rswift.StringResource(key: "pincode.enter.pin.code", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter a wallet name...
      ///
      /// Locales: en, ru
      static let walletCreateButtonTitleDisabled_v2_2_0 = Rswift.StringResource(key: "wallet.create.button.title.disabled_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter password...
      ///
      /// Locales: en, ru
      static let walletImportNoPassword = Rswift.StringResource(key: "wallet.import.no.password", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter the address...
      ///
      /// Locales: en, ru
      static let transferSetupEnterAddress = Rswift.StringResource(key: "transfer.setup.enter.address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter the amount...
      ///
      /// Locales: en, ru
      static let transferSetupEnterAmount = Rswift.StringResource(key: "transfer.setup.enter.amount", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter the raw seed...
      ///
      /// Locales: en, ru
      static let walletImportNoSeedTitle = Rswift.StringResource(key: "wallet.import.no.seed.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter the words in the right order
      ///
      /// Locales: en, ru
      static let walletImportMnemonicTitle = Rswift.StringResource(key: "wallet.import.mnemonic.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter the words...
      ///
      /// Locales: en, ru
      static let walletImportNoMnemonicTitle = Rswift.StringResource(key: "wallet.import.no.mnemonic.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter wallet name...
      ///
      /// Locales: en, ru
      static let walletImportNoNameTitle = Rswift.StringResource(key: "wallet.import.no.name.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter your raw seed
      ///
      /// Locales: en, ru
      static let walletImportSeedTitle = Rswift.StringResource(key: "wallet.import.seed.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Enter your referral code
      ///
      /// Locales: en, ru
      static let karuraReferralCodeAction = Rswift.StringResource(key: "karura.referral.code.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Era
      ///
      /// Locales: en, ru
      static let stakingCommonEra = Rswift.StringResource(key: "staking.common.era", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Era
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsEra = Rswift.StringResource(key: "staking.reward.details.era", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Error
      ///
      /// Locales: en, ru
      static let commonErrorGeneralTitle = Rswift.StringResource(key: "common.error.general.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Estimated %@ earnings
      ///
      /// Locales: en, ru
      static let stakingEstimateEarningTitle_v190 = Rswift.StringResource(key: "staking.estimate.earning.title_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Estimated reward
      ///
      /// Locales: en, ru
      static let crowdloanReward = Rswift.StringResource(key: "crowdloan.reward", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Estimated reward
      ///
      /// Locales: en, ru
      static let stakingValidatorEstimatedReward = Rswift.StringResource(key: "staking.validator.estimated.reward", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Estimated reward (% APY)
      ///
      /// Locales: en, ru
      static let stakingValidatorApyPercent = Rswift.StringResource(key: "staking.validator.apy.percent", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Ethereum keypair crypto type
      ///
      /// Locales: en, ru
      static let commonCryptoTypeEthereum = Rswift.StringResource(key: "common.crypto.type.ethereum", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Ethereum secret derivation path
      ///
      /// Locales: en, ru
      static let commonSecretDerivationPathEthereum = Rswift.StringResource(key: "common.secret.derivation.path.ethereum", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Event
      ///
      /// Locales: en, ru
      static let stakingCommonEventId = Rswift.StringResource(key: "staking.common.event.id", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Everyone can be a validator and run a blockchain node, but that requires a certain level of technical skills and responsibility. Polkadot and Kusama networks have a program, named Thousand Validators Programme, to provide support for beginners. Moreover, the network itself will always reward more validators, who have less stake (but enough to be elected) to improve decentralization.
      ///
      /// Locales: en, ru
      static let stakingStoryValidatorPage2 = Rswift.StringResource(key: "staking.story.validator.page.2", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Example: Savings, Investments, Crowdloans, Staking.
      ///
      /// Locales: en, ru
      static let walletUsernameSetupHint = Rswift.StringResource(key: "wallet.username.setup.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Examples: Savings, Investments, Crowdloans, Staking.
      ///
      /// Locales: en, ru
      static let walletNicknameCreateCaption = Rswift.StringResource(key: "wallet.nickname.create.caption", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Explore
      ///
      /// Locales: en, ru
      static let dappsListHeaderTitle = Rswift.StringResource(key: "dapps.list.header.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Export
      ///
      /// Locales: en, ru
      static let accountExportAction = Rswift.StringResource(key: "account.export.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Export account
      ///
      /// Locales: en, ru
      static let commonExport = Rswift.StringResource(key: "common.export", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Extrinsic Hash
      ///
      /// Locales: en, ru
      static let transactionDetailsHashTitle = Rswift.StringResource(key: "transaction.details.hash.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Extrinsic details
      ///
      /// Locales: en, ru
      static let walletExtrinsicDetailsTitle = Rswift.StringResource(key: "wallet.extrinsic.details.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Extrinsic extensions doesn't much local ones
      ///
      /// Locales: en, ru
      static let dappConfirmationExtensionsMismatch = Rswift.StringResource(key: "dapp.confirmation.extensions.mismatch", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Face ID
      ///
      /// Locales: en, ru
      static let askFaceidTitle = Rswift.StringResource(key: "ask.faceid.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Face ID is used to authorize in application
      ///
      /// Locales: en, ru
      static let nsFaceIDUsageDescription = Rswift.StringResource(key: "NSFaceIDUsageDescription", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Failed
      ///
      /// Locales: en, ru
      static let transactionStatusFailed = Rswift.StringResource(key: "transaction.status.failed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Failed to sign requested operation
      ///
      /// Locales: en, ru
      static let dappSignExtrinsicFailed = Rswift.StringResource(key: "dapp.sign.extrinsic.failed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Favorites
      ///
      /// Locales: en, ru
      static let commonFavorites = Rswift.StringResource(key: "common.favorites", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Featured websites
      ///
      /// Locales: en, ru
      static let dappListFeaturedWebsites = Rswift.StringResource(key: "dapp.list.featured.websites", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Fee
      ///
      /// Locales: en, ru
      static let transactionDetailsExtrinsicFee = Rswift.StringResource(key: "transaction.details.extrinsic.fee", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Fee calculation is in progress
      ///
      /// Locales: en, ru
      static let feeNotYetLoadedTitle = Rswift.StringResource(key: "fee.not.yet.loaded.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Fee loading failed. Would you like to retry?
      ///
      /// Locales: en, ru
      static let commonFeeRetryFailed = Rswift.StringResource(key: "common.fee.retry.failed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Fill rest with recommended
      ///
      /// Locales: en, ru
      static let stakingCustomFillButtonTitle = Rswift.StringResource(key: "staking.custom.fill.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Filters
      ///
      /// Locales: en, ru
      static let assetsManageTitle = Rswift.StringResource(key: "assets.manage.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Filters
      ///
      /// Locales: en, ru
      static let walletFiltersTitle = Rswift.StringResource(key: "wallet.filters.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Find out more
      ///
      /// Locales: en, ru
      static let commonFindMore = Rswift.StringResource(key: "common.find.more", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Find out more about
      ///
      /// Locales: en, ru
      static let commonLearnMore_v2_2_0 = Rswift.StringResource(key: "common.learn.more_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Following address: %@ is known to be used in phishing activities, thus we are not recommending sending tokens to that address. Would you like to proceed anyway?
      ///
      /// Locales: en, ru
      static let walletSendPhishingWarningText = Rswift.StringResource(key: "wallet.send.phishing.warning.text", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Forget
      ///
      /// Locales: en, ru
      static let accountDeleteConfirm = Rswift.StringResource(key: "account.delete.confirm", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Forget account?
      ///
      /// Locales: en, ru
      static let accountDeleteConfirmationTitle = Rswift.StringResource(key: "account.delete.confirmation.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Forget wallet?
      ///
      /// Locales: en, ru
      static let walletDeleteConfirmationTitle = Rswift.StringResource(key: "wallet.delete.confirmation.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: From
      ///
      /// Locales: en, ru
      static let transactionDetailsFrom = Rswift.StringResource(key: "transaction.details.from", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Frozen
      ///
      /// Locales: en, ru
      static let walletBalanceFrozen = Rswift.StringResource(key: "wallet.balance.frozen", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: General
      ///
      /// Locales: en, ru
      static let settingsGeneral = Rswift.StringResource(key: "settings.general", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Generated signature is invalid
      ///
      /// Locales: en, ru
      static let dappConfirmationInvalidSignature = Rswift.StringResource(key: "dapp.confirmation.invalid.signature", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Get a special bonus
      ///
      /// Locales: en, ru
      static let crowdloanEmptyBonusTitle = Rswift.StringResource(key: "crowdloan.empty.bonus.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Github
      ///
      /// Locales: en, ru
      static let aboutGithub = Rswift.StringResource(key: "about.github", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Having onchain identity
      ///
      /// Locales: en, ru
      static let stakingRecommendedHint3 = Rswift.StringResource(key: "staking.recommended.hint3", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Hexadecimal string
      ///
      /// Locales: en, ru
      static let secretTypeSeedSubtitle = Rswift.StringResource(key: "secret.type.seed.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Hide assets with zero balances
      ///
      /// Locales: en, ru
      static let assetsManageHideZeroBalances = Rswift.StringResource(key: "assets.manage.hide.zero.balances", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: History
      ///
      /// Locales: en, ru
      static let walletHistoryTitle_v190 = Rswift.StringResource(key: "wallet.history.title_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: How it works
      ///
      /// Locales: en, ru
      static let commonHowItWorks = Rswift.StringResource(key: "common.how.it.works", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: How to use your rewards?
      ///
      /// Locales: en, ru
      static let stakingSetupRewardDestinationSectionTitle = Rswift.StringResource(key: "staking.setup.reward.destination.section.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: I have read and agree to %@
      ///
      /// Locales: en, ru
      static let crowdloanTermsFormat = Rswift.StringResource(key: "crowdloan.terms.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: I have read and agreed to Terms and Conditions and Privacy Policy
      ///
      /// Locales: en, ru
      static let onboardingTermsAndConditions1 = Rswift.StringResource(key: "onboarding.terms.and.conditions.1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: I understand
      ///
      /// Locales: en, ru
      static let commonUnderstand = Rswift.StringResource(key: "common.understand", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Identity
      ///
      /// Locales: en, ru
      static let identityTitle = Rswift.StringResource(key: "identity.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: If you don't have referral code, you can apply Nova referral code to receive bonus for your contribution
      ///
      /// Locales: en, ru
      static let crowdloanHavenotAppliedBonusMessage = Rswift.StringResource(key: "crowdloan.havenot.applied.bonus.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: If you want to unstake tokens, you will have to wait for the unstaking period (%@).
      ///
      /// Locales: en, ru
      static let stakingHintUnstakeFormat = Rswift.StringResource(key: "staking.hint.unstake.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Import account
      ///
      /// Locales: en, ru
      static let accountImportOptionTitle = Rswift.StringResource(key: "account.import.option.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Import account
      ///
      /// Locales: en, ru
      static let importChainAccountTitle = Rswift.StringResource(key: "import.chain.account.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Import wallet
      ///
      /// Locales: en, ru
      static let importWalletTitle = Rswift.StringResource(key: "import.wallet.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Improve staking security
      ///
      /// Locales: en, ru
      static let stakingControllerBannerTitle = Rswift.StringResource(key: "staking.controller.banner.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: In future updates, we will add staking features for the validators.
      ///
      /// Locales: en, ru
      static let stakingValidatorSummaryDescription = Rswift.StringResource(key: "staking.validator.summary.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Inactive
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusInactive = Rswift.StringResource(key: "staking.nominator.status.inactive", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Inactive status
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusAlertInactiveTitle = Rswift.StringResource(key: "staking.nominator.status.alert.inactive.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Incoming and outgoing operations will appear here
      ///
      /// Locales: en, ru
      static let walletEmptyDescription = Rswift.StringResource(key: "wallet.empty.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Info
      ///
      /// Locales: en, ru
      static let commonInfo = Rswift.StringResource(key: "common.info", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Information about crowdloans  will appear here
      ///
      /// Locales: en, ru
      static let crowdloanEmptyMessage = Rswift.StringResource(key: "crowdloan.empty.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Input the amount...
      ///
      /// Locales: en, ru
      static let commonInputAmountHint = Rswift.StringResource(key: "common.input.amount.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Insufficient balance
      ///
      /// Locales: en, ru
      static let stakingErrorInsufficientBalanceTitle = Rswift.StringResource(key: "staking.error.insufficient.balance.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid derivation path
      ///
      /// Locales: en, ru
      static let commonInvalidPathTitle_v2_2_0 = Rswift.StringResource(key: "common.invalid.path.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid field in transaction: %@
      ///
      /// Locales: en, ru
      static let dappConfirmationBadField = Rswift.StringResource(key: "dapp.confirmation.bad.field", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid format
      ///
      /// Locales: en, ru
      static let commonInvalidPathTitle = Rswift.StringResource(key: "common.invalid.path.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid mnemonic
      ///
      /// Locales: en, ru
      static let confirmMnemonicMismatchErrorTitle = Rswift.StringResource(key: "confirm.mnemonic.mismatch.error.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid mnemonic passphrase, please check one more time the words order
      ///
      /// Locales: en, ru
      static let accessRestorePhraseErrorMessage_v2_2_0 = Rswift.StringResource(key: "access.restore.phrase.error.message_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid recipient
      ///
      /// Locales: en, ru
      static let commonValidationInvalidAddressTitle = Rswift.StringResource(key: "common.validation.invalid.address.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Invalid restore json. Please, make sure that input contains valid json.
      ///
      /// Locales: en, ru
      static let accountImportInvalidKeystore = Rswift.StringResource(key: "account.import.invalid.keystore", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: JSON contains no network information. Please specify it below.
      ///
      /// Locales: en, ru
      static let accountImportJsonNoNetwork = Rswift.StringResource(key: "account.import.json.no.network", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: JSON file
      ///
      /// Locales: en, ru
      static let secretTypeKeystoreSubtitle = Rswift.StringResource(key: "secret.type.keystore.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Keypair crypto type
      ///
      /// Locales: en, ru
      static let commonCryptoType = Rswift.StringResource(key: "common.crypto.type", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Keystore decryption failed
      ///
      /// Locales: en, ru
      static let accountImportKeystoreDecryptionErrorTitle = Rswift.StringResource(key: "account.import.keystore.decryption.error.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Language
      ///
      /// Locales: en, ru
      static let languageTitle = Rswift.StringResource(key: "language.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Language
      ///
      /// Locales: en, ru
      static let profileLanguageTitle = Rswift.StringResource(key: "profile.language.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Latest unstaked
      ///
      /// Locales: en, ru
      static let stakingRebondActionLast = Rswift.StringResource(key: "staking.rebond.action.last", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Learn %@'s crowdloan
      ///
      /// Locales: en, ru
      static let crowdloanLearn = Rswift.StringResource(key: "crowdloan.learn", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Learn more
      ///
      /// Locales: en, ru
      static let commonLearnMore = Rswift.StringResource(key: "common.learn.more", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Learn more about different contributions to Acala
      ///
      /// Locales: en, ru
      static let crowdloanAcalaLearnMore = Rswift.StringResource(key: "crowdloan.acala.learn.more", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Learn more about rewards
      ///
      /// Locales: en, ru
      static let stakingRewardsLearnMore = Rswift.StringResource(key: "staking.rewards.learn.more", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Leasing period
      ///
      /// Locales: en, ru
      static let crowdloanLeasingPeriod = Rswift.StringResource(key: "crowdloan.leasing.period", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Legal name
      ///
      /// Locales: en, ru
      static let identityLegalNameTitle = Rswift.StringResource(key: "identity.legal.name.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Let sender scan this QR code
      ///
      /// Locales: en, ru
      static let walletReceiveDescription_v2_2_0 = Rswift.StringResource(key: "wallet.receive.description_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Lets double check it
      ///
      /// Locales: en, ru
      static let confirmMnemonicTitle = Rswift.StringResource(key: "confirm.mnemonic.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Limit of 2 validators per identity
      ///
      /// Locales: en, ru
      static let stakingRecommendedHint5 = Rswift.StringResource(key: "staking.recommended.hint5", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Liquid
      ///
      /// Locales: en, ru
      static let crowdloanAcalaLiquid = Rswift.StringResource(key: "crowdloan.acala.liquid", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: List of websites will appear here
      ///
      /// Locales: en, ru
      static let dappAuthorizedEmpty = Rswift.StringResource(key: "dapp.authorized.empty", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Load photos from library
      ///
      /// Locales: en, ru
      static let nsPhotoLibraryUsageDescription = Rswift.StringResource(key: "NSPhotoLibraryUsageDescription", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Loading validators...
      ///
      /// Locales: en, ru
      static let stakingLoadingValidators = Rswift.StringResource(key: "staking.loading.validators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Locked
      ///
      /// Locales: en, ru
      static let walletBalanceLocked = Rswift.StringResource(key: "wallet.balance.locked", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Make sure that the address is  from the right network
      ///
      /// Locales: en, ru
      static let walletSearchEmptyTitle = Rswift.StringResource(key: "wallet.search.empty.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Make sure you have exported your account before proceeding.
      ///
      /// Locales: en, ru
      static let accountDeleteConfirmationDescription = Rswift.StringResource(key: "account.delete.confirmation.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Make sure you have exported your wallet before proceeding.
      ///
      /// Locales: en, ru
      static let walletDeleteConfirmationDescription = Rswift.StringResource(key: "wallet.delete.confirmation.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Manage
      ///
      /// Locales: en, ru
      static let stakingManageTitle = Rswift.StringResource(key: "staking.manage.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Manage assets
      ///
      /// Locales: en, ru
      static let walletManageAssetsTitle = Rswift.StringResource(key: "wallet.manage.assets.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Maximum APY
      ///
      /// Locales: en, ru
      static let stakingRewardInfoMax = Rswift.StringResource(key: "staking.reward.info.max", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Maximum number of nominators has been reached
      ///
      /// Locales: en, ru
      static let stakingMaxNominatorsReachedMessage = Rswift.StringResource(key: "staking.max.nominators.reached.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Minimal balance
      ///
      /// Locales: en, ru
      static let walletSendBalanceMinimal = Rswift.StringResource(key: "wallet.send.balance.minimal", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Minimum stake
      ///
      /// Locales: en, ru
      static let stakingMainMinimumStakeTitle = Rswift.StringResource(key: "staking.main.minimum.stake.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Mnemonic Passphrase
      ///
      /// Locales: en, ru
      static let accountBackupMnemonicFieldTitle = Rswift.StringResource(key: "account.backup.mnemonic.field.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Mnemonic is used to recover access to account. Write it down, we will not be able to recover your account without it!
      ///
      /// Locales: en, ru
      static let accountCreationInfo = Rswift.StringResource(key: "account.creation.info", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Mnemonic must contain 24 words at max
      ///
      /// Locales: en, ru
      static let accessRestoreWordsErrorMessage = Rswift.StringResource(key: "access.restore.words.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Mnemonic passphrase
      ///
      /// Locales: en, ru
      static let importMnemonic = Rswift.StringResource(key: "import.mnemonic", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Mnemonic phrase
      ///
      /// Locales: en, ru
      static let secretTypeMnemonicTitle = Rswift.StringResource(key: "secret.type.mnemonic.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Module
      ///
      /// Locales: en, ru
      static let commonModule = Rswift.StringResource(key: "common.module", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Monthly
      ///
      /// Locales: en, ru
      static let stakingMonthPeriodTitle = Rswift.StringResource(key: "staking.month.period.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Moonbeam account is missing
      ///
      /// Locales: en, ru
      static let crowdloanMoonbeamMissingAccountTitle = Rswift.StringResource(key: "crowdloan.moonbeam.missing.account.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Moonbeams Terms & Conditions
      ///
      /// Locales: en, ru
      static let crowdloanMoonbeamTermsTitle = Rswift.StringResource(key: "crowdloan.moonbeam.terms.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: More about rewards
      ///
      /// Locales: en, ru
      static let stakingRewardsLearnMore_2_2_0 = Rswift.StringResource(key: "staking.rewards.learn.more_2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Most profitable
      ///
      /// Locales: en, ru
      static let stakingRecommendedHint1 = Rswift.StringResource(key: "staking.recommended.hint1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: My %@ address to receive %@:
      ///
      /// Locales: en, ru
      static let walletReceiveShareMessage = Rswift.StringResource(key: "wallet.receive.share.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Name
      ///
      /// Locales: en, ru
      static let accountInfoNameTitle = Rswift.StringResource(key: "account.info.name.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Name
      ///
      /// Locales: en, ru
      static let accountUsernameSetupChooseTitle = Rswift.StringResource(key: "account.username.setup.choose.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Name examples: Main account, My validator, Dotsama crowdloans, etc.
      ///
      /// Locales: en, ru
      static let walletNicknameCreateCaption_v2_2_0 = Rswift.StringResource(key: "wallet.nickname.create.caption_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Name will be used only locally in this application. You can edit it later
      ///
      /// Locales: en, ru
      static let walletNicknameCreateSubtitle_v2_2_0 = Rswift.StringResource(key: "wallet.nickname.create.subtitle_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network
      ///
      /// Locales: en, ru
      static let commonNetwork = Rswift.StringResource(key: "common.network", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network fee
      ///
      /// Locales: en, ru
      static let commonNetworkFee = Rswift.StringResource(key: "common.network.fee", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network in JSON does not match selected one. The latter will be used to import an account.
      ///
      /// Locales: en, ru
      static let accountImportWrongNetwork = Rswift.StringResource(key: "account.import.wrong.network", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network: %@ Mnemonic: %@
      ///
      /// Locales: en, ru
      static let exportMnemonicWithoutDpTemplate = Rswift.StringResource(key: "export.mnemonic.without.dp.template", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network: %@ Mnemonic: %@ Derivation path: %@
      ///
      /// Locales: en, ru
      static let exportMnemonicWithDpTemplate = Rswift.StringResource(key: "export.mnemonic.with.dp.template", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network: %@ Seed: %@
      ///
      /// Locales: en, ru
      static let exportSeedWithoutDpTemplate = Rswift.StringResource(key: "export.seed.without.dp.template", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Network: %@ Seed: %@ Derivation path: %@
      ///
      /// Locales: en, ru
      static let exportSeedWithDpTemplate = Rswift.StringResource(key: "export.seed.with.dp.template", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Networks
      ///
      /// Locales: en, ru
      static let connectionManagementTitle = Rswift.StringResource(key: "connection.management.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Next
      ///
      /// Locales: en, ru
      static let commonNext = Rswift.StringResource(key: "common.next", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: No data retrieved.
      ///
      /// Locales: en, ru
      static let commonErrorNoDataRetrieved = Rswift.StringResource(key: "common.error.no.data.retrieved", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: No redeemable tokens found
      ///
      /// Locales: en, ru
      static let stakingRedeemNoTokensMessage = Rswift.StringResource(key: "staking.redeem.no.tokens.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: No search results. Be sure you typed full account address
      ///
      /// Locales: en, ru
      static let stakingValidatorSearchEmptyTitle = Rswift.StringResource(key: "staking.validator.search.empty.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Node Info
      ///
      /// Locales: en, ru
      static let networkInfoTitle = Rswift.StringResource(key: "network.info.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Node address
      ///
      /// Locales: en, ru
      static let networkInfoAddress = Rswift.StringResource(key: "network.info.address", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Node name
      ///
      /// Locales: en, ru
      static let networkInfoName = Rswift.StringResource(key: "network.info.name", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nominated: 
      ///
      /// Locales: en, ru
      static let stakingYourNominatedPrefix = Rswift.StringResource(key: "staking.your.nominated.prefix", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nominated: %@
      ///
      /// Locales: en, ru
      static let stakingYourNominatedFormat = Rswift.StringResource(key: "staking.your.nominated.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nominator earns passive income by locking his tokens for securing the network. To achieve that, the nominator should select a number of validators to support. The nominator should be careful when selecting validators. If selected validator wont behave properly, slashing penalties would be applied to both of them, based on the severity of the incident.
      ///
      /// Locales: en, ru
      static let stakingStoryNominatorPage1 = Rswift.StringResource(key: "staking.story.nominator.page.1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nominators
      ///
      /// Locales: en, ru
      static let stakingValidatorNominators = Rswift.StringResource(key: "staking.validator.nominators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: None of your validators have been elected by network.
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusAlertNoValidators = Rswift.StringResource(key: "staking.nominator.status.alert.no.validators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Not elected
      ///
      /// Locales: en, ru
      static let stakingValidatorStatusUnelected = Rswift.StringResource(key: "staking.validator.status.unelected", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Not elected (%@)
      ///
      /// Locales: en, ru
      static let stakingYourNotElectedFormat = Rswift.StringResource(key: "staking.your.not.elected.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Not listed
      ///
      /// Locales: en, ru
      static let nftListNotListed = Rswift.StringResource(key: "nft.list.not.listed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Not now
      ///
      /// Locales: en, ru
      static let commonNotNow = Rswift.StringResource(key: "common.not.now", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Not oversubscribed
      ///
      /// Locales: en, ru
      static let stakingRecommendedHint2 = Rswift.StringResource(key: "staking.recommended.hint2", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Not slashed
      ///
      /// Locales: en, ru
      static let stakingRecommendedHint4 = Rswift.StringResource(key: "staking.recommended.hint4", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova Wallet believes that this website could compromise the security of your accounts and your tokens
      ///
      /// Locales: en, ru
      static let dappPhishingMessage = Rswift.StringResource(key: "dapp.phishing.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova Wallet bonus (%@)
      ///
      /// Locales: en, ru
      static let crowdloanAppBonusFormat = Rswift.StringResource(key: "crowdloan.app.bonus.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova Wallet created a list of recommended validators based on blockchain data and with the following criteria:
      ///
      /// Locales: en, ru
      static let stakingSelectValidatorsRecommendedDesc_v2_2_0 = Rswift.StringResource(key: "staking.select.validators.recommended.desc_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova Wallet provides a support for nominators by helping them to select validators. The mobile app fetches data from the blockchain and composes a list of validators, which have: most profits, identity with contact info, not slashed and available to receive nominations. Nova Wallet also cares about decentralization, so if one person or a company runs several validator nodes, only up to 2 nodes from them will be shown in the recommended list.
      ///
      /// Locales: en, ru
      static let stakingStoryNominatorPage2 = Rswift.StringResource(key: "staking.story.nominator.page.2", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova Wallet will select the top validators based on security and profitability criteria
      ///
      /// Locales: en, ru
      static let stakingRecommendedBannerMessage = Rswift.StringResource(key: "staking.recommended.banner.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova support
      ///
      /// Locales: en, ru
      static let helpSupportTitle = Rswift.StringResource(key: "help.support.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Nova wallet will change rewards destination  to your account to avoid remaining stake.
      ///
      /// Locales: en, ru
      static let stakingHintUnbondKillsStash = Rswift.StringResource(key: "staking.hint.unbond.kills.stash", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: OK
      ///
      /// Locales: en, ru
      static let commonOk = Rswift.StringResource(key: "common.ok", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Okay, take me back
      ///
      /// Locales: en, ru
      static let dappPhishingAction = Rswift.StringResource(key: "dapp.phishing.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: One of your validators have been elected by network.
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusAlertActiveMessage = Rswift.StringResource(key: "staking.nominator.status.alert.active.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Open settings
      ///
      /// Locales: en, ru
      static let commonOpenSettings = Rswift.StringResource(key: "common.open.settings", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Operation Failed
      ///
      /// Locales: en, ru
      static let operationErrorTitle = Rswift.StringResource(key: "operation.error.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Operation will remove account
      ///
      /// Locales: en, ru
      static let commonExistentialWarningTitle = Rswift.StringResource(key: "common.existential.warning.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Operation will remove account from blockstore since it will make total balance lower than minimal balance.
      ///
      /// Locales: en, ru
      static let commonExistentialWarningMessage = Rswift.StringResource(key: "common.existential.warning.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Other transactions
      ///
      /// Locales: en, ru
      static let walletFiltersExtrinsics = Rswift.StringResource(key: "wallet.filters.extrinsics", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Others, who are active without your stake allocation.
      ///
      /// Locales: en, ru
      static let stakingYourNotAllocatedDescription = Rswift.StringResource(key: "staking.your.not.allocated.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Oversubscribed. Only the top staked nominators are paid rewards.
      ///
      /// Locales: en, ru
      static let stakingValidatorOtherOversubscribedMessage = Rswift.StringResource(key: "staking.validator.other.oversubscribed.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Oversubscribed. You will not receive rewards from the validator in this era.
      ///
      /// Locales: en, ru
      static let stakingValidatorMyOversubscribedMessage = Rswift.StringResource(key: "staking.validator.my.oversubscribed.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Own
      ///
      /// Locales: en, ru
      static let stakingValidatorOwnStake = Rswift.StringResource(key: "staking.validator.own.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Owned by
      ///
      /// Locales: en, ru
      static let nftOwnerTitle = Rswift.StringResource(key: "nft.owner.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Password
      ///
      /// Locales: en, ru
      static let accountImportPasswordPlaceholder = Rswift.StringResource(key: "account.import.password.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Password is required to encrypt your account and store as Restore JSON. Please, create password to continue operation.
      ///
      /// Locales: en, ru
      static let accountExportJsonHint = Rswift.StringResource(key: "account.export.json.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Passwords do not match
      ///
      /// Locales: en, ru
      static let commonErrorPasswordMismatch = Rswift.StringResource(key: "common.error.password.mismatch", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Paste
      ///
      /// Locales: en, ru
      static let commonPaste = Rswift.StringResource(key: "common.paste", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Paste json
      ///
      /// Locales: en, ru
      static let accountImportRecoveryJsonPlaceholder = Rswift.StringResource(key: "account.import.recovery.json.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Paste json or upload file
      ///
      /// Locales: en, ru
      static let recoverJsonHint = Rswift.StringResource(key: "recover.json.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout
      ///
      /// Locales: en, ru
      static let stakingPayoutTitle = Rswift.StringResource(key: "staking.payout.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsPayout = Rswift.StringResource(key: "staking.reward.details.payout", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout account
      ///
      /// Locales: en, ru
      static let stakingRewardPayoutAccount = Rswift.StringResource(key: "staking.reward.payout.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout all (%@)
      ///
      /// Locales: en, ru
      static let stakingRewardPayoutsPayoutAll = Rswift.StringResource(key: "staking.reward.payouts.payout.all", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout all rewards
      ///
      /// Locales: en, ru
      static let stakingPendingRewardsPayoutAll = Rswift.StringResource(key: "staking.pending.rewards.payout.all", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout expired
      ///
      /// Locales: en, ru
      static let stakingPayoutExpired = Rswift.StringResource(key: "staking.payout.expired", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Payout transaction sent
      ///
      /// Locales: en, ru
      static let stakingPayoutSent = Rswift.StringResource(key: "staking.payout.sent", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Pending
      ///
      /// Locales: en, ru
      static let transactionStatusPending = Rswift.StringResource(key: "transaction.status.pending", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Pending rewards
      ///
      /// Locales: en, ru
      static let stakingPendingRewards = Rswift.StringResource(key: "staking.pending.rewards", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Pending rewards
      ///
      /// Locales: en, ru
      static let stakingRewardPayoutsTitle = Rswift.StringResource(key: "staking.reward.payouts.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Perfect! All rewards are paid.
      ///
      /// Locales: en, ru
      static let stakingRewardPayoutsEmptyRewards = Rswift.StringResource(key: "staking.reward.payouts.empty.rewards", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Phishing detected
      ///
      /// Locales: en, ru
      static let dappPhishingTitle = Rswift.StringResource(key: "dapp.phishing.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Photos Access
      ///
      /// Locales: en, ru
      static let qrScanErrorGalleryTitle = Rswift.StringResource(key: "qr.scan.error.gallery.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please make sure to write down your phrase correctly and legibly.
      ///
      /// Locales: en, ru
      static let accountBackupMnemonicCaption = Rswift.StringResource(key: "account.backup.mnemonic.caption", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please wait for the next era to start.
      ///
      /// Locales: en, ru
      static let stakingAlertStartNextEraMessage = Rswift.StringResource(key: "staking.alert.start.next.era.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please wait until fee is calculated
      ///
      /// Locales: en, ru
      static let feeNotYetLoadedMessage = Rswift.StringResource(key: "fee.not.yet.loaded.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check internet connection and try again later.
      ///
      /// Locales: en, ru
      static let connectionErrorMessage = Rswift.StringResource(key: "connection.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check order of the words one more time.
      ///
      /// Locales: en, ru
      static let confirmMnemonicMismatchErrorMessage = Rswift.StringResource(key: "confirm.mnemonic.mismatch.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check password correctness and try again.
      ///
      /// Locales: en, ru
      static let accountImportKeystoreDecryptionErrorMessage = Rswift.StringResource(key: "account.import.keystore.decryption.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of characters not including /.
      ///
      /// Locales: en, ru
      static let commonInvalidHardSoftMessage = Rswift.StringResource(key: "common.invalid.hard.soft.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of characters not including /. The path can end up with ///'password'. For example, //1/nova///mypass.
      ///
      /// Locales: en, ru
      static let commonInvalidPathWithSoftMessage = Rswift.StringResource(key: "common.invalid.path.with.soft.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of digits not including /. For example, //44//60//0/0/0
      ///
      /// Locales: en, ru
      static let commonInvalidHardSoftNumericMessage = Rswift.StringResource(key: "common.invalid.hard.soft.numeric.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of digits not including /. The path can end up with ///'password'. For example, //44//60//0/0/0///mypass.
      ///
      /// Locales: en, ru
      static let commonInvalidHardSoftNumericPasswordMessage = Rswift.StringResource(key: "common.invalid.hard.soft.numeric.password.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check that input is a mix of //'hard' where 'hard' can be any sequence of characters not including /.
      ///
      /// Locales: en, ru
      static let commonInvalidHardMessage = Rswift.StringResource(key: "common.invalid.hard.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check that input is a mix of //'hard' where 'hard' can be any sequence of characters not including /. The path can end up with ///'password'. For example, //1//nova///mypass.
      ///
      /// Locales: en, ru
      static let commonInvalidPathWithoutSoftMessage = Rswift.StringResource(key: "common.invalid.path.without.soft.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, check your connection or try again later
      ///
      /// Locales: en, ru
      static let connectionErrorMessage_v2_2_0 = Rswift.StringResource(key: "connection.error.message_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, make sure that the mail application is installed on the device.
      ///
      /// Locales: en, ru
      static let noEmailBoundErrorMessage = Rswift.StringResource(key: "no.email.bound.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, make sure to write down your phrase correctly  and legibly
      ///
      /// Locales: en, ru
      static let exportMnemonicCheckHint = Rswift.StringResource(key: "export.mnemonic.check.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, make sure to write down your secret correctly and legibly
      ///
      /// Locales: en, ru
      static let exportSeedHint = Rswift.StringResource(key: "export.seed.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, try again later
      ///
      /// Locales: en, ru
      static let operationErrorMessage = Rswift.StringResource(key: "operation.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Please, try again with another input. If the error appears again, please, contact support.
      ///
      /// Locales: en, ru
      static let commonUndefinedErrorMessage = Rswift.StringResource(key: "common.undefined.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Preferences
      ///
      /// Locales: en, ru
      static let settingsPreferences = Rswift.StringResource(key: "settings.preferences", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Price
      ///
      /// Locales: en, ru
      static let commonPrice = Rswift.StringResource(key: "common.price", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Privacy Policy
      ///
      /// Locales: en, ru
      static let onboardingPrivacyPolicy = Rswift.StringResource(key: "onboarding.privacy.policy", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Privacy policy
      ///
      /// Locales: en, ru
      static let aboutPrivacy = Rswift.StringResource(key: "about.privacy", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Private crowdloan
      ///
      /// Locales: en, ru
      static let crowdloanPrivateCrowdloanTitle = Rswift.StringResource(key: "crowdloan.private.crowdloan.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Private crowdloans are not yet supported.
      ///
      /// Locales: en, ru
      static let crowdloanPrivateCrowdloanMessage = Rswift.StringResource(key: "crowdloan.private.crowdloan.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Proceed
      ///
      /// Locales: en, ru
      static let commonProceed = Rswift.StringResource(key: "common.proceed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Provide your Restore JSON
      ///
      /// Locales: en, ru
      static let walletImportKeystoreTitle = Rswift.StringResource(key: "wallet.import.keystore.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Provide your Restore JSON...
      ///
      /// Locales: en, ru
      static let walletImportNoJsonTitle = Rswift.StringResource(key: "wallet.import.no.json.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Purchase initiated! Please wait up to 60 minutes. You can track status on the email.
      ///
      /// Locales: en, ru
      static let buyCompleted = Rswift.StringResource(key: "buy.completed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: QR can't be decoded
      ///
      /// Locales: en, ru
      static let qrScanErrorNoInfo = Rswift.StringResource(key: "qr.scan.error.no.info", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Raised
      ///
      /// Locales: en, ru
      static let crowdloanRaised = Rswift.StringResource(key: "crowdloan.raised", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Raised: %@ of %@
      ///
      /// Locales: en, ru
      static let crowdloanProgressFormat = Rswift.StringResource(key: "crowdloan.progress.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rate us
      ///
      /// Locales: en, ru
      static let settingsRateUs = Rswift.StringResource(key: "settings.rate.us", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Raw seed
      ///
      /// Locales: en, ru
      static let importRawSeed = Rswift.StringResource(key: "import.raw.seed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Raw seed
      ///
      /// Locales: en, ru
      static let secretTypeSeedTitle = Rswift.StringResource(key: "secret.type.seed.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Raw seed: 128 hex symbols
      ///
      /// Locales: en, ru
      static let accountImportEthereumSeedPlaceholder = Rswift.StringResource(key: "account.import.ethereum.seed.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Raw seed: 64 hex symbols
      ///
      /// Locales: en, ru
      static let accountImportSubstrateSeedPlaceholder = Rswift.StringResource(key: "account.import.substrate.seed.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rebond custom amount
      ///
      /// Locales: en, ru
      static let stakingRebondCustomAmount = Rswift.StringResource(key: "staking.rebond.custom.amount", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Receive
      ///
      /// Locales: en, ru
      static let walletAssetReceive = Rswift.StringResource(key: "wallet.asset.receive", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Receive %@
      ///
      /// Locales: en, ru
      static let walletReceiveTitleFormat = Rswift.StringResource(key: "wallet.receive.title.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Received
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsStatusReceived = Rswift.StringResource(key: "staking.reward.details.status.received", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Receiving rewards
      ///
      /// Locales: en, ru
      static let stakingStoryRewardTitle = Rswift.StringResource(key: "staking.story.reward.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Recipient
      ///
      /// Locales: en, ru
      static let commonRecipient = Rswift.StringResource(key: "common.recipient", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Recipient is not able to accept transfer
      ///
      /// Locales: en, ru
      static let walletSendDeadRecipientCommissionAssetTitle = Rswift.StringResource(key: "wallet.send.dead.recipient.commission.asset.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Recipient should be a valid %@ address
      ///
      /// Locales: en, ru
      static let commonValidationInvalidAddressMessage = Rswift.StringResource(key: "common.validation.invalid.address.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Recipient's address must differ from sender
      ///
      /// Locales: en, ru
      static let commonSameReceiveAddressMessage = Rswift.StringResource(key: "common.same.receive.address.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Recommended validators
      ///
      /// Locales: en, ru
      static let stakingRecommendedSectionTitle = Rswift.StringResource(key: "staking.recommended.section.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Redeem
      ///
      /// Locales: en, ru
      static let stakingRedeem = Rswift.StringResource(key: "staking.redeem", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Redeem unstaked tokens.
      ///
      /// Locales: en, ru
      static let stakingRedeemUnbondedTokens = Rswift.StringResource(key: "staking.redeem.unbonded.tokens", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Redeemable
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsStatusClaimable = Rswift.StringResource(key: "staking.reward.details.status.claimable", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Redeemable
      ///
      /// Locales: en, ru
      static let walletBalanceRedeemable = Rswift.StringResource(key: "wallet.balance.redeemable", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Redeemable: %@
      ///
      /// Locales: en, ru
      static let stakingRedeemableFormat = Rswift.StringResource(key: "staking.redeemable.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Referral code
      ///
      /// Locales: en, ru
      static let commonReferralCodeTitle = Rswift.StringResource(key: "common.referral.code.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Referral code is invalid. Please, try another one
      ///
      /// Locales: en, ru
      static let crowdloanReferralCodeInvalid = Rswift.StringResource(key: "crowdloan.referral.code.invalid", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Referral code verification failed. Please, try again later.
      ///
      /// Locales: en, ru
      static let crowdloanReferralCodeInternal = Rswift.StringResource(key: "crowdloan.referral.code.internal", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reject
      ///
      /// Locales: en, ru
      static let commonReject = Rswift.StringResource(key: "common.reject", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reload
      ///
      /// Locales: en, ru
      static let commonReload = Rswift.StringResource(key: "common.reload", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Remaining staking balance will drop under minimum value and also will be added to unstaking amount
      ///
      /// Locales: en, ru
      static let stakingUnbondingAllMessage = Rswift.StringResource(key: "staking.unbonding.all.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Remove
      ///
      /// Locales: en, ru
      static let commonRemove = Rswift.StringResource(key: "common.remove", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Remove from Authorized?
      ///
      /// Locales: en, ru
      static let dappRemoveAuthorizedTitle = Rswift.StringResource(key: "dapp.remove.authorized.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Remove from Favorites?
      ///
      /// Locales: en, ru
      static let dappRemoveFavoritesTitle = Rswift.StringResource(key: "dapp.remove.favorites.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reserved
      ///
      /// Locales: en, ru
      static let walletBalanceReserved = Rswift.StringResource(key: "wallet.balance.reserved", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reset
      ///
      /// Locales: en, ru
      static let commonReset = Rswift.StringResource(key: "common.reset", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Restake
      ///
      /// Locales: en, ru
      static let stakingRestakeTitle = Rswift.StringResource(key: "staking.restake.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Restake
      ///
      /// Locales: en, ru
      static let stakingSetupRestakeTitle = Rswift.StringResource(key: "staking.setup.restake.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Restake rewards
      ///
      /// Locales: en, ru
      static let stakingRestakeTitle_v2_2_0 = Rswift.StringResource(key: "staking.restake.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Restake rewards
      ///
      /// Locales: en, ru
      static let stakingSetupRestakeTitle_v2_2_0 = Rswift.StringResource(key: "staking.setup.restake.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Restore JSON
      ///
      /// Locales: en, ru
      static let importRecoveryJson = Rswift.StringResource(key: "import.recovery.json", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Restore JSON
      ///
      /// Locales: en, ru
      static let secretTypeKeystoreTitle = Rswift.StringResource(key: "secret.type.keystore.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Retry
      ///
      /// Locales: en, ru
      static let commonRetry = Rswift.StringResource(key: "common.retry", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Return to stake
      ///
      /// Locales: en, ru
      static let stakingRebond = Rswift.StringResource(key: "staking.rebond", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Returned tokens will be counted from the next era
      ///
      /// Locales: en, ru
      static let stakingRebondHint = Rswift.StringResource(key: "staking.rebond.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reward
      ///
      /// Locales: en, ru
      static let stakingReward = Rswift.StringResource(key: "staking.reward", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reward
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsReward = Rswift.StringResource(key: "staking.reward.details.reward", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Reward details
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsTitle = Rswift.StringResource(key: "staking.reward.details.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewarded
      ///
      /// Locales: en, ru
      static let stakingTotalRewards_v190 = Rswift.StringResource(key: "staking.total.rewards_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards
      ///
      /// Locales: en, ru
      static let stakingRewardsTitle = Rswift.StringResource(key: "staking.rewards.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards (APY)
      ///
      /// Locales: en, ru
      static let stakingCommonRewardsApy = Rswift.StringResource(key: "staking.common.rewards.apy", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards (APY)
      ///
      /// Locales: en, ru
      static let stakingFilterTitleRewards = Rswift.StringResource(key: "staking.filter.title.rewards", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards and Slashes
      ///
      /// Locales: en, ru
      static let walletFiltersRewardsAndSlashes = Rswift.StringResource(key: "wallet.filters.rewards.and.slashes", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards are paid every 23 days by validators
      ///
      /// Locales: en, ru
      static let stakingPendingRewardsHintTitle = Rswift.StringResource(key: "staking.pending.rewards.hint.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards are paid every 23 days by validators. You can payout them by yourself, when they are close to expire, but you will pay the fee
      ///
      /// Locales: en, ru
      static let stakingPendingRewardsExplanationMessage_2_2_0 = Rswift.StringResource(key: "staking.pending.rewards.explanation.message_2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards destination
      ///
      /// Locales: en, ru
      static let stakingRewardsDestinationTitle = Rswift.StringResource(key: "staking.rewards.destination.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards destination
      ///
      /// Locales: en, ru
      static let stakingRewardsDestinationTitle_v2_0_0 = Rswift.StringResource(key: "staking.rewards.destination.title_v2_0_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Rewards for staking are available to payout at the end of each era (6 hours in Kusama and 24 hours in Polkadot). Network stores pending rewards during 84 eras and in most cases validators are paying out the rewards for everyone. However, validators might forget or something might happen with them, so nominators can payout their rewards by themselves.
      ///
      /// Locales: en, ru
      static let stakingStoryRewardPage1 = Rswift.StringResource(key: "staking.story.reward.page.1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Save
      ///
      /// Locales: en, ru
      static let commonSave = Rswift.StringResource(key: "common.save", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Save transfer request as a qr code
      ///
      /// Locales: en, ru
      static let nsPhotoLibraryAddUsageDescription = Rswift.StringResource(key: "NSPhotoLibraryAddUsageDescription", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Save your secret and store it in a safe place
      ///
      /// Locales: en, ru
      static let exportRestoreJsonTitle = Rswift.StringResource(key: "export.restore.json.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Saved
      ///
      /// Locales: en, ru
      static let commonSaved = Rswift.StringResource(key: "common.saved", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Scam alert
      ///
      /// Locales: en, ru
      static let walletSendPhishingWarningTitle = Rswift.StringResource(key: "wallet.send.phishing.warning.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Scan QR
      ///
      /// Locales: en, ru
      static let recepientScanTitle = Rswift.StringResource(key: "recepient.scan.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Scan QR code from receiver
      ///
      /// Locales: en, ru
      static let recepientScanMessage = Rswift.StringResource(key: "recepient.scan.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Schnorrkel
      ///
      /// Locales: en, ru
      static let sr25519SelectionTitle = Rswift.StringResource(key: "sr25519.selection.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search
      ///
      /// Locales: en, ru
      static let commonSearch = Rswift.StringResource(key: "common.search", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search
      ///
      /// Locales: en, ru
      static let dappSearchQuerySection = Rswift.StringResource(key: "dapp.search.query.section", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search by address or name
      ///
      /// Locales: en, ru
      static let stakingValidatorSearchPlaceholder = Rswift.StringResource(key: "staking.validator.search.placeholder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search by address or name
      ///
      /// Locales: en, ru
      static let walletContactsSearchPlaceholder_v110 = Rswift.StringResource(key: "wallet.contacts.search.placeholder_v1.10", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search by name or enter URL
      ///
      /// Locales: en, ru
      static let dappListSearch = Rswift.StringResource(key: "dapp.list.search", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search results will be displayed here
      ///
      /// Locales: en, ru
      static let commonSearchStartTitle_v2_2_0 = Rswift.StringResource(key: "common.search.start.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Search results: %li
      ///
      /// Locales: en, ru
      static let commonSearchResultsNumber = Rswift.StringResource(key: "common.search.results.number", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Searching pending rewards...
      ///
      /// Locales: en, ru
      static let stakingPendingRewardSearch = Rswift.StringResource(key: "staking.pending.reward.search", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Secret derivation path
      ///
      /// Locales: en, ru
      static let commonSecretDerivationPath = Rswift.StringResource(key: "common.secret.derivation.path", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Security
      ///
      /// Locales: en, ru
      static let settingsSecurity = Rswift.StringResource(key: "settings.security", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Seed is invalid. Please, make sure that your input contains 64 hex symbols.
      ///
      /// Locales: en, ru
      static let accountImportInvalidSeed = Rswift.StringResource(key: "account.import.invalid.seed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select another account as a controller to delegate staking management operations to it
      ///
      /// Locales: en, ru
      static let stakingControllerBannerMessage = Rswift.StringResource(key: "staking.controller.banner.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select another account as a controller to improve staking security by delegating staking management operations to it
      ///
      /// Locales: en, ru
      static let stakingSetSeparateAccountController_v2_2_0 = Rswift.StringResource(key: "staking.set.separate.account.controller_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select asset
      ///
      /// Locales: en, ru
      static let commonSelectAsset = Rswift.StringResource(key: "common.select.asset", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select by yourself
      ///
      /// Locales: en, ru
      static let stakingSelectValidatorsCustomButtonTitle = Rswift.StringResource(key: "staking.select.validators.custom.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select network
      ///
      /// Locales: en, ru
      static let commonSelectNetwork = Rswift.StringResource(key: "common.select.network", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select parachains to contribute your %@. You will receive rewards if the parachain acquires a slot by the end of the auction.
      ///
      /// Locales: en, ru
      static let crowdloanListSectionFormat = Rswift.StringResource(key: "crowdloan.list.section.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select recommended
      ///
      /// Locales: en, ru
      static let stakingSelectValidatorsRecommendedButtonTitle = Rswift.StringResource(key: "staking.select.validators.recommended.button.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select the controller account
      ///
      /// Locales: en, ru
      static let stakingControllerSelectTitle = Rswift.StringResource(key: "staking.controller.select.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select the words in the right order.
      ///
      /// Locales: en, ru
      static let confirmMnemonicSubtitle = Rswift.StringResource(key: "confirm.mnemonic.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select the words...
      ///
      /// Locales: en, ru
      static let confirmMnemonicSelectWord = Rswift.StringResource(key: "confirm.mnemonic.select.word", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select validators
      ///
      /// Locales: en, ru
      static let stakingCustomValidatorsListTitle = Rswift.StringResource(key: "staking.custom.validators.list.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select validators (max %li)
      ///
      /// Locales: en, ru
      static let stakingCustomProceedButtonDisabledTitle = Rswift.StringResource(key: "staking.custom.proceed.button.disabled.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select validators to start staking
      ///
      /// Locales: en, ru
      static let stakingSetValidatorsTitle = Rswift.StringResource(key: "staking.set.validators.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select your rewards type
      ///
      /// Locales: en, ru
      static let stakingSetupRewardDestinationSectionTitle_v2_2_0 = Rswift.StringResource(key: "staking.setup.reward.destination.section.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Select your secret type
      ///
      /// Locales: en, ru
      static let secretTypePickerTitle = Rswift.StringResource(key: "secret.type.picker.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Selected (%@)
      ///
      /// Locales: en, ru
      static let stakingYourSelectedFormat = Rswift.StringResource(key: "staking.your.selected.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Selected account is already in use as controller
      ///
      /// Locales: en, ru
      static let stakingAccountIsUsedAsController = Rswift.StringResource(key: "staking.account.is.used.as.controller", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Selected validators
      ///
      /// Locales: en, ru
      static let stakingSelectedValidatorsTitle = Rswift.StringResource(key: "staking.selected.validators.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Send
      ///
      /// Locales: en, ru
      static let walletSendTitle = Rswift.StringResource(key: "wallet.send.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Send %@
      ///
      /// Locales: en, ru
      static let walletSendTokenTitle = Rswift.StringResource(key: "wallet.send.token.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Send %@ on
      ///
      /// Locales: en, ru
      static let walletTransferTokenFormat = Rswift.StringResource(key: "wallet.transfer.token.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Send to this contact
      ///
      /// Locales: en, ru
      static let txDetailsSendTitle = Rswift.StringResource(key: "tx.details.send.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Sender
      ///
      /// Locales: en, ru
      static let commonSender = Rswift.StringResource(key: "common.sender", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Set a new password
      ///
      /// Locales: en, ru
      static let exportPasswordTitle = Rswift.StringResource(key: "export.password.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Set a separate account as a controller to increase staking management security.
      ///
      /// Locales: en, ru
      static let stakingSetSeparateAccountController = Rswift.StringResource(key: "staking.set.separate.account.controller", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Set password
      ///
      /// Locales: en, ru
      static let commonSetPassword = Rswift.StringResource(key: "common.set.password", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Set password...
      ///
      /// Locales: en, ru
      static let exportPasswordProceedSetTitle = Rswift.StringResource(key: "export.password.proceed.set.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Set validators
      ///
      /// Locales: en, ru
      static let stakingSetValidators = Rswift.StringResource(key: "staking.set.validators", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Set your pin code
      ///
      /// Locales: en, ru
      static let pincodeSetYourPinCode = Rswift.StringResource(key: "pincode.set.your.pin.code", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Settings
      ///
      /// Locales: en, ru
      static let profileTitle = Rswift.StringResource(key: "profile.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Settings
      ///
      /// Locales: en, ru
      static let tabbarSettingsTitle = Rswift.StringResource(key: "tabbar.settings.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Share QR code
      ///
      /// Locales: en, ru
      static let walletReceiveShareTitle = Rswift.StringResource(key: "wallet.receive.share.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Share this QR to sender
      ///
      /// Locales: en, ru
      static let walletReceiveDescription = Rswift.StringResource(key: "wallet.receive.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Sharing or copying your secret is a high risk operation, dont send it to anyone. Would you like to proceed with sharing/copying process?
      ///
      /// Locales: en, ru
      static let accountExportWarningMessage = Rswift.StringResource(key: "account.export.warning.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Show
      ///
      /// Locales: en, ru
      static let walletFiltersHeader = Rswift.StringResource(key: "wallet.filters.header", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Show selected: %li (max %li)
      ///
      /// Locales: en, ru
      static let stakingCustomProceedButtonEnabledTitle = Rswift.StringResource(key: "staking.custom.proceed.button.enabled.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Skip
      ///
      /// Locales: en, ru
      static let commonSkip = Rswift.StringResource(key: "common.skip", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Skip process
      ///
      /// Locales: en, ru
      static let confirmationSkipAction = Rswift.StringResource(key: "confirmation.skip.action", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Slash
      ///
      /// Locales: en, ru
      static let stakingSlash = Rswift.StringResource(key: "staking.slash", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Sorry, you don't have enough funds to pay the network fee.
      ///
      /// Locales: en, ru
      static let commonNotEnoughFeeMessage = Rswift.StringResource(key: "common.not.enough.fee.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Sorry, you don't have enough funds to spend specified amount
      ///
      /// Locales: en, ru
      static let commonNotEnoughBalanceMessage = Rswift.StringResource(key: "common.not.enough.balance.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Sort by:
      ///
      /// Locales: en, ru
      static let commonFilterSortHeader = Rswift.StringResource(key: "common.filter.sort.header", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Source type
      ///
      /// Locales: en, ru
      static let importSourcePickerTitle = Rswift.StringResource(key: "import.source.picker.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake
      ///
      /// Locales: en, ru
      static let stakingStake = Rswift.StringResource(key: "staking.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake %@
      ///
      /// Locales: en, ru
      static let stakingStakeFormat = Rswift.StringResource(key: "staking.stake.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake more
      ///
      /// Locales: en, ru
      static let stakingBondMore_v190 = Rswift.StringResource(key: "staking.bond.more_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake more request has been submitted
      ///
      /// Locales: en, ru
      static let stakingBondMoreCompletion = Rswift.StringResource(key: "staking.bond.more.completion", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake more tokens.
      ///
      /// Locales: en, ru
      static let stakingBondMoreTokens = Rswift.StringResource(key: "staking.bond.more.tokens", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake with recommended validators
      ///
      /// Locales: en, ru
      static let stakingRecommendedBannerTitle = Rswift.StringResource(key: "staking.recommended.banner.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stake with your validators
      ///
      /// Locales: en, ru
      static let stakingSelectValidatorsCustomTitle = Rswift.StringResource(key: "staking.select.validators.custom.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staked
      ///
      /// Locales: en, ru
      static let stakingMainStakeBalanceStaked = Rswift.StringResource(key: "staking.main.stake.balance.staked", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staked
      ///
      /// Locales: en, ru
      static let walletBalanceBonded = Rswift.StringResource(key: "wallet.balance.bonded", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staked tokens generate rewards each era (%@).
      ///
      /// Locales: en, ru
      static let stakingHintRewardsFormat = Rswift.StringResource(key: "staking.hint.rewards.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staked:
      ///
      /// Locales: en, ru
      static let commonStakedPrefix = Rswift.StringResource(key: "common.staked.prefix", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking
      ///
      /// Locales: en, ru
      static let stakingTitle = Rswift.StringResource(key: "staking.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking
      ///
      /// Locales: en, ru
      static let tabbarStakingTitle = Rswift.StringResource(key: "tabbar.staking.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking balance
      ///
      /// Locales: en, ru
      static let stakingBalanceTitle = Rswift.StringResource(key: "staking.balance.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking for validator
      ///
      /// Locales: en, ru
      static let stakingValidatorSummaryTitle = Rswift.StringResource(key: "staking.validator.summary.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking is an important part of network security and reliability. Anyone can run validator nodes, but only those who have enough tokens staked will be elected by the network to participate in composing new blocks and receive the rewards. Validators often do not have enough tokens by themselves, so nominators are helping them by locking their tokens for them to achieve the required amount of stake.
      ///
      /// Locales: en, ru
      static let stakingStoryStakingPage2 = Rswift.StringResource(key: "staking.story.staking.page.2", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking is an option to earn passive income by locking your tokens in the network. Staking rewards are allocated every era (6 hours on Kusama and 24 hours on Polkadot). You can stake as long as you wish, and for unstaking your tokens you need to wait for the unstacking period to end, making your tokens available to be redeemed.
      ///
      /// Locales: en, ru
      static let stakingStoryStakingPage1 = Rswift.StringResource(key: "staking.story.staking.page.1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking is currently inactive. Current minimal stake is %@.
      ///
      /// Locales: en, ru
      static let stakingInactiveCurrentMinimalStake = Rswift.StringResource(key: "staking.inactive.current.minimal.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking period
      ///
      /// Locales: en, ru
      static let stakingNetworkInfoStakingPeriodTitle = Rswift.StringResource(key: "staking.network.info.staking.period.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking setup transaction sent
      ///
      /// Locales: en, ru
      static let stakingSetupSentMessage = Rswift.StringResource(key: "staking.setup.sent.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking was active
      ///
      /// Locales: en, ru
      static let stakingAnalyticsStakingWasActive = Rswift.StringResource(key: "staking.analytics.staking.was.active", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Staking was inactive
      ///
      /// Locales: en, ru
      static let stakingAnalyticsStakingWasInactive = Rswift.StringResource(key: "staking.analytics.staking.was.inactive", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Start staking
      ///
      /// Locales: en, ru
      static let stakingStartTitle = Rswift.StringResource(key: "staking.start.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stash
      ///
      /// Locales: en, ru
      static let stakingStash = Rswift.StringResource(key: "staking.stash", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stash account
      ///
      /// Locales: en, ru
      static let stackingStashAccount = Rswift.StringResource(key: "stacking.stash.account", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stash account %@ is unavailable to update staking setup.
      ///
      /// Locales: en, ru
      static let stakingStashMissingMessage = Rswift.StringResource(key: "staking.stash.missing.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stash can stake more and set the controller.
      ///
      /// Locales: en, ru
      static let stakingStashCanHint = Rswift.StringResource(key: "staking.stash.can.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stash is used to: stake more and set the controller
      ///
      /// Locales: en, ru
      static let stakingStashCanHint_v2_2_0 = Rswift.StringResource(key: "staking.stash.can.hint_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Status
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsStatus = Rswift.StringResource(key: "staking.reward.details.status", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Status
      ///
      /// Locales: en, ru
      static let transactionDetailStatus = Rswift.StringResource(key: "transaction.detail.status", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Stop staking
      ///
      /// Locales: en, ru
      static let stakingUnbondingAllTitle = Rswift.StringResource(key: "staking.unbonding.all.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Submit agreement
      ///
      /// Locales: en, ru
      static let crowdloanSubmitAgreement = Rswift.StringResource(key: "crowdloan.submit.agreement", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Substrate keypair crypto type
      ///
      /// Locales: en, ru
      static let commonCryptoTypeSubstrate = Rswift.StringResource(key: "common.crypto.type.substrate", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Substrate secret derivation path
      ///
      /// Locales: en, ru
      static let commonSecretDerivationPathSubstrate = Rswift.StringResource(key: "common.secret.derivation.path.substrate", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Support & Feedback
      ///
      /// Locales: en, ru
      static let settingsSupport = Rswift.StringResource(key: "settings.support", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Switch your account to stash to set the controller.
      ///
      /// Locales: en, ru
      static let stakingSwitchAccountToStash = Rswift.StringResource(key: "staking.switch.account.to.stash", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Telegram
      ///
      /// Locales: en, ru
      static let aboutTelegram = Rswift.StringResource(key: "about.telegram", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Terms and Conditions
      ///
      /// Locales: en, ru
      static let aboutTerms = Rswift.StringResource(key: "about.terms", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Terms and Conditions
      ///
      /// Locales: en, ru
      static let crowdloanTermsValue = Rswift.StringResource(key: "crowdloan.terms.value", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Terms and Conditions
      ///
      /// Locales: en, ru
      static let onboardingTermsAndConditions2 = Rswift.StringResource(key: "onboarding.terms.and.conditions.2", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: The minimum allowed amount to contribute is %@.
      ///
      /// Locales: en, ru
      static let crowdloanTooSmallContributionMessage = Rswift.StringResource(key: "crowdloan.too.small.contribution.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: The network type is not supported yet. Please, choose another one.
      ///
      /// Locales: en, ru
      static let commonUnsupportedNetworkMessage = Rswift.StringResource(key: "common.unsupported.network.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: The node has already been added previously. Please, try another node.
      ///
      /// Locales: en, ru
      static let connectionAddAlreadyExistsError = Rswift.StringResource(key: "connection.add.already.exists.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: The reward destination will be changed to your account to avoid a bonded remnant since staking will be stopped
      ///
      /// Locales: en, ru
      static let stakingUnbondPayeeResetMessage = Rswift.StringResource(key: "staking.unbond.payee.reset.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: The reward is less than the network fee.
      ///
      /// Locales: en, ru
      static let stakingWarningTinyPayout = Rswift.StringResource(key: "staking.warning.tiny.payout", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: The validator runs a blockchain node 24/7 and is required to have enough stake locked (both owned and provided by nominators) to be elected by the network. Validators should maintain their nodes' performance and reliability to be rewarded. Being a validator is almost a full-time job, there are companies that are focused to be validators on the blockchain networks.
      ///
      /// Locales: en, ru
      static let stakingStoryValidatorPage1 = Rswift.StringResource(key: "staking.story.validator.page.1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: This crowdloan isn't available in your location.
      ///
      /// Locales: en, ru
      static let crowdloanMoonbeamRegionRestrictionMessage = Rswift.StringResource(key: "crowdloan.moonbeam.region.restriction.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: This name will be displayed only for you and stored locally on your mobile device.
      ///
      /// Locales: en, ru
      static let accountUsernameSetupHint = Rswift.StringResource(key: "account.username.setup.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: This nickname will be displayed only for you and stored locally on your mobile device.
      ///
      /// Locales: en, ru
      static let walletNicknameCreateSubtitle = Rswift.StringResource(key: "wallet.nickname.create.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: This validator is not accepting nominations at this moment. Please, try again in the next era.
      ///
      /// Locales: en, ru
      static let stakingCustomBlockedWarning = Rswift.StringResource(key: "staking.custom.blocked.warning", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Time left
      ///
      /// Locales: en, ru
      static let commonTimeLeft = Rswift.StringResource(key: "common.time.left", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Title
      ///
      /// Locales: en, ru
      static let commonTitle = Rswift.StringResource(key: "common.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: To
      ///
      /// Locales: en, ru
      static let walletSendReceiverTitle = Rswift.StringResource(key: "wallet.send.receiver.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: To unstake tokens you will have to wait for the unstaking period (%@)
      ///
      /// Locales: en, ru
      static let stakingHintUnstakeFormat_v2_2_0 = Rswift.StringResource(key: "staking.hint.unstake.format_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Tokens in stake produce rewards each era (%@)
      ///
      /// Locales: en, ru
      static let stakingHintRewardsFormat_v2_2_0 = Rswift.StringResource(key: "staking.hint.rewards.format_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Tokens in unstaking period generate no rewards.
      ///
      /// Locales: en, ru
      static let stakingHintNoRewards = Rswift.StringResource(key: "staking.hint.no.rewards", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total
      ///
      /// Locales: en, ru
      static let walletTransferTotalTitle = Rswift.StringResource(key: "wallet.transfer.total.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total after transfer
      ///
      /// Locales: en, ru
      static let walletSendBalanceTotalAfterTransfer = Rswift.StringResource(key: "wallet.send.balance.total.after.transfer", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total balance
      ///
      /// Locales: en, ru
      static let walletSendBalanceTotal = Rswift.StringResource(key: "wallet.send.balance.total", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total balance
      ///
      /// Locales: en, ru
      static let walletTotalBalance = Rswift.StringResource(key: "wallet.total.balance", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total stake
      ///
      /// Locales: en, ru
      static let stakingValidatorTotalStake = Rswift.StringResource(key: "staking.validator.total.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total stake (%@)
      ///
      /// Locales: en, ru
      static let stakingValidatorTotalStakeToken = Rswift.StringResource(key: "staking.validator.total.stake.token", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Total staked
      ///
      /// Locales: en, ru
      static let stakingMainTotalStakedTitle = Rswift.StringResource(key: "staking.main.total.staked.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Touch ID
      ///
      /// Locales: en, ru
      static let askTouchidTitle = Rswift.StringResource(key: "ask.touchid.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transaction ID
      ///
      /// Locales: en, ru
      static let commonTxId = Rswift.StringResource(key: "common.tx.id", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transaction details
      ///
      /// Locales: en, ru
      static let commonTxDetails = Rswift.StringResource(key: "common.tx.details", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transaction failed. Please, try again later.
      ///
      /// Locales: en, ru
      static let commonTransactionFailed = Rswift.StringResource(key: "common.transaction.failed", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transaction submitted
      ///
      /// Locales: en, ru
      static let commonTransactionSubmitted = Rswift.StringResource(key: "common.transaction.submitted", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transfer
      ///
      /// Locales: en, ru
      static let transferTitle = Rswift.StringResource(key: "transfer.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transfer fee
      ///
      /// Locales: en, ru
      static let walletSendFeeTitle = Rswift.StringResource(key: "wallet.send.fee.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transferable
      ///
      /// Locales: en, ru
      static let walletBalanceAvailable = Rswift.StringResource(key: "wallet.balance.available", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transferable rewards
      ///
      /// Locales: en, ru
      static let stakingPayoutTitle_v2_2_0 = Rswift.StringResource(key: "staking.payout.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transferable rewards
      ///
      /// Locales: en, ru
      static let stakingSetupPayoutTitle = Rswift.StringResource(key: "staking.setup.payout.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transferable:
      ///
      /// Locales: en, ru
      static let commonTransferablePrefix = Rswift.StringResource(key: "common.transferable.prefix", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Transfers
      ///
      /// Locales: en, ru
      static let walletFiltersTransfers = Rswift.StringResource(key: "wallet.filters.transfers", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Twitter
      ///
      /// Locales: en, ru
      static let settingsTwitter = Rswift.StringResource(key: "settings.twitter", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Type
      ///
      /// Locales: en, ru
      static let stakingAnalyticsDetailsType = Rswift.StringResource(key: "staking.analytics.details.type", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Typically 12-word phrase (but may be 15, 18, 21 or 24)
      ///
      /// Locales: en, ru
      static let walletImportMnemonicHint = Rswift.StringResource(key: "wallet.import.mnemonic.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Undefined error
      ///
      /// Locales: en, ru
      static let commonUndefinedErrorTitle = Rswift.StringResource(key: "common.undefined.error.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unexpected corrupted data found. Please, contact support.
      ///
      /// Locales: en, ru
      static let commonDataCorruptionError = Rswift.StringResource(key: "common.data.corruption.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unfortunately, access to the camera is restricted.
      ///
      /// Locales: en, ru
      static let qrScanErrorCameraRestricted = Rswift.StringResource(key: "qr.scan.error.camera.restricted", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unfortunately, access to the photos is restricted.
      ///
      /// Locales: en, ru
      static let qrScanErrorGalleryRestricted = Rswift.StringResource(key: "qr.scan.error.gallery.restricted", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unfortunately, the network is unsupported. Please, try one of the following: %@.
      ///
      /// Locales: en, ru
      static let connectionAddUnsupportedError = Rswift.StringResource(key: "connection.add.unsupported.error", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unfortunately, you denied access to camera previously. Would you like to allow access now?
      ///
      /// Locales: en, ru
      static let qrScanErrorCameraRestricted_previously = Rswift.StringResource(key: "qr.scan.error.camera.restricted_previously", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unfortunately, you denied access to photos previously. Would you like to allow access now?
      ///
      /// Locales: en, ru
      static let qrScanErrorGalleryRestrictedPreviously = Rswift.StringResource(key: "qr.scan.error.gallery.restricted.previously", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unlimited
      ///
      /// Locales: en, ru
      static let stakingNetworkInfoStakingPeriodValue = Rswift.StringResource(key: "staking.network.info.staking.period.value", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unlimited series
      ///
      /// Locales: en, ru
      static let nftListItemUnlimited = Rswift.StringResource(key: "nft.list.item.unlimited", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unpaid rewards
      ///
      /// Locales: en, ru
      static let stakingPendingRewards_v2_0_0 = Rswift.StringResource(key: "staking.pending.rewards_v2_0_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unpaid rewards
      ///
      /// Locales: en, ru
      static let stakingRewardPayoutsTitle_v2_2_0 = Rswift.StringResource(key: "staking.reward.payouts.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstake
      ///
      /// Locales: en, ru
      static let stakingUnbond_v190 = Rswift.StringResource(key: "staking.unbond_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking
      ///
      /// Locales: en, ru
      static let walletBalanceUnbonding_v190 = Rswift.StringResource(key: "wallet.balance.unbonding_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking period
      ///
      /// Locales: en, ru
      static let stakingMainLockupPeriodTitle_v190 = Rswift.StringResource(key: "staking.main.lockup.period.title_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking period
      ///
      /// Locales: en, ru
      static let stakingUnbondingPeriod_v190 = Rswift.StringResource(key: "staking.unbonding.period_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking requests limit reached
      ///
      /// Locales: en, ru
      static let stakingUnbondingLimitReachedTitle = Rswift.StringResource(key: "staking.unbonding.limit.reached.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking transactions will appear here
      ///
      /// Locales: en, ru
      static let stakingUnbondingEmptyList_v190 = Rswift.StringResource(key: "staking.unbonding.empty.list_v1.9.0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking transactions will be displayed here
      ///
      /// Locales: en, ru
      static let stakingUnbondingEmptyList_v2_2_0 = Rswift.StringResource(key: "staking.unbonding.empty.list_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking:
      ///
      /// Locales: en, ru
      static let commonUnstakingPrefix = Rswift.StringResource(key: "common.unstaking.prefix", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Unstaking: %@
      ///
      /// Locales: en, ru
      static let stakingUnbondingFormat = Rswift.StringResource(key: "staking.unbonding.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Update
      ///
      /// Locales: en, ru
      static let commonUpdate = Rswift.StringResource(key: "common.update", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Update your list
      ///
      /// Locales: en, ru
      static let stakingCustomValidatorsUpdateList = Rswift.StringResource(key: "staking.custom.validators.update.list", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Upload from gallery
      ///
      /// Locales: en, ru
      static let qrScanUploadGallery = Rswift.StringResource(key: "qr.scan.upload.gallery", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Use
      ///
      /// Locales: en, ru
      static let commonUse = Rswift.StringResource(key: "common.use", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Use non digital way to backup, such as writing the sequence of mnemonic words and derivation path (if set) down on paper.
      ///
      /// Locales: en, ru
      static let exportMnemonicHint = Rswift.StringResource(key: "export.mnemonic.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Use nondigital way to back up, such as writing it down on paper.
      ///
      /// Locales: en, ru
      static let accountCreateDetails = Rswift.StringResource(key: "account.create.details", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validator
      ///
      /// Locales: en, ru
      static let stakingCommonValidator = Rswift.StringResource(key: "staking.common.validator", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validator
      ///
      /// Locales: en, ru
      static let stakingRewardDetailsValidator = Rswift.StringResource(key: "staking.reward.details.validator", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validator info
      ///
      /// Locales: en, ru
      static let stakingValidatorInfoTitle = Rswift.StringResource(key: "staking.validator.info.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validator is slashed for misbehaves (e.g. goes offline, attacks the network, or runs modified software) in the network.
      ///
      /// Locales: en, ru
      static let stakingValidatorSlashedDesc = Rswift.StringResource(key: "staking.validator.slashed.desc", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validator's own stake
      ///
      /// Locales: en, ru
      static let stakingFilterTitleOwnStake = Rswift.StringResource(key: "staking.filter.title.own.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validator's own stake (%@)
      ///
      /// Locales: en, ru
      static let stakingFilterTitleOwnStakeToken = Rswift.StringResource(key: "staking.filter.title.own.stake.token", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validators
      ///
      /// Locales: en, ru
      static let stakingRecommendedTitle = Rswift.StringResource(key: "staking.recommended.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validators are not selected
      ///
      /// Locales: en, ru
      static let stakingSetValidatorsMessage = Rswift.StringResource(key: "staking.set.validators.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validators payout the rewards every 25 days. However, you can payout them by yourself, especially if rewards are close to expiring, but you will pay the fee.
      ///
      /// Locales: en, ru
      static let stakingPendingRewardsExplanationMessage = Rswift.StringResource(key: "staking.pending.rewards.explanation.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validators who were not elected in this era.
      ///
      /// Locales: en, ru
      static let stakingYourInactiveDescription = Rswift.StringResource(key: "staking.your.inactive.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validators without enough stake to be elected
      ///
      /// Locales: en, ru
      static let stakingYourInactiveDescription_v2_2_0 = Rswift.StringResource(key: "staking.your.inactive.description_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Validators: %li of %li
      ///
      /// Locales: en, ru
      static let stakingCustomHeaderValidatorsTitle = Rswift.StringResource(key: "staking.custom.header.validators.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Vesting
      ///
      /// Locales: en, ru
      static let walletAccountLocksVesting = Rswift.StringResource(key: "wallet.account.locks.vesting", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: View in %@
      ///
      /// Locales: en, ru
      static let commmonViewInFormat = Rswift.StringResource(key: "commmon.view.in.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: View in Polkascan
      ///
      /// Locales: en, ru
      static let transactionDetailsViewPolkascan = Rswift.StringResource(key: "transaction.details.view.polkascan", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: View in Subscan
      ///
      /// Locales: en, ru
      static let transactionDetailsViewSubscan = Rswift.StringResource(key: "transaction.details.view.subscan", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Waiting for the next Era
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusWaiting = Rswift.StringResource(key: "staking.nominator.status.waiting", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallet
      ///
      /// Locales: en, ru
      static let commonWallet = Rswift.StringResource(key: "common.wallet", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallet
      ///
      /// Locales: en, ru
      static let tabbarWalletTitle = Rswift.StringResource(key: "tabbar.wallet.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallet
      ///
      /// Locales: en, ru
      static let walletChainManagementTitle = Rswift.StringResource(key: "wallet.chain.management.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallet account
      ///
      /// Locales: en, ru
      static let stakingStashTitle = Rswift.StringResource(key: "staking.stash.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallet name
      ///
      /// Locales: en, ru
      static let walletUsernameSetupChooseTitle_v2_2_0 = Rswift.StringResource(key: "wallet.username.setup.choose.title_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallet nickname
      ///
      /// Locales: en, ru
      static let walletUsernameSetupChooseTitle = Rswift.StringResource(key: "wallet.username.setup.choose.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Wallets
      ///
      /// Locales: en, ru
      static let profileWalletsTitle = Rswift.StringResource(key: "profile.wallets.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Warning
      ///
      /// Locales: en, ru
      static let commonWarning = Rswift.StringResource(key: "common.warning", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: We are going to show your mnemonic. Make sure no one can see your screen and do not take screenshots  they can be collected by third-party malware
      ///
      /// Locales: en, ru
      static let commonNoScreenshotMessage_v2_2_0 = Rswift.StringResource(key: "common.no.screenshot.message_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: We found that this account has no free tokens, are you sure that you want to change the controller?
      ///
      /// Locales: en, ru
      static let stakingControllerAccountZeroBalance = Rswift.StringResource(key: "staking.controller.account.zero.balance", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Web
      ///
      /// Locales: en, ru
      static let identityWebTitle = Rswift.StringResource(key: "identity.web.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Website
      ///
      /// Locales: en, ru
      static let aboutWebsite = Rswift.StringResource(key: "about.website", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Websites to which you allowed access to see your address when you use them
      ///
      /// Locales: en, ru
      static let dappAuthorizedInfo = Rswift.StringResource(key: "dapp.authorized.info", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Welcome to DApp portal
      ///
      /// Locales: en, ru
      static let dappDecorationTitle = Rswift.StringResource(key: "dapp.decoration.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Welcome to Nova browser
      ///
      /// Locales: en, ru
      static let dappDecorationTitle_2_4_3 = Rswift.StringResource(key: "dapp.decoration.title_2_4_3", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: What is staking?
      ///
      /// Locales: en, ru
      static let stakingStoryStakingTitle = Rswift.StringResource(key: "staking.story.staking.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Who is a nominator?
      ///
      /// Locales: en, ru
      static let stakingStoryNominatorTitle = Rswift.StringResource(key: "staking.story.nominator.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Who is a validator?
      ///
      /// Locales: en, ru
      static let stakingStoryValidatorTitle = Rswift.StringResource(key: "staking.story.validator.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Would you like to use Face ID for authentication?
      ///
      /// Locales: en, ru
      static let askFaceidMessage = Rswift.StringResource(key: "ask.faceid.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Would you like to use Touch ID for authentication?
      ///
      /// Locales: en, ru
      static let askTouchidMessage = Rswift.StringResource(key: "ask.touchid.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Write down the phrase and store it in a safe place
      ///
      /// Locales: en, ru
      static let accountBackupMnemonicTitle = Rswift.StringResource(key: "account.backup.mnemonic.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Write down your secret and store it in a safe place
      ///
      /// Locales: en, ru
      static let exportSeedTitle = Rswift.StringResource(key: "export.seed.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Write words separately with one space, no commas or other signs
      ///
      /// Locales: en, ru
      static let walletImportMnemonicSubtitle = Rswift.StringResource(key: "wallet.import.mnemonic.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Yearly
      ///
      /// Locales: en, ru
      static let stakingYearPeriodTitle = Rswift.StringResource(key: "staking.year.period.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You are about to deselect all the validators you selected earlier.
      ///
      /// Locales: en, ru
      static let stakingCustomDeselectWarning = Rswift.StringResource(key: "staking.custom.deselect.warning", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You are neither nominating nor validating
      ///
      /// Locales: en, ru
      static let stakingBondedInactive = Rswift.StringResource(key: "staking.bonded.inactive", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You can payout them by yourself, when they are close to expire, but you will pay the fee
      ///
      /// Locales: en, ru
      static let stakingPendingRewardsHintMessage = Rswift.StringResource(key: "staking.pending.rewards.hint.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You dont have account for this network, you can create or import account.
      ///
      /// Locales: en, ru
      static let accountNeededMessage = Rswift.StringResource(key: "account.needed.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You have not applied bonus
      ///
      /// Locales: en, ru
      static let crowdloanHavenotAppliedBonusTitle = Rswift.StringResource(key: "crowdloan.havenot.applied.bonus.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You need to submit agreement with Terms & Conditions on the blockchain to proceed. This is required to be done only once for all following Moonbeam contributions
      ///
      /// Locales: en, ru
      static let crowdloanMoonbeamTermsDescription = Rswift.StringResource(key: "crowdloan.moonbeam.terms.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You should add Moonbeam account to the wallet in order to participate in Moonbeam crowdloan
      ///
      /// Locales: en, ru
      static let crowdloanMoonbeamMissingAccountMessage = Rswift.StringResource(key: "crowdloan.moonbeam.missing.account.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You should have funds to pay fee and remain above minimal balance.
      ///
      /// Locales: en, ru
      static let walletFeeOverExistentialDeposit = Rswift.StringResource(key: "wallet.fee.over.existential.deposit", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You should trust your nominations to act competently and honest, basing your decision purely on their current profitability could lead to reduced profits or even loss of funds.
      ///
      /// Locales: en, ru
      static let stakingSelectValidatorsCustomDesc = Rswift.StringResource(key: "staking.select.validators.custom.desc", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: You will get increased rewards starting from next era
      ///
      /// Locales: en, ru
      static let stakingHintRewardBondMore_v2_2_0 = Rswift.StringResource(key: "staking.hint.reward.bond.more_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your %@ tokens will be returned after the leasing period.
      ///
      /// Locales: en, ru
      static let crowdloanUnlockHint = Rswift.StringResource(key: "crowdloan.unlock.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your NFTs
      ///
      /// Locales: en, ru
      static let walletListYourNftsTitle = Rswift.StringResource(key: "wallet.list.your.nfts.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your account will be removed from blockchain after this operation cause it makes total balance lower than minimal
      ///
      /// Locales: en, ru
      static let commonExistentialWarningMessage_v2_2_0 = Rswift.StringResource(key: "common.existential.warning.message_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your account will be removed from blockchain after transfer cause it makes total balance lower than minimal
      ///
      /// Locales: en, ru
      static let walletSendExistentialWarning_v2_2_0 = Rswift.StringResource(key: "wallet.send.existential.warning_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your accounts and contacts to whom you were sending transfers will appear here
      ///
      /// Locales: en, ru
      static let walletContactsEmptyTitle = Rswift.StringResource(key: "wallet.contacts.empty.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your accounts and contacts to whom you were sending transfers will appear here
      ///
      /// Locales: en, ru
      static let walletContactsEmptyTitle_v110 = Rswift.StringResource(key: "wallet.contacts.empty.title_v1.10", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your assets will appear here. Make sure the "Hide zero balances" filter is turned off
      ///
      /// Locales: en, ru
      static let walletListEmptyMessage = Rswift.StringResource(key: "wallet.list.empty.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your balance
      ///
      /// Locales: en, ru
      static let walletBalancesWidgetTitle = Rswift.StringResource(key: "wallet.balances.widget.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your contributions
      ///
      /// Locales: en, ru
      static let crowdloanYouContributionsTitle = Rswift.StringResource(key: "crowdloan.you.contributions.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your derivation path contains unsupported symbols or has incorrect structure
      ///
      /// Locales: en, ru
      static let commonInvalidDerivationPathMessage_v2_2_0 = Rswift.StringResource(key: "common.invalid.derivation.path.message_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your mnemonic is invalid. Please, try another one.
      ///
      /// Locales: en, ru
      static let accessRestorePhraseErrorMessage = Rswift.StringResource(key: "access.restore.phrase.error.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your operations will be displayed here
      ///
      /// Locales: en, ru
      static let walletEmptyDescription_v2_2_0 = Rswift.StringResource(key: "wallet.empty.description_v2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your region is not supported
      ///
      /// Locales: en, ru
      static let crowdloanMoonbeamRegionRestrictionTitle = Rswift.StringResource(key: "crowdloan.moonbeam.region.restriction.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your rewards
      ///
      /// Locales: en, ru
      static let stakingRewardWidgetTitle = Rswift.StringResource(key: "staking.reward.widget.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your rewards  will appear here
      ///
      /// Locales: en, ru
      static let stakingAnalyticsRewardsEmptyMessage = Rswift.StringResource(key: "staking.analytics.rewards.empty.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your rewards will be increased starting from the next era.
      ///
      /// Locales: en, ru
      static let stakingHintRewardBondMore = Rswift.StringResource(key: "staking.hint.reward.bond.more", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your stake
      ///
      /// Locales: en, ru
      static let stakingYourStake = Rswift.StringResource(key: "staking.your.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your stake changes will appear here
      ///
      /// Locales: en, ru
      static let stakingAnalyticsStakeEmptyMessage = Rswift.StringResource(key: "staking.analytics.stake.empty.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your stake is allocated to the following validators.
      ///
      /// Locales: en, ru
      static let stakingYourAllocatedDescription = Rswift.StringResource(key: "staking.your.allocated.description", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your stake is assigned to next validators
      ///
      /// Locales: en, ru
      static let stakingYourAllocatedDescription_2_2_0 = Rswift.StringResource(key: "staking.your.allocated.description_2_2_0", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your staked amount is less than the minimum stake to get a reward.
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusAlertLowStake = Rswift.StringResource(key: "staking.nominator.status.alert.low.stake", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your staking will start in the next era.
      ///
      /// Locales: en, ru
      static let stakingNominatorStatusAlertWaitingMessage = Rswift.StringResource(key: "staking.nominator.status.alert.waiting.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your tokens are allocated to the oversubscribed validators. You will not receive rewards in this era.
      ///
      /// Locales: en, ru
      static let stakingYourOversubscribedMessage = Rswift.StringResource(key: "staking.your.oversubscribed.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your tokens will be available to redeem after the unstaking period.
      ///
      /// Locales: en, ru
      static let stakingUnbondingHint = Rswift.StringResource(key: "staking.unbonding.hint", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your transfer will fail since the destination account does not have enough %@ to accept other token transfers
      ///
      /// Locales: en, ru
      static let walletSendDeadRecipientCommissionAssetMessage = Rswift.StringResource(key: "wallet.send.dead.recipient.commission.asset.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your transfer will fail since the final amount on the destination account will be less than the minimal balance. Please, try to increase the amount.
      ///
      /// Locales: en, ru
      static let walletSendDeadRecipientMessage = Rswift.StringResource(key: "wallet.send.dead.recipient.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your transfer will remove account from blockstore since it will make total balance lower than minimal balance.
      ///
      /// Locales: en, ru
      static let walletSendExistentialWarning = Rswift.StringResource(key: "wallet.send.existential.warning", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your validator
      ///
      /// Locales: en, ru
      static let stakingYourValidatorTitle = Rswift.StringResource(key: "staking.your.validator.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your validators
      ///
      /// Locales: en, ru
      static let stakingYourValidatorsTitle = Rswift.StringResource(key: "staking.your.validators.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Your validators will change in the next era.
      ///
      /// Locales: en, ru
      static let stakingYourValidatorsChangingTitle = Rswift.StringResource(key: "staking.your.validators.changing.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: Youtube
      ///
      /// Locales: en, ru
      static let settingsYoutube = Rswift.StringResource(key: "settings.youtube", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: ed25519 (alternative)
      ///
      /// Locales: en, ru
      static let ed25519SelectionSubtitle = Rswift.StringResource(key: "ed25519.selection.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: era #%@
      ///
      /// Locales: en, ru
      static let stakingEraTitle = Rswift.StringResource(key: "staking.era.title", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: max
      ///
      /// Locales: en, ru
      static let commonMax = Rswift.StringResource(key: "common.max", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: my accounts
      ///
      /// Locales: en, ru
      static let walletSearchAccounts = Rswift.StringResource(key: "wallet.search.accounts", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: selected %li (max %li)
      ///
      /// Locales: en, ru
      static let stakingSelectedValidatorsCount_v191 = Rswift.StringResource(key: "staking.selected.validators.count_v1.9.1", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: sr25519 (recommended)
      ///
      /// Locales: en, ru
      static let sr25519SelectionSubtitle = Rswift.StringResource(key: "sr25519.selection.subtitle", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: till %@
      ///
      /// Locales: en, ru
      static let commonTillDate = Rswift.StringResource(key: "common.till.date", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: waiting for the next era (%@)
      ///
      /// Locales: en, ru
      static let stakingWaitingNextEraFormat = Rswift.StringResource(key: "staking.waiting.next.era.format", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: with at least one identity contact
      ///
      /// Locales: en, ru
      static let stakingRecommendedHint3Addition = Rswift.StringResource(key: "staking.recommended.hint3.addition", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ DApp will be removed from Authorized
      ///
      /// Locales: en, ru
      static let dappRemoveAuthorizedMessage = Rswift.StringResource(key: "dapp.remove.authorized.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)
      /// en translation: %@ DApp will be removed from Favorites
      ///
      /// Locales: en, ru
      static let dappRemoveFavoritesMessage = Rswift.StringResource(key: "dapp.remove.favorites.message", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "ru"], comment: nil)

      /// en translation: 
      ///
      /// Locales: en, ru
      static func usernameSetupHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("username.setup.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "username.setup.hint"
        }

        return NSLocalizedString("username.setup.hint", bundle: bundle, comment: "")
      }

      /// en translation: 
      ///
      /// Locales: en, ru
      static func usernameSetupTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("username.setup.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "username.setup.title"
        }

        return NSLocalizedString("username.setup.title", bundle: bundle, comment: "")
      }

      /// en translation: #%@
      ///
      /// Locales: en, ru
      static func commonEraFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.era.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.era.format"
        }

        let format = NSLocalizedString("common.era.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: #%@ Edition of %@
      ///
      /// Locales: en, ru
      static func nftListItemLimitedFormat(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("nft.list.item.limited.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "nft.list.item.limited.format"
        }

        let format = NSLocalizedString("nft.list.item.limited.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static func commonDaysFormat(format value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.days.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.days.format"
        }

        let format = NSLocalizedString("common.days.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static func commonDaysLeftFormat(format value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.days.left.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.days.left.format"
        }

        let format = NSLocalizedString("common.days.left.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static func commonHoursFormat(format value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.hours.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.hours.format"
        }

        let format = NSLocalizedString("common.hours.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %#@format@
      ///
      /// Locales: en, ru
      static func stakingAnalyticsValidatorsErasCounter(format value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.analytics.validators.eras.counter", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.validators.eras.counter"
        }

        let format = NSLocalizedString("staking.analytics.validators.eras.counter", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ (max %@)
      ///
      /// Locales: en, ru
      static func stakingValidatorInfoNominators(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.validator.info.nominators", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.info.nominators"
        }

        let format = NSLocalizedString("staking.validator.info.nominators", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: %@ (via %@)
      ///
      /// Locales: en, ru
      static func crowdloanCustomContribFormat(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.custom.contrib.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.custom.contrib.format"
        }

        let format = NSLocalizedString("crowdloan.custom.contrib.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: %@ account
      ///
      /// Locales: en, ru
      static func accountNotFoundActionsTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("account.not.found.actions.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.not.found.actions.title"
        }

        let format = NSLocalizedString("account.not.found.actions.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ avg.
      ///
      /// Locales: en, ru
      static func stakingAnalyticsAvg(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.analytics.avg", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.avg"
        }

        let format = NSLocalizedString("staking.analytics.avg", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ left
      ///
      /// Locales: en, ru
      static func commonTimeLeftFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.time.left.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.time.left.format"
        }

        let format = NSLocalizedString("common.time.left.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ monthly
      ///
      /// Locales: en, ru
      static func stakingMonthPeriodFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.month.period.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.month.period.format"
        }

        let format = NSLocalizedString("staking.month.period.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ network
      ///
      /// Locales: en, ru
      static func stakingMainNetworkTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.main.network.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.main.network.title"
        }

        let format = NSLocalizedString("staking.main.network.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ of %@
      ///
      /// Locales: en, ru
      static func stakingRecommendedValidatorsCounter(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.recommended.validators.counter", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.validators.counter"
        }

        let format = NSLocalizedString("staking.recommended.validators.counter", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: %@ reward destination
      ///
      /// Locales: en, ru
      static func crowdloanRewardDestinationFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.reward.destination.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.reward.destination.format"
        }

        let format = NSLocalizedString("crowdloan.reward.destination.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ rewarded
      ///
      /// Locales: en, ru
      static func stakingMaxNominatorRewardedFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.max.nominator.rewarded.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.max.nominator.rewarded.format"
        }

        let format = NSLocalizedString("staking.max.nominator.rewarded.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ yearly
      ///
      /// Locales: en, ru
      static func stakingYearPeriodFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.year.period.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.year.period.format"
        }

        let format = NSLocalizedString("staking.year.period.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@'s crowdloan website
      ///
      /// Locales: en, ru
      static func crowdloanLearn_v2_2_0(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.learn_v2_2_0", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.learn_v2_2_0"
        }

        let format = NSLocalizedString("crowdloan.learn_v2_2_0", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %li of %li eras
      ///
      /// Locales: en, ru
      static func stakingAnalyticsEraRange(_ value1: Int, _ value2: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.analytics.era.range", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.era.range"
        }

        let format = NSLocalizedString("staking.analytics.era.range", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: (BTC/ETH compatible)
      ///
      /// Locales: en, ru
      static func ecdsaSelectionSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ecdsa.selection.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ecdsa.selection.subtitle"
        }

        return NSLocalizedString("ecdsa.selection.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: 12, 15, 18, 21 or 24-word phrase
      ///
      /// Locales: en, ru
      static func secretTypeMnemonicSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.mnemonic.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.mnemonic.subtitle"
        }

        return NSLocalizedString("secret.type.mnemonic.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: 128 hex symbols
      ///
      /// Locales: en, ru
      static func accountImportEthereumSeedPlaceholder_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.ethereum.seed.placeholder_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.ethereum.seed.placeholder_v2_2_0"
        }

        return NSLocalizedString("account.import.ethereum.seed.placeholder_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: 1y
      ///
      /// Locales: en, ru
      static func stakingAnalyticsPeriod1y(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.period.1y", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.period.1y"
        }

        return NSLocalizedString("staking.analytics.period.1y", bundle: bundle, comment: "")
      }

      /// en translation: 30d
      ///
      /// Locales: en, ru
      static func stakingAnalyticsPeriod30d(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.period.30d", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.period.30d"
        }

        return NSLocalizedString("staking.analytics.period.30d", bundle: bundle, comment: "")
      }

      /// en translation: 64 hex symbols
      ///
      /// Locales: en, ru
      static func accountImportSubstrateSeedPlaceholder_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.substrate.seed.placeholder_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.substrate.seed.placeholder_v2_2_0"
        }

        return NSLocalizedString("account.import.substrate.seed.placeholder_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: 7 days rewards
      ///
      /// Locales: en, ru
      static func stakingAnalytics7daysRewards(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.7days.rewards", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.7days.rewards"
        }

        return NSLocalizedString("staking.analytics.7days.rewards", bundle: bundle, comment: "")
      }

      /// en translation: 7d
      ///
      /// Locales: en, ru
      static func stakingAnalyticsPeriod7d(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.period.7d", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.period.7d"
        }

        return NSLocalizedString("staking.analytics.period.7d", bundle: bundle, comment: "")
      }

      /// en translation: About
      ///
      /// Locales: en, ru
      static func aboutTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.title"
        }

        return NSLocalizedString("about.title", bundle: bundle, comment: "")
      }

      /// en translation: About
      ///
      /// Locales: en, ru
      static func profileAboutTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("profile.about.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "profile.about.title"
        }

        return NSLocalizedString("profile.about.title", bundle: bundle, comment: "")
      }

      /// en translation: About crowdloans
      ///
      /// Locales: en, ru
      static func crowdloanAboutCrowdloans(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.about.crowdloans", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.about.crowdloans"
        }

        return NSLocalizedString("crowdloan.about.crowdloans", bundle: bundle, comment: "")
      }

      /// en translation: About rewards
      ///
      /// Locales: en, ru
      static func stakingAboutRewards(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.about.rewards", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.about.rewards"
        }

        return NSLocalizedString("staking.about.rewards", bundle: bundle, comment: "")
      }

      /// en translation: About staking
      ///
      /// Locales: en, ru
      static func stakingNetworkInfoTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.network.info.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.network.info.title"
        }

        return NSLocalizedString("staking.network.info.title", bundle: bundle, comment: "")
      }

      /// en translation: Account
      ///
      /// Locales: en, ru
      static func accountInfoTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.info.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.info.title"
        }

        return NSLocalizedString("account.info.title", bundle: bundle, comment: "")
      }

      /// en translation: Account
      ///
      /// Locales: en, ru
      static func commonAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.account"
        }

        return NSLocalizedString("common.account", bundle: bundle, comment: "")
      }

      /// en translation: Account address
      ///
      /// Locales: en, ru
      static func commonAccountAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.account.address", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.account.address"
        }

        return NSLocalizedString("common.account.address", bundle: bundle, comment: "")
      }

      /// en translation: Account address or account name
      ///
      /// Locales: en, ru
      static func walletContactsSearchPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.contacts.search.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.contacts.search.placeholder"
        }

        return NSLocalizedString("wallet.contacts.search.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Account already exists. Please, try another one.
      ///
      /// Locales: en, ru
      static func accountAddAlreadyExistsMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.add.already.exists.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.add.already.exists.message"
        }

        return NSLocalizedString("account.add.already.exists.message", bundle: bundle, comment: "")
      }

      /// en translation: Account is not found
      ///
      /// Locales: en, ru
      static func accountNotFoundCaption(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.not.found.caption", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.not.found.caption"
        }

        return NSLocalizedString("account.not.found.caption", bundle: bundle, comment: "")
      }

      /// en translation: Account needed
      ///
      /// Locales: en, ru
      static func accountNeededTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.needed.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.needed.title"
        }

        return NSLocalizedString("account.needed.title", bundle: bundle, comment: "")
      }

      /// en translation: Accounts
      ///
      /// Locales: en, ru
      static func profileAccountsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("profile.accounts.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "profile.accounts.title"
        }

        return NSLocalizedString("profile.accounts.title", bundle: bundle, comment: "")
      }

      /// en translation: Accounts with custom secret
      ///
      /// Locales: en, ru
      static func chainAccountsSectionTitleCustomSecret(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("chain.accounts.section.title.custom.secret", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "chain.accounts.section.title.custom.secret"
        }

        return NSLocalizedString("chain.accounts.section.title.custom.secret", bundle: bundle, comment: "")
      }

      /// en translation: Accounts with shared secret
      ///
      /// Locales: en, ru
      static func chainAccountsSectionTitleSharedSecret(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("chain.accounts.section.title.shared.secret", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "chain.accounts.section.title.shared.secret"
        }

        return NSLocalizedString("chain.accounts.section.title.shared.secret", bundle: bundle, comment: "")
      }

      /// en translation: Active
      ///
      /// Locales: en, ru
      static func crowdloanActiveSection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.active.section", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.active.section"
        }

        return NSLocalizedString("crowdloan.active.section", bundle: bundle, comment: "")
      }

      /// en translation: Active
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusActive(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.active", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.active"
        }

        return NSLocalizedString("staking.nominator.status.active", bundle: bundle, comment: "")
      }

      /// en translation: Active crowdloans  will appear here
      ///
      /// Locales: en, ru
      static func crowdloanPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.placeholder"
        }

        return NSLocalizedString("crowdloan.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Active nominators
      ///
      /// Locales: en, ru
      static func stakingMainActiveNominatorsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.main.active.nominators.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.main.active.nominators.title"
        }

        return NSLocalizedString("staking.main.active.nominators.title", bundle: bundle, comment: "")
      }

      /// en translation: Active status
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusAlertActiveTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.alert.active.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.alert.active.title"
        }

        return NSLocalizedString("staking.nominator.status.alert.active.title", bundle: bundle, comment: "")
      }

      /// en translation: Active validators without your stake assignment
      ///
      /// Locales: en, ru
      static func stakingYourNotAllocatedDescription_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.not.allocated.description_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.not.allocated.description_v2_2_0"
        }

        return NSLocalizedString("staking.your.not.allocated.description_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Activity
      ///
      /// Locales: en, ru
      static func stakingAnalyticsActivity(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.activity", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.activity"
        }

        return NSLocalizedString("staking.analytics.activity", bundle: bundle, comment: "")
      }

      /// en translation: Add
      ///
      /// Locales: en, ru
      static func commonAdd(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.add", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.add"
        }

        return NSLocalizedString("common.add", bundle: bundle, comment: "")
      }

      /// en translation: Add account
      ///
      /// Locales: en, ru
      static func accountsAddAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("accounts.add.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "accounts.add.account"
        }

        return NSLocalizedString("accounts.add.account", bundle: bundle, comment: "")
      }

      /// en translation: Add connection
      ///
      /// Locales: en, ru
      static func connectionsAddConnection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connections.add.connection", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connections.add.connection"
        }

        return NSLocalizedString("connections.add.connection", bundle: bundle, comment: "")
      }

      /// en translation: Add controller account %@ to the application to perform this action.
      ///
      /// Locales: en, ru
      static func stakingAddController(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.add.controller", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.add.controller"
        }

        let format = NSLocalizedString("staking.add.controller", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Add to favorites
      ///
      /// Locales: en, ru
      static func dappFavoriteAddTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.favorite.add.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.favorite.add.title"
        }

        return NSLocalizedString("dapp.favorite.add.title", bundle: bundle, comment: "")
      }

      /// en translation: Add wallet
      ///
      /// Locales: en, ru
      static func walletAddButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.add.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.add.button.title"
        }

        return NSLocalizedString("wallet.add.button.title", bundle: bundle, comment: "")
      }

      /// en translation: Address
      ///
      /// Locales: en, ru
      static func commonAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.address", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.address"
        }

        return NSLocalizedString("common.address", bundle: bundle, comment: "")
      }

      /// en translation: Address format is invalid. Make sure that address belongs to the right network
      ///
      /// Locales: en, ru
      static func walletSearchEmptyTitle_v1100(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.search.empty.title_v1.10.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.search.empty.title_v1.10.0"
        }

        return NSLocalizedString("wallet.search.empty.title_v1.10.0", bundle: bundle, comment: "")
      }

      /// en translation: Address in transaction (%@) doesn't match the address in the wallet (%@)
      ///
      /// Locales: en, ru
      static func dappConfirmationAddressMismatch(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("dapp.confirmation.address.mismatch", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.confirmation.address.mismatch"
        }

        let format = NSLocalizedString("dapp.confirmation.address.mismatch", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Advanced
      ///
      /// Locales: en, ru
      static func commonAdvanced(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.advanced", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.advanced"
        }

        return NSLocalizedString("common.advanced", bundle: bundle, comment: "")
      }

      /// en translation: After unstaking period don't forget to redeem your tokens
      ///
      /// Locales: en, ru
      static func stakingHintRedeem_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.redeem_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.redeem_v2_2_0"
        }

        return NSLocalizedString("staking.hint.redeem_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: After unstaking period you will need to redeem your tokens.
      ///
      /// Locales: en, ru
      static func stakingHintRedeem(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.redeem", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.redeem"
        }

        return NSLocalizedString("staking.hint.redeem", bundle: bundle, comment: "")
      }

      /// en translation: Agree with Terms and Conditions
      ///
      /// Locales: en, ru
      static func karuraTermsAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("karura.terms.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "karura.terms.action"
        }

        return NSLocalizedString("karura.terms.action", bundle: bundle, comment: "")
      }

      /// en translation: Alerts
      ///
      /// Locales: en, ru
      static func stakingAlertsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.alerts.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.alerts.title"
        }

        return NSLocalizedString("staking.alerts.title", bundle: bundle, comment: "")
      }

      /// en translation: All
      ///
      /// Locales: en, ru
      static func commonAll(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.all", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.all"
        }

        return NSLocalizedString("common.all", bundle: bundle, comment: "")
      }

      /// en translation: All
      ///
      /// Locales: en, ru
      static func stakingAnalyticsPeriodAll(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.period.all", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.period.all"
        }

        return NSLocalizedString("staking.analytics.period.all", bundle: bundle, comment: "")
      }

      /// en translation: All unstaking
      ///
      /// Locales: en, ru
      static func stakingRebondActionAll(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond.action.all", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond.action.all"
        }

        return NSLocalizedString("staking.rebond.action.all", bundle: bundle, comment: "")
      }

      /// en translation: Allocation with current validators
      ///
      /// Locales: en, ru
      static func stakingAnalyticsStakeAllocation(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.stake.allocation", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.stake.allocation"
        }

        return NSLocalizedString("staking.analytics.stake.allocation", bundle: bundle, comment: "")
      }

      /// en translation: Allow
      ///
      /// Locales: en, ru
      static func commonAllow(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.allow", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.allow"
        }

        return NSLocalizedString("common.allow", bundle: bundle, comment: "")
      }

      /// en translation: Allow %@ to access your account addresses?
      ///
      /// Locales: en, ru
      static func dappAuthTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("dapp.auth.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.auth.title"
        }

        let format = NSLocalizedString("dapp.auth.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Already have a wallet
      ///
      /// Locales: en, ru
      static func onboardingRestoreWallet(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.restore.wallet", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.restore.wallet"
        }

        return NSLocalizedString("onboarding.restore.wallet", bundle: bundle, comment: "")
      }

      /// en translation: Already have an account
      ///
      /// Locales: en, ru
      static func onboardingRestoreChainAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.restore.chain.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.restore.chain.account"
        }

        return NSLocalizedString("onboarding.restore.chain.account", bundle: bundle, comment: "")
      }

      /// en translation: Although rewards are usually distributed by validators, Nova Wallet helps by alerting if there are any unpaid rewards that are close to expiring. You will receive alerts about this and other activities on the staking screen.
      ///
      /// Locales: en, ru
      static func stakingStoryRewardPage2(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.reward.page.2", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.reward.page.2"
        }

        return NSLocalizedString("staking.story.reward.page.2", bundle: bundle, comment: "")
      }

      /// en translation: Amount
      ///
      /// Locales: en, ru
      static func walletSendAmountTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.amount.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.amount.title"
        }

        return NSLocalizedString("wallet.send.amount.title", bundle: bundle, comment: "")
      }

      /// en translation: Amount is too low
      ///
      /// Locales: en, ru
      static func amountTooLow(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("amount.too.low", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "amount.too.low"
        }

        return NSLocalizedString("amount.too.low", bundle: bundle, comment: "")
      }

      /// en translation: Amount is too low
      ///
      /// Locales: en, ru
      static func walletSendDeadRecipientTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.dead.recipient.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.dead.recipient.title"
        }

        return NSLocalizedString("wallet.send.dead.recipient.title", bundle: bundle, comment: "")
      }

      /// en translation: Amount you want to return to stake is greater than unstaking balance
      ///
      /// Locales: en, ru
      static func stakingRebondInsufficientBondings(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond.insufficient.bondings", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond.insufficient.bondings"
        }

        return NSLocalizedString("staking.rebond.insufficient.bondings", bundle: bundle, comment: "")
      }

      /// en translation: Analytics
      ///
      /// Locales: en, ru
      static func stakingAnalyticsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.title"
        }

        return NSLocalizedString("staking.analytics.title", bundle: bundle, comment: "")
      }

      /// en translation: App version
      ///
      /// Locales: en, ru
      static func aboutVersion(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.version", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.version"
        }

        return NSLocalizedString("about.version", bundle: bundle, comment: "")
      }

      /// en translation: Applied
      ///
      /// Locales: en, ru
      static func commonApplied(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.applied", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.applied"
        }

        return NSLocalizedString("common.applied", bundle: bundle, comment: "")
      }

      /// en translation: Apply
      ///
      /// Locales: en, ru
      static func commonApply(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.apply", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.apply"
        }

        return NSLocalizedString("common.apply", bundle: bundle, comment: "")
      }

      /// en translation: Apply bonus
      ///
      /// Locales: en, ru
      static func crowdloanHavenotAppliedBonusApply(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.havenot.applied.bonus.apply", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.havenot.applied.bonus.apply"
        }

        return NSLocalizedString("crowdloan.havenot.applied.bonus.apply", bundle: bundle, comment: "")
      }

      /// en translation: Approve this request if you trust the application
      ///
      /// Locales: en, ru
      static func dappAuthSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.auth.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.auth.subtitle"
        }

        return NSLocalizedString("dapp.auth.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Approve this request if you trust the application. Check the transaction details.
      ///
      /// Locales: en, ru
      static func dappConfirmSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.confirm.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.confirm.subtitle"
        }

        return NSLocalizedString("dapp.confirm.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Are you sure you want to cancel this operation?
      ///
      /// Locales: en, ru
      static func commonCancelOperationMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.cancel.operation.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.cancel.operation.message"
        }

        return NSLocalizedString("common.cancel.operation.message", bundle: bundle, comment: "")
      }

      /// en translation: Are you sure you want to close this screen? Your changes will not be applied.
      ///
      /// Locales: en, ru
      static func dappBrowserCloseConfirmation(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.browser.close.confirmation", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.browser.close.confirmation"
        }

        return NSLocalizedString("dapp.browser.close.confirmation", bundle: bundle, comment: "")
      }

      /// en translation: Are you sure?
      ///
      /// Locales: en, ru
      static func commonConfirmationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.confirmation.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.confirmation.title"
        }

        return NSLocalizedString("common.confirmation.title", bundle: bundle, comment: "")
      }

      /// en translation: Asset
      ///
      /// Locales: en, ru
      static func walletSendAssetTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.asset.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.asset.title"
        }

        return NSLocalizedString("wallet.send.asset.title", bundle: bundle, comment: "")
      }

      /// en translation: Assets
      ///
      /// Locales: en, ru
      static func tabbarAssetsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.assets.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.assets.title"
        }

        return NSLocalizedString("tabbar.assets.title", bundle: bundle, comment: "")
      }

      /// en translation: Assets value
      ///
      /// Locales: en, ru
      static func walletAssetsTotalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.assets.total.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.assets.total.title"
        }

        return NSLocalizedString("wallet.assets.total.title", bundle: bundle, comment: "")
      }

      /// en translation: Astar referral code should be a valid Polkadot address
      ///
      /// Locales: en, ru
      static func crowdloanAstarInvalidReferralMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.astar.invalid.referral.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.astar.invalid.referral.message"
        }

        return NSLocalizedString("crowdloan.astar.invalid.referral.message", bundle: bundle, comment: "")
      }

      /// en translation: Attention!
      ///
      /// Locales: en, ru
      static func commonNoScreenshotTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.no.screenshot.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.no.screenshot.title_v2_2_0"
        }

        return NSLocalizedString("common.no.screenshot.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Authenticate to access the account
      ///
      /// Locales: en, ru
      static func askBiometryReason(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ask.biometry.reason", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ask.biometry.reason"
        }

        return NSLocalizedString("ask.biometry.reason", bundle: bundle, comment: "")
      }

      /// en translation: Authorized websites
      ///
      /// Locales: en, ru
      static func dappAuthorizedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.authorized.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.authorized.title"
        }

        return NSLocalizedString("dapp.authorized.title", bundle: bundle, comment: "")
      }

      /// en translation: Available balance
      ///
      /// Locales: en, ru
      static func walletSendAvailableBalance(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.available.balance", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.available.balance"
        }

        return NSLocalizedString("wallet.send.available.balance", bundle: bundle, comment: "")
      }

      /// en translation: Available: %@
      ///
      /// Locales: en, ru
      static func commonAvailableFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.available.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.available.format"
        }

        let format = NSLocalizedString("common.available.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Average APY
      ///
      /// Locales: en, ru
      static func stakingRewardInfoAvg(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.info.avg", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.info.avg"
        }

        return NSLocalizedString("staking.reward.info.avg", bundle: bundle, comment: "")
      }

      /// en translation: Awesome! You have no unpaid rewards
      ///
      /// Locales: en, ru
      static func stakingRewardPayoutsEmptyRewards_2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.payouts.empty.rewards_2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.payouts.empty.rewards_2_2_0"
        }

        return NSLocalizedString("staking.reward.payouts.empty.rewards_2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Back to operation
      ///
      /// Locales: en, ru
      static func commonKeepEditingAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.keep.editing.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.keep.editing.action"
        }

        return NSLocalizedString("common.keep.editing.action", bundle: bundle, comment: "")
      }

      /// en translation: Backup mnemonic
      ///
      /// Locales: en, ru
      static func accountCreateTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.create.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.create.title"
        }

        return NSLocalizedString("account.create.title", bundle: bundle, comment: "")
      }

      /// en translation: Balance
      ///
      /// Locales: en, ru
      static func commonBalance(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.balance", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.balance"
        }

        return NSLocalizedString("common.balance", bundle: bundle, comment: "")
      }

      /// en translation: Balance
      ///
      /// Locales: en, ru
      static func stakingBalanceTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.balance.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.balance.title_v2_2_0"
        }

        return NSLocalizedString("staking.balance.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Balance details
      ///
      /// Locales: en, ru
      static func walletSendBalanceDetails(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.balance.details", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.balance.details"
        }

        return NSLocalizedString("wallet.send.balance.details", bundle: bundle, comment: "")
      }

      /// en translation: Be careful
      ///
      /// Locales: en, ru
      static func accountExportWarningTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.export.warning.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.export.warning.title"
        }

        return NSLocalizedString("account.export.warning.title", bundle: bundle, comment: "")
      }

      /// en translation: Bonded: %@
      ///
      /// Locales: en, ru
      static func stakingBondedFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.bonded.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.bonded.format"
        }

        let format = NSLocalizedString("staking.bonded.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Bonus
      ///
      /// Locales: en, ru
      static func commonBonus(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.bonus", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.bonus"
        }

        return NSLocalizedString("common.bonus", bundle: bundle, comment: "")
      }

      /// en translation: Bonus signature verification failed. Please, try again later.
      ///
      /// Locales: en, ru
      static func crowdloanBonusVerificationError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.bonus.verification.error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.bonus.verification.error"
        }

        return NSLocalizedString("crowdloan.bonus.verification.error", bundle: bundle, comment: "")
      }

      /// en translation: Browse the web using  your accounts from Nova Wallet
      ///
      /// Locales: en, ru
      static func dappsDecorationSubtitle_2_4_3(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapps.decoration.subtitle_2_4_3", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapps.decoration.subtitle_2_4_3"
        }

        return NSLocalizedString("dapps.decoration.subtitle_2_4_3", bundle: bundle, comment: "")
      }

      /// en translation: Browser
      ///
      /// Locales: en, ru
      static func tabbarDappsTitle_2_4_3(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.dapps.title_2_4_3", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.dapps.title_2_4_3"
        }

        return NSLocalizedString("tabbar.dapps.title_2_4_3", bundle: bundle, comment: "")
      }

      /// en translation: Buy
      ///
      /// Locales: en, ru
      static func walletAssetBuy(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.asset.buy", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.asset.buy"
        }

        return NSLocalizedString("wallet.asset.buy", bundle: bundle, comment: "")
      }

      /// en translation: Buy with
      ///
      /// Locales: en, ru
      static func walletAssetBuyWith(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.asset.buy.with", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.asset.buy.with"
        }

        return NSLocalizedString("wallet.asset.buy.with", bundle: bundle, comment: "")
      }

      /// en translation: By continuing, you agree to our  Terms and Conditions and Privacy Policy
      ///
      /// Locales: en, ru
      static func onboardingTermsAndConditions1_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.terms.and.conditions.1_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.terms.and.conditions.1_v2_2_0"
        }

        return NSLocalizedString("onboarding.terms.and.conditions.1_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Call
      ///
      /// Locales: en, ru
      static func commonCall(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.call", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.call"
        }

        return NSLocalizedString("common.call", bundle: bundle, comment: "")
      }

      /// en translation: Camera Access
      ///
      /// Locales: en, ru
      static func qrScanErrorCameraTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.camera.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.camera.title"
        }

        return NSLocalizedString("qr.scan.error.camera.title", bundle: bundle, comment: "")
      }

      /// en translation: Camera is used to capture QR code
      ///
      /// Locales: en, ru
      static func nsCameraUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSCameraUsageDescription", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "NSCameraUsageDescription"
        }

        return NSLocalizedString("NSCameraUsageDescription", bundle: bundle, comment: "")
      }

      /// en translation: Can't establish connection with node. Please, try another one.
      ///
      /// Locales: en, ru
      static func connectionAddInvalidError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.add.invalid.error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.add.invalid.error"
        }

        return NSLocalizedString("connection.add.invalid.error", bundle: bundle, comment: "")
      }

      /// en translation: Can't extract recipient address
      ///
      /// Locales: en, ru
      static func recepientScanError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("recepient.scan.error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "recepient.scan.error"
        }

        return NSLocalizedString("recepient.scan.error", bundle: bundle, comment: "")
      }

      /// en translation: Can't process selected image
      ///
      /// Locales: en, ru
      static func qrScanErrorInvalidImage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.invalid.image", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.invalid.image"
        }

        return NSLocalizedString("qr.scan.error.invalid.image", bundle: bundle, comment: "")
      }

      /// en translation: Can't stake less than minimal value (%@)
      ///
      /// Locales: en, ru
      static func stakingSetupAmountTooLow(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.setup.amount.too.low", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.amount.too.low"
        }

        let format = NSLocalizedString("staking.setup.amount.too.low", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Cancel
      ///
      /// Locales: en, ru
      static func commonCancel(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.cancel", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.cancel"
        }

        return NSLocalizedString("common.cancel", bundle: bundle, comment: "")
      }

      /// en translation: Cancel operation
      ///
      /// Locales: en, ru
      static func commonCancelOperationAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.cancel.operation.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.cancel.operation.action"
        }

        return NSLocalizedString("common.cancel.operation.action", bundle: bundle, comment: "")
      }

      /// en translation: Cannot contribute chosen amount since resulting raised amount will exceed crowdloan cap. Maximum allowed contribution is %@.
      ///
      /// Locales: en, ru
      static func crowdloanCapReachedAmountMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.cap.reached.amount.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.cap.reached.amount.message"
        }

        let format = NSLocalizedString("crowdloan.cap.reached.amount.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Cannot contribute to selected crowdloan  since its cap is already reached.
      ///
      /// Locales: en, ru
      static func crowdloanCapReachedRaisedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.cap.reached.raised.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.cap.reached.raised.message"
        }

        return NSLocalizedString("crowdloan.cap.reached.raised.message", bundle: bundle, comment: "")
      }

      /// en translation: Cannot contribute to selected crowdloan since it is already ended.
      ///
      /// Locales: en, ru
      static func crowdloanEndedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.ended.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.ended.message"
        }

        return NSLocalizedString("crowdloan.ended.message", bundle: bundle, comment: "")
      }

      /// en translation: Cannot import account with Ethereum secret into the network with Substrate encryption
      ///
      /// Locales: en, ru
      static func importJsonUnsupportedSubstrateCryptoMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.json.unsupported.substrate.crypto.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.json.unsupported.substrate.crypto.message"
        }

        return NSLocalizedString("import.json.unsupported.substrate.crypto.message", bundle: bundle, comment: "")
      }

      /// en translation: Cannot import account with Substrate secret into the network with Ethereum encryption
      ///
      /// Locales: en, ru
      static func importJsonUnsupportedEthereumCryptoMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.json.unsupported.ethereum.crypto.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.json.unsupported.ethereum.crypto.message"
        }

        return NSLocalizedString("import.json.unsupported.ethereum.crypto.message", bundle: bundle, comment: "")
      }

      /// en translation: Cannot start staking
      ///
      /// Locales: en, ru
      static func stakingMaxNominatorsReachedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.max.nominators.reached.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.max.nominators.reached.title"
        }

        return NSLocalizedString("staking.max.nominators.reached.title", bundle: bundle, comment: "")
      }

      /// en translation: Change
      ///
      /// Locales: en, ru
      static func commonChange(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.change", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.change"
        }

        return NSLocalizedString("common.change", bundle: bundle, comment: "")
      }

      /// en translation: Change %@ account
      ///
      /// Locales: en, ru
      static func accountActionsChangeSheetTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("account.actions.change.sheet.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.actions.change.sheet.title"
        }

        let format = NSLocalizedString("account.actions.change.sheet.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Change PIN code
      ///
      /// Locales: en, ru
      static func profilePincodeChangeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("profile.pincode.change.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "profile.pincode.change.title"
        }

        return NSLocalizedString("profile.pincode.change.title", bundle: bundle, comment: "")
      }

      /// en translation: Change account
      ///
      /// Locales: en, ru
      static func accountActionsChangeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.actions.change.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.actions.change.title"
        }

        return NSLocalizedString("account.actions.change.title", bundle: bundle, comment: "")
      }

      /// en translation: Change controller
      ///
      /// Locales: en, ru
      static func stakingControllerConfirmTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.confirm.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.confirm.title"
        }

        return NSLocalizedString("staking.controller.confirm.title", bundle: bundle, comment: "")
      }

      /// en translation: Change password
      ///
      /// Locales: en, ru
      static func commonChangePassword(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.change.password", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.change.password"
        }

        return NSLocalizedString("common.change.password", bundle: bundle, comment: "")
      }

      /// en translation: Change validators
      ///
      /// Locales: en, ru
      static func stakingChangeValidators(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.change.validators", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.change.validators"
        }

        return NSLocalizedString("staking.change.validators", bundle: bundle, comment: "")
      }

      /// en translation: Change your validators.
      ///
      /// Locales: en, ru
      static func stakingChangeYourValidators(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.change.your.validators", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.change.your.validators"
        }

        return NSLocalizedString("staking.change.your.validators", bundle: bundle, comment: "")
      }

      /// en translation: Changed
      ///
      /// Locales: en, ru
      static func commonChanged(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.changed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.changed"
        }

        return NSLocalizedString("common.changed", bundle: bundle, comment: "")
      }

      /// en translation: Choose action
      ///
      /// Locales: en, ru
      static func commonChooseAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.choose.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.choose.action"
        }

        return NSLocalizedString("common.choose.action", bundle: bundle, comment: "")
      }

      /// en translation: Choose custom validators 
      ///
      /// Locales: en, ru
      static func stakingRecommendedCustomTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.custom.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.custom.title"
        }

        return NSLocalizedString("staking.recommended.custom.title", bundle: bundle, comment: "")
      }

      /// en translation: Choose network
      ///
      /// Locales: en, ru
      static func commonChooseNetwork(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.choose.network", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.choose.network"
        }

        return NSLocalizedString("common.choose.network", bundle: bundle, comment: "")
      }

      /// en translation: Choose parachains to contribute your %@. You'll get back your contributed tokens, and if parachain wins a slot, you'll receive rewards after the end of the auction
      ///
      /// Locales: en, ru
      static func crowdloanListSectionFormat_v2_2_0(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.list.section.format_v2_2_0", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.list.section.format_v2_2_0"
        }

        let format = NSLocalizedString("crowdloan.list.section.format_v2_2_0", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Choose words in the right order
      ///
      /// Locales: en, ru
      static func accountConfirmationDetails(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.confirmation.details", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.confirmation.details"
        }

        return NSLocalizedString("account.confirmation.details", bundle: bundle, comment: "")
      }

      /// en translation: Choose your validators carefully, as they should act proficiently and honest. Basing your decision purely on the profitability could lead to reduced rewards or even loss of stake
      ///
      /// Locales: en, ru
      static func stakingSelectValidatorsCustomDesc_2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.select.validators.custom.desc_2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.select.validators.custom.desc_2_2_0"
        }

        return NSLocalizedString("staking.select.validators.custom.desc_2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Clear filters
      ///
      /// Locales: en, ru
      static func stakingCustomClearButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.clear.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.clear.button.title"
        }

        return NSLocalizedString("staking.custom.clear.button.title", bundle: bundle, comment: "")
      }

      /// en translation: Close
      ///
      /// Locales: en, ru
      static func commonClose(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.close", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.close"
        }

        return NSLocalizedString("common.close", bundle: bundle, comment: "")
      }

      /// en translation: Collection
      ///
      /// Locales: en, ru
      static func nftCollectionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("nft.collection.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "nft.collection.title"
        }

        return NSLocalizedString("nft.collection.title", bundle: bundle, comment: "")
      }

      /// en translation: Community
      ///
      /// Locales: en, ru
      static func settingsCommunity(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.community", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.community"
        }

        return NSLocalizedString("settings.community", bundle: bundle, comment: "")
      }

      /// en translation: Completed
      ///
      /// Locales: en, ru
      static func crowdloanCompletedSection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.completed.section", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.completed.section"
        }

        return NSLocalizedString("crowdloan.completed.section", bundle: bundle, comment: "")
      }

      /// en translation: Completed
      ///
      /// Locales: en, ru
      static func transactionStatusCompleted(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.status.completed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.status.completed"
        }

        return NSLocalizedString("transaction.status.completed", bundle: bundle, comment: "")
      }

      /// en translation: Confirm
      ///
      /// Locales: en, ru
      static func commonConfirm(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.confirm", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.confirm"
        }

        return NSLocalizedString("common.confirm", bundle: bundle, comment: "")
      }

      /// en translation: Confirm %@ deletion.
      ///
      /// Locales: en, ru
      static func connectionDeleteDescription(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("connection.delete.description", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.delete.description"
        }

        let format = NSLocalizedString("connection.delete.description", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Confirm mnemonic
      ///
      /// Locales: en, ru
      static func accountConfirmationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.confirmation.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.confirmation.title"
        }

        return NSLocalizedString("account.confirmation.title", bundle: bundle, comment: "")
      }

      /// en translation: Confirm password
      ///
      /// Locales: en, ru
      static func commonConfirmPassword(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.confirm.password", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.confirm.password"
        }

        return NSLocalizedString("common.confirm.password", bundle: bundle, comment: "")
      }

      /// en translation: Confirm password...
      ///
      /// Locales: en, ru
      static func exportPasswordProceedConfirmTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.password.proceed.confirm.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.password.proceed.confirm.title"
        }

        return NSLocalizedString("export.password.proceed.confirm.title", bundle: bundle, comment: "")
      }

      /// en translation: Confirm transfer
      ///
      /// Locales: en, ru
      static func walletSendConfirmTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.confirm.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.confirm.title"
        }

        return NSLocalizedString("wallet.send.confirm.title", bundle: bundle, comment: "")
      }

      /// en translation: Confirm your pin code
      ///
      /// Locales: en, ru
      static func pincodeConfirmYourPinCode(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("pincode.confirm.your.pin.code", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "pincode.confirm.your.pin.code"
        }

        return NSLocalizedString("pincode.confirm.your.pin.code", bundle: bundle, comment: "")
      }

      /// en translation: Confirmation
      ///
      /// Locales: en, ru
      static func commonConfirmTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.confirm.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.confirm.title"
        }

        return NSLocalizedString("common.confirm.title", bundle: bundle, comment: "")
      }

      /// en translation: Confirmed
      ///
      /// Locales: en, ru
      static func commonConfirmed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.confirmed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.confirmed"
        }

        return NSLocalizedString("common.confirmed", bundle: bundle, comment: "")
      }

      /// en translation: Connect to the Polkadot & Kusama ecosystem web applications using accounts in Nova Wallet
      ///
      /// Locales: en, ru
      static func dappsDecorationSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapps.decoration.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapps.decoration.subtitle"
        }

        return NSLocalizedString("dapps.decoration.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Connected
      ///
      /// Locales: en, ru
      static func networkStatusConnected(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("network.status.connected", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "network.status.connected"
        }

        return NSLocalizedString("network.status.connected", bundle: bundle, comment: "")
      }

      /// en translation: Connecting
      ///
      /// Locales: en, ru
      static func networkStatusConnecting(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("network.status.connecting", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "network.status.connecting"
        }

        return NSLocalizedString("network.status.connecting", bundle: bundle, comment: "")
      }

      /// en translation: Connection Failed
      ///
      /// Locales: en, ru
      static func connectionErrorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.error.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.error.title"
        }

        return NSLocalizedString("connection.error.title", bundle: bundle, comment: "")
      }

      /// en translation: Contact Us
      ///
      /// Locales: en, ru
      static func aboutContactUs(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.contact.us", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.contact.us"
        }

        return NSLocalizedString("about.contact.us", bundle: bundle, comment: "")
      }

      /// en translation: Contacts
      ///
      /// Locales: en, ru
      static func walletSearchContacts(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.search.contacts", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.search.contacts"
        }

        return NSLocalizedString("wallet.search.contacts", bundle: bundle, comment: "")
      }

      /// en translation: Continue
      ///
      /// Locales: en, ru
      static func commonContinue(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.continue", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.continue"
        }

        return NSLocalizedString("common.continue", bundle: bundle, comment: "")
      }

      /// en translation: Contribute to crowdloan
      ///
      /// Locales: en, ru
      static func crowdloanContributeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.contribute.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.contribute.title"
        }

        return NSLocalizedString("crowdloan.contribute.title", bundle: bundle, comment: "")
      }

      /// en translation: Contribution amount is too small
      ///
      /// Locales: en, ru
      static func crowdloanTooSmallContributionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.too.small.contribution.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.too.small.contribution.title"
        }

        return NSLocalizedString("crowdloan.too.small.contribution.title", bundle: bundle, comment: "")
      }

      /// en translation: Controller
      ///
      /// Locales: en, ru
      static func stakingController(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller"
        }

        return NSLocalizedString("staking.controller", bundle: bundle, comment: "")
      }

      /// en translation: Controller account
      ///
      /// Locales: en, ru
      static func stakingControllerAccountTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.account.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.account.title"
        }

        return NSLocalizedString("staking.controller.account.title", bundle: bundle, comment: "")
      }

      /// en translation: Controller can unstake, redeem, return to stake, change rewards destination and validators.
      ///
      /// Locales: en, ru
      static func stakingControllerCanHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.can.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.can.hint"
        }

        return NSLocalizedString("staking.controller.can.hint", bundle: bundle, comment: "")
      }

      /// en translation: Controller is used to: unstake, redeem, return to stake, change validators and set rewards destination
      ///
      /// Locales: en, ru
      static func stakingControllerCanHint_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.can.hint_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.can.hint_v2_2_0"
        }

        return NSLocalizedString("staking.controller.can.hint_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Copied to clipboard
      ///
      /// Locales: en, ru
      static func commonCopied(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.copied", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.copied"
        }

        return NSLocalizedString("common.copied", bundle: bundle, comment: "")
      }

      /// en translation: Copy address
      ///
      /// Locales: en, ru
      static func commonCopyAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.copy.address", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.copy.address"
        }

        return NSLocalizedString("common.copy.address", bundle: bundle, comment: "")
      }

      /// en translation: Copy hash
      ///
      /// Locales: en, ru
      static func transactionDetailsCopyHash(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.details.copy.hash", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.details.copy.hash"
        }

        return NSLocalizedString("transaction.details.copy.hash", bundle: bundle, comment: "")
      }

      /// en translation: Copy id
      ///
      /// Locales: en, ru
      static func commonCopyId(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.copy.id", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.copy.id"
        }

        return NSLocalizedString("common.copy.id", bundle: bundle, comment: "")
      }

      /// en translation: Couldn't extract data from the database. Please, try again later.
      ///
      /// Locales: en, ru
      static func commonDbSubscriptionError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.db.subscription.error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.db.subscription.error"
        }

        return NSLocalizedString("common.db.subscription.error", bundle: bundle, comment: "")
      }

      /// en translation: Create a new account
      ///
      /// Locales: en, ru
      static func accountUsernameSetupTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.username.setup.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.username.setup.title"
        }

        return NSLocalizedString("account.username.setup.title", bundle: bundle, comment: "")
      }

      /// en translation: Create a new account
      ///
      /// Locales: en, ru
      static func onboardingCreateChainAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.create.chain.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.create.chain.account"
        }

        return NSLocalizedString("onboarding.create.chain.account", bundle: bundle, comment: "")
      }

      /// en translation: Create a new wallet
      ///
      /// Locales: en, ru
      static func onboardingCreateWallet(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.create.wallet", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.create.wallet"
        }

        return NSLocalizedString("onboarding.create.wallet", bundle: bundle, comment: "")
      }

      /// en translation: Create a new wallet
      ///
      /// Locales: en, ru
      static func walletUsernameSetupTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.username.setup.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.username.setup.title"
        }

        return NSLocalizedString("wallet.username.setup.title", bundle: bundle, comment: "")
      }

      /// en translation: Create account
      ///
      /// Locales: en, ru
      static func accountCreateOptionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.create.option.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.create.option.title"
        }

        return NSLocalizedString("account.create.option.title", bundle: bundle, comment: "")
      }

      /// en translation: Create account
      ///
      /// Locales: en, ru
      static func onboardingCreateAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.create.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.create.account"
        }

        return NSLocalizedString("onboarding.create.account", bundle: bundle, comment: "")
      }

      /// en translation: Create pin code
      ///
      /// Locales: en, ru
      static func pincodeCreateTopTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("pincode.create.top.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "pincode.create.top.title"
        }

        return NSLocalizedString("pincode.create.top.title", bundle: bundle, comment: "")
      }

      /// en translation: Create wallet name
      ///
      /// Locales: en, ru
      static func walletNicknameCreateTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.nickname.create.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.nickname.create.title_v2_2_0"
        }

        return NSLocalizedString("wallet.nickname.create.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Create wallet nickname
      ///
      /// Locales: en, ru
      static func walletNicknameCreateTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.nickname.create.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.nickname.create.title"
        }

        return NSLocalizedString("wallet.nickname.create.title", bundle: bundle, comment: "")
      }

      /// en translation: Created by
      ///
      /// Locales: en, ru
      static func nftIssuerTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("nft.issuer.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "nft.issuer.title"
        }

        return NSLocalizedString("nft.issuer.title", bundle: bundle, comment: "")
      }

      /// en translation: Crowdloan cap exceeded
      ///
      /// Locales: en, ru
      static func crowdloanCapReachedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.cap.reached.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.cap.reached.title"
        }

        return NSLocalizedString("crowdloan.cap.reached.title", bundle: bundle, comment: "")
      }

      /// en translation: Crowdloan info
      ///
      /// Locales: en, ru
      static func crowdloanInfo(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.info", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.info"
        }

        return NSLocalizedString("crowdloan.info", bundle: bundle, comment: "")
      }

      /// en translation: Crowdloan is ended
      ///
      /// Locales: en, ru
      static func crowdloanEndedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.ended.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.ended.title"
        }

        return NSLocalizedString("crowdloan.ended.title", bundle: bundle, comment: "")
      }

      /// en translation: Crowdloans
      ///
      /// Locales: en, ru
      static func tabbarCrowdloanTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.crowdloan.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.crowdloan.title"
        }

        return NSLocalizedString("tabbar.crowdloan.title", bundle: bundle, comment: "")
      }

      /// en translation: Crowdloans
      ///
      /// Locales: en, ru
      static func tabbarCrowdloanTitle_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.crowdloan.title_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.crowdloan.title_v1.9.0"
        }

        return NSLocalizedString("tabbar.crowdloan.title_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Crowdloans will be displayed here
      ///
      /// Locales: en, ru
      static func crowdloanEmptyMessage_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.empty.message_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.empty.message_v2_2_0"
        }

        return NSLocalizedString("crowdloan.empty.message_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Custom
      ///
      /// Locales: en, ru
      static func connectionManagementCustomTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.management.custom.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.management.custom.title"
        }

        return NSLocalizedString("connection.management.custom.title", bundle: bundle, comment: "")
      }

      /// en translation: Custom amount
      ///
      /// Locales: en, ru
      static func stakingRebondActionCustom(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond.action.custom", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond.action.custom"
        }

        return NSLocalizedString("staking.rebond.action.custom", bundle: bundle, comment: "")
      }

      /// en translation: DApp
      ///
      /// Locales: en, ru
      static func commonDapp(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.dapp", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.dapp"
        }

        return NSLocalizedString("common.dapp", bundle: bundle, comment: "")
      }

      /// en translation: DApp communication failed with reason: %@
      ///
      /// Locales: en, ru
      static func dappUnexpectedErrorFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("dapp.unexpected.error.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.unexpected.error.format"
        }

        let format = NSLocalizedString("dapp.unexpected.error.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: DApps
      ///
      /// Locales: en, ru
      static func dappSearchAppSection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.search.app.section", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.search.app.section"
        }

        return NSLocalizedString("dapp.search.app.section", bundle: bundle, comment: "")
      }

      /// en translation: DApps
      ///
      /// Locales: en, ru
      static func tabbarDappsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.dapps.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.dapps.title"
        }

        return NSLocalizedString("tabbar.dapps.title", bundle: bundle, comment: "")
      }

      /// en translation: Date
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsDate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.date", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.date"
        }

        return NSLocalizedString("staking.reward.details.date", bundle: bundle, comment: "")
      }

      /// en translation: Date
      ///
      /// Locales: en, ru
      static func transactionDetailDate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.detail.date", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.detail.date"
        }

        return NSLocalizedString("transaction.detail.date", bundle: bundle, comment: "")
      }

      /// en translation: Default
      ///
      /// Locales: en, ru
      static func connectionManagementDefaultTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.management.default.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.management.default.title"
        }

        return NSLocalizedString("connection.management.default.title", bundle: bundle, comment: "")
      }

      /// en translation: Delete
      ///
      /// Locales: en, ru
      static func connectionDeleteConfirm(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.delete.confirm", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.delete.confirm"
        }

        return NSLocalizedString("connection.delete.confirm", bundle: bundle, comment: "")
      }

      /// en translation: Delete network?
      ///
      /// Locales: en, ru
      static func connectionDeleteTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.delete.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.delete.title"
        }

        return NSLocalizedString("connection.delete.title", bundle: bundle, comment: "")
      }

      /// en translation: Democracy
      ///
      /// Locales: en, ru
      static func walletAccountLocksDemocracy(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.account.locks.democracy", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.account.locks.democracy"
        }

        return NSLocalizedString("wallet.account.locks.democracy", bundle: bundle, comment: "")
      }

      /// en translation: Deselect all
      ///
      /// Locales: en, ru
      static func stakingCustomDeselectButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.deselect.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.deselect.button.title"
        }

        return NSLocalizedString("staking.custom.deselect.button.title", bundle: bundle, comment: "")
      }

      /// en translation: Details
      ///
      /// Locales: en, ru
      static func commonDetails(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.details", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.details"
        }

        return NSLocalizedString("common.details", bundle: bundle, comment: "")
      }

      /// en translation: Direct
      ///
      /// Locales: en, ru
      static func crowdloanAcalaDirect(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.acala.direct", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.acala.direct"
        }

        return NSLocalizedString("crowdloan.acala.direct", bundle: bundle, comment: "")
      }

      /// en translation: Do not take screenshots
      ///
      /// Locales: en, ru
      static func commonNoScreenshotTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.no.screenshot.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.no.screenshot.title"
        }

        return NSLocalizedString("common.no.screenshot.title", bundle: bundle, comment: "")
      }

      /// en translation: Do not take screenshots, which may be collected by third-party malware
      ///
      /// Locales: en, ru
      static func commonNoScreenshotMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.no.screenshot.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.no.screenshot.message"
        }

        return NSLocalizedString("common.no.screenshot.message", bundle: bundle, comment: "")
      }

      /// en translation: Do not use clipboard or screenshots on your mobile device, try to find secure methods for backup (e.g. paper)
      ///
      /// Locales: en, ru
      static func accountCreateDetails_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.create.details_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.create.details_v2_2_0"
        }

        return NSLocalizedString("account.create.details_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Done
      ///
      /// Locales: en, ru
      static func commonDone(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.done", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.done"
        }

        return NSLocalizedString("common.done", bundle: bundle, comment: "")
      }

      /// en translation: During unstaking period tokens produce no rewards
      ///
      /// Locales: en, ru
      static func stakingHintNoRewards_V2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.no.rewards_ v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.no.rewards_ v2_2_0"
        }

        return NSLocalizedString("staking.hint.no.rewards_ v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: ECDSA
      ///
      /// Locales: en, ru
      static func ecdsaSelectionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ecdsa.selection.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ecdsa.selection.title"
        }

        return NSLocalizedString("ecdsa.selection.title", bundle: bundle, comment: "")
      }

      /// en translation: Earnings with restake
      ///
      /// Locales: en, ru
      static func stakingRewardInfoTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.info.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.info.title"
        }

        return NSLocalizedString("staking.reward.info.title", bundle: bundle, comment: "")
      }

      /// en translation: Edit
      ///
      /// Locales: en, ru
      static func commonEdit(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.edit", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.edit"
        }

        return NSLocalizedString("common.edit", bundle: bundle, comment: "")
      }

      /// en translation: Edwards
      ///
      /// Locales: en, ru
      static func ed25519SelectionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ed25519.selection.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ed25519.selection.title"
        }

        return NSLocalizedString("ed25519.selection.title", bundle: bundle, comment: "")
      }

      /// en translation: Elected
      ///
      /// Locales: en, ru
      static func stakingValidatorStatusElected(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.status.elected", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.status.elected"
        }

        return NSLocalizedString("staking.validator.status.elected", bundle: bundle, comment: "")
      }

      /// en translation: Elected (%@)
      ///
      /// Locales: en, ru
      static func stakingYourElectedFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.your.elected.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.elected.format"
        }

        let format = NSLocalizedString("staking.your.elected.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Elections
      ///
      /// Locales: en, ru
      static func walletAccountLocksElections(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.account.locks.elections", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.account.locks.elections"
        }

        return NSLocalizedString("wallet.account.locks.elections", bundle: bundle, comment: "")
      }

      /// en translation: Element name
      ///
      /// Locales: en, ru
      static func identityRiotNameTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("identity.riot.name.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "identity.riot.name.title"
        }

        return NSLocalizedString("identity.riot.name.title", bundle: bundle, comment: "")
      }

      /// en translation: Email
      ///
      /// Locales: en, ru
      static func identityEmailTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("identity.email.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "identity.email.title"
        }

        return NSLocalizedString("identity.email.title", bundle: bundle, comment: "")
      }

      /// en translation: Email
      ///
      /// Locales: en, ru
      static func settingsEmail(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.email", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.email"
        }

        return NSLocalizedString("settings.email", bundle: bundle, comment: "")
      }

      /// en translation: Enter PIN code
      ///
      /// Locales: en, ru
      static func pincodeEnterPinCode(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("pincode.enter.pin.code", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "pincode.enter.pin.code"
        }

        return NSLocalizedString("pincode.enter.pin.code", bundle: bundle, comment: "")
      }

      /// en translation: Enter a wallet name...
      ///
      /// Locales: en, ru
      static func walletCreateButtonTitleDisabled_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.create.button.title.disabled_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.create.button.title.disabled_v2_2_0"
        }

        return NSLocalizedString("wallet.create.button.title.disabled_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Enter password...
      ///
      /// Locales: en, ru
      static func walletImportNoPassword(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.no.password", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.no.password"
        }

        return NSLocalizedString("wallet.import.no.password", bundle: bundle, comment: "")
      }

      /// en translation: Enter the address...
      ///
      /// Locales: en, ru
      static func transferSetupEnterAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transfer.setup.enter.address", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transfer.setup.enter.address"
        }

        return NSLocalizedString("transfer.setup.enter.address", bundle: bundle, comment: "")
      }

      /// en translation: Enter the amount...
      ///
      /// Locales: en, ru
      static func transferSetupEnterAmount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transfer.setup.enter.amount", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transfer.setup.enter.amount"
        }

        return NSLocalizedString("transfer.setup.enter.amount", bundle: bundle, comment: "")
      }

      /// en translation: Enter the raw seed...
      ///
      /// Locales: en, ru
      static func walletImportNoSeedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.no.seed.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.no.seed.title"
        }

        return NSLocalizedString("wallet.import.no.seed.title", bundle: bundle, comment: "")
      }

      /// en translation: Enter the words in the right order
      ///
      /// Locales: en, ru
      static func walletImportMnemonicTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.mnemonic.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.mnemonic.title"
        }

        return NSLocalizedString("wallet.import.mnemonic.title", bundle: bundle, comment: "")
      }

      /// en translation: Enter the words...
      ///
      /// Locales: en, ru
      static func walletImportNoMnemonicTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.no.mnemonic.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.no.mnemonic.title"
        }

        return NSLocalizedString("wallet.import.no.mnemonic.title", bundle: bundle, comment: "")
      }

      /// en translation: Enter wallet name...
      ///
      /// Locales: en, ru
      static func walletImportNoNameTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.no.name.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.no.name.title"
        }

        return NSLocalizedString("wallet.import.no.name.title", bundle: bundle, comment: "")
      }

      /// en translation: Enter your raw seed
      ///
      /// Locales: en, ru
      static func walletImportSeedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.seed.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.seed.title"
        }

        return NSLocalizedString("wallet.import.seed.title", bundle: bundle, comment: "")
      }

      /// en translation: Enter your referral code
      ///
      /// Locales: en, ru
      static func karuraReferralCodeAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("karura.referral.code.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "karura.referral.code.action"
        }

        return NSLocalizedString("karura.referral.code.action", bundle: bundle, comment: "")
      }

      /// en translation: Era
      ///
      /// Locales: en, ru
      static func stakingCommonEra(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.common.era", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.common.era"
        }

        return NSLocalizedString("staking.common.era", bundle: bundle, comment: "")
      }

      /// en translation: Era
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsEra(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.era", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.era"
        }

        return NSLocalizedString("staking.reward.details.era", bundle: bundle, comment: "")
      }

      /// en translation: Error
      ///
      /// Locales: en, ru
      static func commonErrorGeneralTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.error.general.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.error.general.title"
        }

        return NSLocalizedString("common.error.general.title", bundle: bundle, comment: "")
      }

      /// en translation: Estimated %@ earnings
      ///
      /// Locales: en, ru
      static func stakingEstimateEarningTitle_v190(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.estimate.earning.title_v1.9.0", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.estimate.earning.title_v1.9.0"
        }

        let format = NSLocalizedString("staking.estimate.earning.title_v1.9.0", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Estimated reward
      ///
      /// Locales: en, ru
      static func crowdloanReward(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.reward", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.reward"
        }

        return NSLocalizedString("crowdloan.reward", bundle: bundle, comment: "")
      }

      /// en translation: Estimated reward
      ///
      /// Locales: en, ru
      static func stakingValidatorEstimatedReward(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.estimated.reward", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.estimated.reward"
        }

        return NSLocalizedString("staking.validator.estimated.reward", bundle: bundle, comment: "")
      }

      /// en translation: Estimated reward (% APY)
      ///
      /// Locales: en, ru
      static func stakingValidatorApyPercent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.apy.percent", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.apy.percent"
        }

        return NSLocalizedString("staking.validator.apy.percent", bundle: bundle, comment: "")
      }

      /// en translation: Ethereum keypair crypto type
      ///
      /// Locales: en, ru
      static func commonCryptoTypeEthereum(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.crypto.type.ethereum", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.crypto.type.ethereum"
        }

        return NSLocalizedString("common.crypto.type.ethereum", bundle: bundle, comment: "")
      }

      /// en translation: Ethereum secret derivation path
      ///
      /// Locales: en, ru
      static func commonSecretDerivationPathEthereum(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.secret.derivation.path.ethereum", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.secret.derivation.path.ethereum"
        }

        return NSLocalizedString("common.secret.derivation.path.ethereum", bundle: bundle, comment: "")
      }

      /// en translation: Event
      ///
      /// Locales: en, ru
      static func stakingCommonEventId(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.common.event.id", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.common.event.id"
        }

        return NSLocalizedString("staking.common.event.id", bundle: bundle, comment: "")
      }

      /// en translation: Everyone can be a validator and run a blockchain node, but that requires a certain level of technical skills and responsibility. Polkadot and Kusama networks have a program, named Thousand Validators Programme, to provide support for beginners. Moreover, the network itself will always reward more validators, who have less stake (but enough to be elected) to improve decentralization.
      ///
      /// Locales: en, ru
      static func stakingStoryValidatorPage2(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.validator.page.2", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.validator.page.2"
        }

        return NSLocalizedString("staking.story.validator.page.2", bundle: bundle, comment: "")
      }

      /// en translation: Example: Savings, Investments, Crowdloans, Staking.
      ///
      /// Locales: en, ru
      static func walletUsernameSetupHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.username.setup.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.username.setup.hint"
        }

        return NSLocalizedString("wallet.username.setup.hint", bundle: bundle, comment: "")
      }

      /// en translation: Examples: Savings, Investments, Crowdloans, Staking.
      ///
      /// Locales: en, ru
      static func walletNicknameCreateCaption(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.nickname.create.caption", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.nickname.create.caption"
        }

        return NSLocalizedString("wallet.nickname.create.caption", bundle: bundle, comment: "")
      }

      /// en translation: Explore
      ///
      /// Locales: en, ru
      static func dappsListHeaderTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapps.list.header.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapps.list.header.title"
        }

        return NSLocalizedString("dapps.list.header.title", bundle: bundle, comment: "")
      }

      /// en translation: Export
      ///
      /// Locales: en, ru
      static func accountExportAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.export.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.export.action"
        }

        return NSLocalizedString("account.export.action", bundle: bundle, comment: "")
      }

      /// en translation: Export account
      ///
      /// Locales: en, ru
      static func commonExport(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.export", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.export"
        }

        return NSLocalizedString("common.export", bundle: bundle, comment: "")
      }

      /// en translation: Extrinsic Hash
      ///
      /// Locales: en, ru
      static func transactionDetailsHashTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.details.hash.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.details.hash.title"
        }

        return NSLocalizedString("transaction.details.hash.title", bundle: bundle, comment: "")
      }

      /// en translation: Extrinsic details
      ///
      /// Locales: en, ru
      static func walletExtrinsicDetailsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.extrinsic.details.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.extrinsic.details.title"
        }

        return NSLocalizedString("wallet.extrinsic.details.title", bundle: bundle, comment: "")
      }

      /// en translation: Extrinsic extensions doesn't much local ones
      ///
      /// Locales: en, ru
      static func dappConfirmationExtensionsMismatch(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.confirmation.extensions.mismatch", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.confirmation.extensions.mismatch"
        }

        return NSLocalizedString("dapp.confirmation.extensions.mismatch", bundle: bundle, comment: "")
      }

      /// en translation: Face ID
      ///
      /// Locales: en, ru
      static func askFaceidTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ask.faceid.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ask.faceid.title"
        }

        return NSLocalizedString("ask.faceid.title", bundle: bundle, comment: "")
      }

      /// en translation: Face ID is used to authorize in application
      ///
      /// Locales: en, ru
      static func nsFaceIDUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSFaceIDUsageDescription", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "NSFaceIDUsageDescription"
        }

        return NSLocalizedString("NSFaceIDUsageDescription", bundle: bundle, comment: "")
      }

      /// en translation: Failed
      ///
      /// Locales: en, ru
      static func transactionStatusFailed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.status.failed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.status.failed"
        }

        return NSLocalizedString("transaction.status.failed", bundle: bundle, comment: "")
      }

      /// en translation: Failed to sign requested operation
      ///
      /// Locales: en, ru
      static func dappSignExtrinsicFailed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.sign.extrinsic.failed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.sign.extrinsic.failed"
        }

        return NSLocalizedString("dapp.sign.extrinsic.failed", bundle: bundle, comment: "")
      }

      /// en translation: Favorites
      ///
      /// Locales: en, ru
      static func commonFavorites(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.favorites", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.favorites"
        }

        return NSLocalizedString("common.favorites", bundle: bundle, comment: "")
      }

      /// en translation: Featured websites
      ///
      /// Locales: en, ru
      static func dappListFeaturedWebsites(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.list.featured.websites", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.list.featured.websites"
        }

        return NSLocalizedString("dapp.list.featured.websites", bundle: bundle, comment: "")
      }

      /// en translation: Fee
      ///
      /// Locales: en, ru
      static func transactionDetailsExtrinsicFee(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.details.extrinsic.fee", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.details.extrinsic.fee"
        }

        return NSLocalizedString("transaction.details.extrinsic.fee", bundle: bundle, comment: "")
      }

      /// en translation: Fee calculation is in progress
      ///
      /// Locales: en, ru
      static func feeNotYetLoadedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("fee.not.yet.loaded.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "fee.not.yet.loaded.title"
        }

        return NSLocalizedString("fee.not.yet.loaded.title", bundle: bundle, comment: "")
      }

      /// en translation: Fee loading failed. Would you like to retry?
      ///
      /// Locales: en, ru
      static func commonFeeRetryFailed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.fee.retry.failed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.fee.retry.failed"
        }

        return NSLocalizedString("common.fee.retry.failed", bundle: bundle, comment: "")
      }

      /// en translation: Fill rest with recommended
      ///
      /// Locales: en, ru
      static func stakingCustomFillButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.fill.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.fill.button.title"
        }

        return NSLocalizedString("staking.custom.fill.button.title", bundle: bundle, comment: "")
      }

      /// en translation: Filters
      ///
      /// Locales: en, ru
      static func assetsManageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("assets.manage.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "assets.manage.title"
        }

        return NSLocalizedString("assets.manage.title", bundle: bundle, comment: "")
      }

      /// en translation: Filters
      ///
      /// Locales: en, ru
      static func walletFiltersTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.filters.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.filters.title"
        }

        return NSLocalizedString("wallet.filters.title", bundle: bundle, comment: "")
      }

      /// en translation: Find out more
      ///
      /// Locales: en, ru
      static func commonFindMore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.find.more", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.find.more"
        }

        return NSLocalizedString("common.find.more", bundle: bundle, comment: "")
      }

      /// en translation: Find out more about
      ///
      /// Locales: en, ru
      static func commonLearnMore_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.learn.more_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.learn.more_v2_2_0"
        }

        return NSLocalizedString("common.learn.more_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Following address: %@ is known to be used in phishing activities, thus we are not recommending sending tokens to that address. Would you like to proceed anyway?
      ///
      /// Locales: en, ru
      static func walletSendPhishingWarningText(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("wallet.send.phishing.warning.text", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.phishing.warning.text"
        }

        let format = NSLocalizedString("wallet.send.phishing.warning.text", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Forget
      ///
      /// Locales: en, ru
      static func accountDeleteConfirm(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.delete.confirm", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.delete.confirm"
        }

        return NSLocalizedString("account.delete.confirm", bundle: bundle, comment: "")
      }

      /// en translation: Forget account?
      ///
      /// Locales: en, ru
      static func accountDeleteConfirmationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.delete.confirmation.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.delete.confirmation.title"
        }

        return NSLocalizedString("account.delete.confirmation.title", bundle: bundle, comment: "")
      }

      /// en translation: Forget wallet?
      ///
      /// Locales: en, ru
      static func walletDeleteConfirmationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.delete.confirmation.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.delete.confirmation.title"
        }

        return NSLocalizedString("wallet.delete.confirmation.title", bundle: bundle, comment: "")
      }

      /// en translation: From
      ///
      /// Locales: en, ru
      static func transactionDetailsFrom(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.details.from", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.details.from"
        }

        return NSLocalizedString("transaction.details.from", bundle: bundle, comment: "")
      }

      /// en translation: Frozen
      ///
      /// Locales: en, ru
      static func walletBalanceFrozen(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.frozen", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.frozen"
        }

        return NSLocalizedString("wallet.balance.frozen", bundle: bundle, comment: "")
      }

      /// en translation: General
      ///
      /// Locales: en, ru
      static func settingsGeneral(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.general", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.general"
        }

        return NSLocalizedString("settings.general", bundle: bundle, comment: "")
      }

      /// en translation: Generated signature is invalid
      ///
      /// Locales: en, ru
      static func dappConfirmationInvalidSignature(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.confirmation.invalid.signature", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.confirmation.invalid.signature"
        }

        return NSLocalizedString("dapp.confirmation.invalid.signature", bundle: bundle, comment: "")
      }

      /// en translation: Get a special bonus
      ///
      /// Locales: en, ru
      static func crowdloanEmptyBonusTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.empty.bonus.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.empty.bonus.title"
        }

        return NSLocalizedString("crowdloan.empty.bonus.title", bundle: bundle, comment: "")
      }

      /// en translation: Github
      ///
      /// Locales: en, ru
      static func aboutGithub(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.github", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.github"
        }

        return NSLocalizedString("about.github", bundle: bundle, comment: "")
      }

      /// en translation: Having onchain identity
      ///
      /// Locales: en, ru
      static func stakingRecommendedHint3(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.hint3", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.hint3"
        }

        return NSLocalizedString("staking.recommended.hint3", bundle: bundle, comment: "")
      }

      /// en translation: Hexadecimal string
      ///
      /// Locales: en, ru
      static func secretTypeSeedSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.seed.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.seed.subtitle"
        }

        return NSLocalizedString("secret.type.seed.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Hide assets with zero balances
      ///
      /// Locales: en, ru
      static func assetsManageHideZeroBalances(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("assets.manage.hide.zero.balances", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "assets.manage.hide.zero.balances"
        }

        return NSLocalizedString("assets.manage.hide.zero.balances", bundle: bundle, comment: "")
      }

      /// en translation: History
      ///
      /// Locales: en, ru
      static func walletHistoryTitle_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.history.title_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.history.title_v1.9.0"
        }

        return NSLocalizedString("wallet.history.title_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: How it works
      ///
      /// Locales: en, ru
      static func commonHowItWorks(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.how.it.works", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.how.it.works"
        }

        return NSLocalizedString("common.how.it.works", bundle: bundle, comment: "")
      }

      /// en translation: How to use your rewards?
      ///
      /// Locales: en, ru
      static func stakingSetupRewardDestinationSectionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.setup.reward.destination.section.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.reward.destination.section.title"
        }

        return NSLocalizedString("staking.setup.reward.destination.section.title", bundle: bundle, comment: "")
      }

      /// en translation: I have read and agree to %@
      ///
      /// Locales: en, ru
      static func crowdloanTermsFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.terms.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.terms.format"
        }

        let format = NSLocalizedString("crowdloan.terms.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: I have read and agreed to Terms and Conditions and Privacy Policy
      ///
      /// Locales: en, ru
      static func onboardingTermsAndConditions1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.terms.and.conditions.1", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.terms.and.conditions.1"
        }

        return NSLocalizedString("onboarding.terms.and.conditions.1", bundle: bundle, comment: "")
      }

      /// en translation: I understand
      ///
      /// Locales: en, ru
      static func commonUnderstand(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.understand", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.understand"
        }

        return NSLocalizedString("common.understand", bundle: bundle, comment: "")
      }

      /// en translation: Identity
      ///
      /// Locales: en, ru
      static func identityTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("identity.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "identity.title"
        }

        return NSLocalizedString("identity.title", bundle: bundle, comment: "")
      }

      /// en translation: If you don't have referral code, you can apply Nova referral code to receive bonus for your contribution
      ///
      /// Locales: en, ru
      static func crowdloanHavenotAppliedBonusMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.havenot.applied.bonus.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.havenot.applied.bonus.message"
        }

        return NSLocalizedString("crowdloan.havenot.applied.bonus.message", bundle: bundle, comment: "")
      }

      /// en translation: If you want to unstake tokens, you will have to wait for the unstaking period (%@).
      ///
      /// Locales: en, ru
      static func stakingHintUnstakeFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.hint.unstake.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.unstake.format"
        }

        let format = NSLocalizedString("staking.hint.unstake.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Import account
      ///
      /// Locales: en, ru
      static func accountImportOptionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.option.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.option.title"
        }

        return NSLocalizedString("account.import.option.title", bundle: bundle, comment: "")
      }

      /// en translation: Import account
      ///
      /// Locales: en, ru
      static func importChainAccountTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.chain.account.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.chain.account.title"
        }

        return NSLocalizedString("import.chain.account.title", bundle: bundle, comment: "")
      }

      /// en translation: Import wallet
      ///
      /// Locales: en, ru
      static func importWalletTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.wallet.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.wallet.title"
        }

        return NSLocalizedString("import.wallet.title", bundle: bundle, comment: "")
      }

      /// en translation: Improve staking security
      ///
      /// Locales: en, ru
      static func stakingControllerBannerTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.banner.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.banner.title"
        }

        return NSLocalizedString("staking.controller.banner.title", bundle: bundle, comment: "")
      }

      /// en translation: In future updates, we will add staking features for the validators.
      ///
      /// Locales: en, ru
      static func stakingValidatorSummaryDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.summary.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.summary.description"
        }

        return NSLocalizedString("staking.validator.summary.description", bundle: bundle, comment: "")
      }

      /// en translation: Inactive
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusInactive(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.inactive", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.inactive"
        }

        return NSLocalizedString("staking.nominator.status.inactive", bundle: bundle, comment: "")
      }

      /// en translation: Inactive status
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusAlertInactiveTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.alert.inactive.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.alert.inactive.title"
        }

        return NSLocalizedString("staking.nominator.status.alert.inactive.title", bundle: bundle, comment: "")
      }

      /// en translation: Incoming and outgoing operations will appear here
      ///
      /// Locales: en, ru
      static func walletEmptyDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.empty.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.empty.description"
        }

        return NSLocalizedString("wallet.empty.description", bundle: bundle, comment: "")
      }

      /// en translation: Info
      ///
      /// Locales: en, ru
      static func commonInfo(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.info", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.info"
        }

        return NSLocalizedString("common.info", bundle: bundle, comment: "")
      }

      /// en translation: Information about crowdloans  will appear here
      ///
      /// Locales: en, ru
      static func crowdloanEmptyMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.empty.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.empty.message"
        }

        return NSLocalizedString("crowdloan.empty.message", bundle: bundle, comment: "")
      }

      /// en translation: Input the amount...
      ///
      /// Locales: en, ru
      static func commonInputAmountHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.input.amount.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.input.amount.hint"
        }

        return NSLocalizedString("common.input.amount.hint", bundle: bundle, comment: "")
      }

      /// en translation: Insufficient balance
      ///
      /// Locales: en, ru
      static func stakingErrorInsufficientBalanceTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.error.insufficient.balance.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.error.insufficient.balance.title"
        }

        return NSLocalizedString("staking.error.insufficient.balance.title", bundle: bundle, comment: "")
      }

      /// en translation: Invalid derivation path
      ///
      /// Locales: en, ru
      static func commonInvalidPathTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.path.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.path.title_v2_2_0"
        }

        return NSLocalizedString("common.invalid.path.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Invalid field in transaction: %@
      ///
      /// Locales: en, ru
      static func dappConfirmationBadField(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("dapp.confirmation.bad.field", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.confirmation.bad.field"
        }

        let format = NSLocalizedString("dapp.confirmation.bad.field", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Invalid format
      ///
      /// Locales: en, ru
      static func commonInvalidPathTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.path.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.path.title"
        }

        return NSLocalizedString("common.invalid.path.title", bundle: bundle, comment: "")
      }

      /// en translation: Invalid mnemonic
      ///
      /// Locales: en, ru
      static func confirmMnemonicMismatchErrorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("confirm.mnemonic.mismatch.error.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "confirm.mnemonic.mismatch.error.title"
        }

        return NSLocalizedString("confirm.mnemonic.mismatch.error.title", bundle: bundle, comment: "")
      }

      /// en translation: Invalid mnemonic passphrase, please check one more time the words order
      ///
      /// Locales: en, ru
      static func accessRestorePhraseErrorMessage_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("access.restore.phrase.error.message_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "access.restore.phrase.error.message_v2_2_0"
        }

        return NSLocalizedString("access.restore.phrase.error.message_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Invalid recipient
      ///
      /// Locales: en, ru
      static func commonValidationInvalidAddressTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.validation.invalid.address.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.validation.invalid.address.title"
        }

        return NSLocalizedString("common.validation.invalid.address.title", bundle: bundle, comment: "")
      }

      /// en translation: Invalid restore json. Please, make sure that input contains valid json.
      ///
      /// Locales: en, ru
      static func accountImportInvalidKeystore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.invalid.keystore", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.invalid.keystore"
        }

        return NSLocalizedString("account.import.invalid.keystore", bundle: bundle, comment: "")
      }

      /// en translation: JSON contains no network information. Please specify it below.
      ///
      /// Locales: en, ru
      static func accountImportJsonNoNetwork(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.json.no.network", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.json.no.network"
        }

        return NSLocalizedString("account.import.json.no.network", bundle: bundle, comment: "")
      }

      /// en translation: JSON file
      ///
      /// Locales: en, ru
      static func secretTypeKeystoreSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.keystore.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.keystore.subtitle"
        }

        return NSLocalizedString("secret.type.keystore.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Keypair crypto type
      ///
      /// Locales: en, ru
      static func commonCryptoType(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.crypto.type", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.crypto.type"
        }

        return NSLocalizedString("common.crypto.type", bundle: bundle, comment: "")
      }

      /// en translation: Keystore decryption failed
      ///
      /// Locales: en, ru
      static func accountImportKeystoreDecryptionErrorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.keystore.decryption.error.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.keystore.decryption.error.title"
        }

        return NSLocalizedString("account.import.keystore.decryption.error.title", bundle: bundle, comment: "")
      }

      /// en translation: Language
      ///
      /// Locales: en, ru
      static func languageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("language.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "language.title"
        }

        return NSLocalizedString("language.title", bundle: bundle, comment: "")
      }

      /// en translation: Language
      ///
      /// Locales: en, ru
      static func profileLanguageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("profile.language.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "profile.language.title"
        }

        return NSLocalizedString("profile.language.title", bundle: bundle, comment: "")
      }

      /// en translation: Latest unstaked
      ///
      /// Locales: en, ru
      static func stakingRebondActionLast(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond.action.last", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond.action.last"
        }

        return NSLocalizedString("staking.rebond.action.last", bundle: bundle, comment: "")
      }

      /// en translation: Learn %@'s crowdloan
      ///
      /// Locales: en, ru
      static func crowdloanLearn(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.learn", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.learn"
        }

        let format = NSLocalizedString("crowdloan.learn", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Learn more
      ///
      /// Locales: en, ru
      static func commonLearnMore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.learn.more", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.learn.more"
        }

        return NSLocalizedString("common.learn.more", bundle: bundle, comment: "")
      }

      /// en translation: Learn more about different contributions to Acala
      ///
      /// Locales: en, ru
      static func crowdloanAcalaLearnMore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.acala.learn.more", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.acala.learn.more"
        }

        return NSLocalizedString("crowdloan.acala.learn.more", bundle: bundle, comment: "")
      }

      /// en translation: Learn more about rewards
      ///
      /// Locales: en, ru
      static func stakingRewardsLearnMore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rewards.learn.more", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rewards.learn.more"
        }

        return NSLocalizedString("staking.rewards.learn.more", bundle: bundle, comment: "")
      }

      /// en translation: Leasing period
      ///
      /// Locales: en, ru
      static func crowdloanLeasingPeriod(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.leasing.period", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.leasing.period"
        }

        return NSLocalizedString("crowdloan.leasing.period", bundle: bundle, comment: "")
      }

      /// en translation: Legal name
      ///
      /// Locales: en, ru
      static func identityLegalNameTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("identity.legal.name.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "identity.legal.name.title"
        }

        return NSLocalizedString("identity.legal.name.title", bundle: bundle, comment: "")
      }

      /// en translation: Let sender scan this QR code
      ///
      /// Locales: en, ru
      static func walletReceiveDescription_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.receive.description_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.receive.description_v2_2_0"
        }

        return NSLocalizedString("wallet.receive.description_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Lets double check it
      ///
      /// Locales: en, ru
      static func confirmMnemonicTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("confirm.mnemonic.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "confirm.mnemonic.title"
        }

        return NSLocalizedString("confirm.mnemonic.title", bundle: bundle, comment: "")
      }

      /// en translation: Limit of 2 validators per identity
      ///
      /// Locales: en, ru
      static func stakingRecommendedHint5(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.hint5", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.hint5"
        }

        return NSLocalizedString("staking.recommended.hint5", bundle: bundle, comment: "")
      }

      /// en translation: Liquid
      ///
      /// Locales: en, ru
      static func crowdloanAcalaLiquid(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.acala.liquid", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.acala.liquid"
        }

        return NSLocalizedString("crowdloan.acala.liquid", bundle: bundle, comment: "")
      }

      /// en translation: List of websites will appear here
      ///
      /// Locales: en, ru
      static func dappAuthorizedEmpty(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.authorized.empty", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.authorized.empty"
        }

        return NSLocalizedString("dapp.authorized.empty", bundle: bundle, comment: "")
      }

      /// en translation: Load photos from library
      ///
      /// Locales: en, ru
      static func nsPhotoLibraryUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSPhotoLibraryUsageDescription", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "NSPhotoLibraryUsageDescription"
        }

        return NSLocalizedString("NSPhotoLibraryUsageDescription", bundle: bundle, comment: "")
      }

      /// en translation: Loading validators...
      ///
      /// Locales: en, ru
      static func stakingLoadingValidators(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.loading.validators", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.loading.validators"
        }

        return NSLocalizedString("staking.loading.validators", bundle: bundle, comment: "")
      }

      /// en translation: Locked
      ///
      /// Locales: en, ru
      static func walletBalanceLocked(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.locked", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.locked"
        }

        return NSLocalizedString("wallet.balance.locked", bundle: bundle, comment: "")
      }

      /// en translation: Make sure that the address is  from the right network
      ///
      /// Locales: en, ru
      static func walletSearchEmptyTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.search.empty.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.search.empty.title"
        }

        return NSLocalizedString("wallet.search.empty.title", bundle: bundle, comment: "")
      }

      /// en translation: Make sure you have exported your account before proceeding.
      ///
      /// Locales: en, ru
      static func accountDeleteConfirmationDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.delete.confirmation.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.delete.confirmation.description"
        }

        return NSLocalizedString("account.delete.confirmation.description", bundle: bundle, comment: "")
      }

      /// en translation: Make sure you have exported your wallet before proceeding.
      ///
      /// Locales: en, ru
      static func walletDeleteConfirmationDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.delete.confirmation.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.delete.confirmation.description"
        }

        return NSLocalizedString("wallet.delete.confirmation.description", bundle: bundle, comment: "")
      }

      /// en translation: Manage
      ///
      /// Locales: en, ru
      static func stakingManageTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.manage.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.manage.title"
        }

        return NSLocalizedString("staking.manage.title", bundle: bundle, comment: "")
      }

      /// en translation: Manage assets
      ///
      /// Locales: en, ru
      static func walletManageAssetsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.manage.assets.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.manage.assets.title"
        }

        return NSLocalizedString("wallet.manage.assets.title", bundle: bundle, comment: "")
      }

      /// en translation: Maximum APY
      ///
      /// Locales: en, ru
      static func stakingRewardInfoMax(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.info.max", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.info.max"
        }

        return NSLocalizedString("staking.reward.info.max", bundle: bundle, comment: "")
      }

      /// en translation: Maximum number of nominators has been reached
      ///
      /// Locales: en, ru
      static func stakingMaxNominatorsReachedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.max.nominators.reached.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.max.nominators.reached.message"
        }

        return NSLocalizedString("staking.max.nominators.reached.message", bundle: bundle, comment: "")
      }

      /// en translation: Minimal balance
      ///
      /// Locales: en, ru
      static func walletSendBalanceMinimal(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.balance.minimal", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.balance.minimal"
        }

        return NSLocalizedString("wallet.send.balance.minimal", bundle: bundle, comment: "")
      }

      /// en translation: Minimum stake
      ///
      /// Locales: en, ru
      static func stakingMainMinimumStakeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.main.minimum.stake.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.main.minimum.stake.title"
        }

        return NSLocalizedString("staking.main.minimum.stake.title", bundle: bundle, comment: "")
      }

      /// en translation: Mnemonic Passphrase
      ///
      /// Locales: en, ru
      static func accountBackupMnemonicFieldTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.backup.mnemonic.field.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.backup.mnemonic.field.title"
        }

        return NSLocalizedString("account.backup.mnemonic.field.title", bundle: bundle, comment: "")
      }

      /// en translation: Mnemonic is used to recover access to account. Write it down, we will not be able to recover your account without it!
      ///
      /// Locales: en, ru
      static func accountCreationInfo(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.creation.info", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.creation.info"
        }

        return NSLocalizedString("account.creation.info", bundle: bundle, comment: "")
      }

      /// en translation: Mnemonic must contain 24 words at max
      ///
      /// Locales: en, ru
      static func accessRestoreWordsErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("access.restore.words.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "access.restore.words.error.message"
        }

        return NSLocalizedString("access.restore.words.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Mnemonic passphrase
      ///
      /// Locales: en, ru
      static func importMnemonic(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.mnemonic", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.mnemonic"
        }

        return NSLocalizedString("import.mnemonic", bundle: bundle, comment: "")
      }

      /// en translation: Mnemonic phrase
      ///
      /// Locales: en, ru
      static func secretTypeMnemonicTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.mnemonic.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.mnemonic.title"
        }

        return NSLocalizedString("secret.type.mnemonic.title", bundle: bundle, comment: "")
      }

      /// en translation: Module
      ///
      /// Locales: en, ru
      static func commonModule(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.module", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.module"
        }

        return NSLocalizedString("common.module", bundle: bundle, comment: "")
      }

      /// en translation: Monthly
      ///
      /// Locales: en, ru
      static func stakingMonthPeriodTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.month.period.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.month.period.title"
        }

        return NSLocalizedString("staking.month.period.title", bundle: bundle, comment: "")
      }

      /// en translation: Moonbeam account is missing
      ///
      /// Locales: en, ru
      static func crowdloanMoonbeamMissingAccountTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.moonbeam.missing.account.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.moonbeam.missing.account.title"
        }

        return NSLocalizedString("crowdloan.moonbeam.missing.account.title", bundle: bundle, comment: "")
      }

      /// en translation: Moonbeams Terms & Conditions
      ///
      /// Locales: en, ru
      static func crowdloanMoonbeamTermsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.moonbeam.terms.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.moonbeam.terms.title"
        }

        return NSLocalizedString("crowdloan.moonbeam.terms.title", bundle: bundle, comment: "")
      }

      /// en translation: More about rewards
      ///
      /// Locales: en, ru
      static func stakingRewardsLearnMore_2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rewards.learn.more_2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rewards.learn.more_2_2_0"
        }

        return NSLocalizedString("staking.rewards.learn.more_2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Most profitable
      ///
      /// Locales: en, ru
      static func stakingRecommendedHint1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.hint1", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.hint1"
        }

        return NSLocalizedString("staking.recommended.hint1", bundle: bundle, comment: "")
      }

      /// en translation: My %@ address to receive %@:
      ///
      /// Locales: en, ru
      static func walletReceiveShareMessage(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("wallet.receive.share.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.receive.share.message"
        }

        let format = NSLocalizedString("wallet.receive.share.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Name
      ///
      /// Locales: en, ru
      static func accountInfoNameTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.info.name.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.info.name.title"
        }

        return NSLocalizedString("account.info.name.title", bundle: bundle, comment: "")
      }

      /// en translation: Name
      ///
      /// Locales: en, ru
      static func accountUsernameSetupChooseTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.username.setup.choose.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.username.setup.choose.title"
        }

        return NSLocalizedString("account.username.setup.choose.title", bundle: bundle, comment: "")
      }

      /// en translation: Name examples: Main account, My validator, Dotsama crowdloans, etc.
      ///
      /// Locales: en, ru
      static func walletNicknameCreateCaption_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.nickname.create.caption_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.nickname.create.caption_v2_2_0"
        }

        return NSLocalizedString("wallet.nickname.create.caption_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Name will be used only locally in this application. You can edit it later
      ///
      /// Locales: en, ru
      static func walletNicknameCreateSubtitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.nickname.create.subtitle_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.nickname.create.subtitle_v2_2_0"
        }

        return NSLocalizedString("wallet.nickname.create.subtitle_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Network
      ///
      /// Locales: en, ru
      static func commonNetwork(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.network", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.network"
        }

        return NSLocalizedString("common.network", bundle: bundle, comment: "")
      }

      /// en translation: Network fee
      ///
      /// Locales: en, ru
      static func commonNetworkFee(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.network.fee", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.network.fee"
        }

        return NSLocalizedString("common.network.fee", bundle: bundle, comment: "")
      }

      /// en translation: Network in JSON does not match selected one. The latter will be used to import an account.
      ///
      /// Locales: en, ru
      static func accountImportWrongNetwork(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.wrong.network", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.wrong.network"
        }

        return NSLocalizedString("account.import.wrong.network", bundle: bundle, comment: "")
      }

      /// en translation: Network: %@ Mnemonic: %@
      ///
      /// Locales: en, ru
      static func exportMnemonicWithoutDpTemplate(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("export.mnemonic.without.dp.template", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.mnemonic.without.dp.template"
        }

        let format = NSLocalizedString("export.mnemonic.without.dp.template", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Network: %@ Mnemonic: %@ Derivation path: %@
      ///
      /// Locales: en, ru
      static func exportMnemonicWithDpTemplate(_ value1: String, _ value2: String, _ value3: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("export.mnemonic.with.dp.template", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2, value3)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.mnemonic.with.dp.template"
        }

        let format = NSLocalizedString("export.mnemonic.with.dp.template", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2, value3)
      }

      /// en translation: Network: %@ Seed: %@
      ///
      /// Locales: en, ru
      static func exportSeedWithoutDpTemplate(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("export.seed.without.dp.template", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.seed.without.dp.template"
        }

        let format = NSLocalizedString("export.seed.without.dp.template", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Network: %@ Seed: %@ Derivation path: %@
      ///
      /// Locales: en, ru
      static func exportSeedWithDpTemplate(_ value1: String, _ value2: String, _ value3: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("export.seed.with.dp.template", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2, value3)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.seed.with.dp.template"
        }

        let format = NSLocalizedString("export.seed.with.dp.template", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2, value3)
      }

      /// en translation: Networks
      ///
      /// Locales: en, ru
      static func connectionManagementTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.management.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.management.title"
        }

        return NSLocalizedString("connection.management.title", bundle: bundle, comment: "")
      }

      /// en translation: Next
      ///
      /// Locales: en, ru
      static func commonNext(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.next", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.next"
        }

        return NSLocalizedString("common.next", bundle: bundle, comment: "")
      }

      /// en translation: No data retrieved.
      ///
      /// Locales: en, ru
      static func commonErrorNoDataRetrieved(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.error.no.data.retrieved", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.error.no.data.retrieved"
        }

        return NSLocalizedString("common.error.no.data.retrieved", bundle: bundle, comment: "")
      }

      /// en translation: No redeemable tokens found
      ///
      /// Locales: en, ru
      static func stakingRedeemNoTokensMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.redeem.no.tokens.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.redeem.no.tokens.message"
        }

        return NSLocalizedString("staking.redeem.no.tokens.message", bundle: bundle, comment: "")
      }

      /// en translation: No search results. Be sure you typed full account address
      ///
      /// Locales: en, ru
      static func stakingValidatorSearchEmptyTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.search.empty.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.search.empty.title"
        }

        return NSLocalizedString("staking.validator.search.empty.title", bundle: bundle, comment: "")
      }

      /// en translation: Node Info
      ///
      /// Locales: en, ru
      static func networkInfoTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("network.info.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "network.info.title"
        }

        return NSLocalizedString("network.info.title", bundle: bundle, comment: "")
      }

      /// en translation: Node address
      ///
      /// Locales: en, ru
      static func networkInfoAddress(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("network.info.address", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "network.info.address"
        }

        return NSLocalizedString("network.info.address", bundle: bundle, comment: "")
      }

      /// en translation: Node name
      ///
      /// Locales: en, ru
      static func networkInfoName(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("network.info.name", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "network.info.name"
        }

        return NSLocalizedString("network.info.name", bundle: bundle, comment: "")
      }

      /// en translation: Nominated: 
      ///
      /// Locales: en, ru
      static func stakingYourNominatedPrefix(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.nominated.prefix", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.nominated.prefix"
        }

        return NSLocalizedString("staking.your.nominated.prefix", bundle: bundle, comment: "")
      }

      /// en translation: Nominated: %@
      ///
      /// Locales: en, ru
      static func stakingYourNominatedFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.your.nominated.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.nominated.format"
        }

        let format = NSLocalizedString("staking.your.nominated.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Nominator earns passive income by locking his tokens for securing the network. To achieve that, the nominator should select a number of validators to support. The nominator should be careful when selecting validators. If selected validator wont behave properly, slashing penalties would be applied to both of them, based on the severity of the incident.
      ///
      /// Locales: en, ru
      static func stakingStoryNominatorPage1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.nominator.page.1", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.nominator.page.1"
        }

        return NSLocalizedString("staking.story.nominator.page.1", bundle: bundle, comment: "")
      }

      /// en translation: Nominators
      ///
      /// Locales: en, ru
      static func stakingValidatorNominators(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.nominators", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.nominators"
        }

        return NSLocalizedString("staking.validator.nominators", bundle: bundle, comment: "")
      }

      /// en translation: None of your validators have been elected by network.
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusAlertNoValidators(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.alert.no.validators", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.alert.no.validators"
        }

        return NSLocalizedString("staking.nominator.status.alert.no.validators", bundle: bundle, comment: "")
      }

      /// en translation: Not elected
      ///
      /// Locales: en, ru
      static func stakingValidatorStatusUnelected(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.status.unelected", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.status.unelected"
        }

        return NSLocalizedString("staking.validator.status.unelected", bundle: bundle, comment: "")
      }

      /// en translation: Not elected (%@)
      ///
      /// Locales: en, ru
      static func stakingYourNotElectedFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.your.not.elected.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.not.elected.format"
        }

        let format = NSLocalizedString("staking.your.not.elected.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Not listed
      ///
      /// Locales: en, ru
      static func nftListNotListed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("nft.list.not.listed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "nft.list.not.listed"
        }

        return NSLocalizedString("nft.list.not.listed", bundle: bundle, comment: "")
      }

      /// en translation: Not now
      ///
      /// Locales: en, ru
      static func commonNotNow(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.not.now", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.not.now"
        }

        return NSLocalizedString("common.not.now", bundle: bundle, comment: "")
      }

      /// en translation: Not oversubscribed
      ///
      /// Locales: en, ru
      static func stakingRecommendedHint2(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.hint2", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.hint2"
        }

        return NSLocalizedString("staking.recommended.hint2", bundle: bundle, comment: "")
      }

      /// en translation: Not slashed
      ///
      /// Locales: en, ru
      static func stakingRecommendedHint4(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.hint4", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.hint4"
        }

        return NSLocalizedString("staking.recommended.hint4", bundle: bundle, comment: "")
      }

      /// en translation: Nova Wallet believes that this website could compromise the security of your accounts and your tokens
      ///
      /// Locales: en, ru
      static func dappPhishingMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.phishing.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.phishing.message"
        }

        return NSLocalizedString("dapp.phishing.message", bundle: bundle, comment: "")
      }

      /// en translation: Nova Wallet bonus (%@)
      ///
      /// Locales: en, ru
      static func crowdloanAppBonusFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.app.bonus.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.app.bonus.format"
        }

        let format = NSLocalizedString("crowdloan.app.bonus.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Nova Wallet created a list of recommended validators based on blockchain data and with the following criteria:
      ///
      /// Locales: en, ru
      static func stakingSelectValidatorsRecommendedDesc_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.select.validators.recommended.desc_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.select.validators.recommended.desc_v2_2_0"
        }

        return NSLocalizedString("staking.select.validators.recommended.desc_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Nova Wallet provides a support for nominators by helping them to select validators. The mobile app fetches data from the blockchain and composes a list of validators, which have: most profits, identity with contact info, not slashed and available to receive nominations. Nova Wallet also cares about decentralization, so if one person or a company runs several validator nodes, only up to 2 nodes from them will be shown in the recommended list.
      ///
      /// Locales: en, ru
      static func stakingStoryNominatorPage2(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.nominator.page.2", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.nominator.page.2"
        }

        return NSLocalizedString("staking.story.nominator.page.2", bundle: bundle, comment: "")
      }

      /// en translation: Nova Wallet will select the top validators based on security and profitability criteria
      ///
      /// Locales: en, ru
      static func stakingRecommendedBannerMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.banner.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.banner.message"
        }

        return NSLocalizedString("staking.recommended.banner.message", bundle: bundle, comment: "")
      }

      /// en translation: Nova support
      ///
      /// Locales: en, ru
      static func helpSupportTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("help.support.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "help.support.title"
        }

        return NSLocalizedString("help.support.title", bundle: bundle, comment: "")
      }

      /// en translation: Nova wallet will change rewards destination  to your account to avoid remaining stake.
      ///
      /// Locales: en, ru
      static func stakingHintUnbondKillsStash(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.unbond.kills.stash", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.unbond.kills.stash"
        }

        return NSLocalizedString("staking.hint.unbond.kills.stash", bundle: bundle, comment: "")
      }

      /// en translation: OK
      ///
      /// Locales: en, ru
      static func commonOk(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.ok", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.ok"
        }

        return NSLocalizedString("common.ok", bundle: bundle, comment: "")
      }

      /// en translation: Okay, take me back
      ///
      /// Locales: en, ru
      static func dappPhishingAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.phishing.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.phishing.action"
        }

        return NSLocalizedString("dapp.phishing.action", bundle: bundle, comment: "")
      }

      /// en translation: One of your validators have been elected by network.
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusAlertActiveMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.alert.active.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.alert.active.message"
        }

        return NSLocalizedString("staking.nominator.status.alert.active.message", bundle: bundle, comment: "")
      }

      /// en translation: Open settings
      ///
      /// Locales: en, ru
      static func commonOpenSettings(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.open.settings", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.open.settings"
        }

        return NSLocalizedString("common.open.settings", bundle: bundle, comment: "")
      }

      /// en translation: Operation Failed
      ///
      /// Locales: en, ru
      static func operationErrorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("operation.error.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "operation.error.title"
        }

        return NSLocalizedString("operation.error.title", bundle: bundle, comment: "")
      }

      /// en translation: Operation will remove account
      ///
      /// Locales: en, ru
      static func commonExistentialWarningTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.existential.warning.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.existential.warning.title"
        }

        return NSLocalizedString("common.existential.warning.title", bundle: bundle, comment: "")
      }

      /// en translation: Operation will remove account from blockstore since it will make total balance lower than minimal balance.
      ///
      /// Locales: en, ru
      static func commonExistentialWarningMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.existential.warning.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.existential.warning.message"
        }

        return NSLocalizedString("common.existential.warning.message", bundle: bundle, comment: "")
      }

      /// en translation: Other transactions
      ///
      /// Locales: en, ru
      static func walletFiltersExtrinsics(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.filters.extrinsics", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.filters.extrinsics"
        }

        return NSLocalizedString("wallet.filters.extrinsics", bundle: bundle, comment: "")
      }

      /// en translation: Others, who are active without your stake allocation.
      ///
      /// Locales: en, ru
      static func stakingYourNotAllocatedDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.not.allocated.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.not.allocated.description"
        }

        return NSLocalizedString("staking.your.not.allocated.description", bundle: bundle, comment: "")
      }

      /// en translation: Oversubscribed. Only the top staked nominators are paid rewards.
      ///
      /// Locales: en, ru
      static func stakingValidatorOtherOversubscribedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.other.oversubscribed.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.other.oversubscribed.message"
        }

        return NSLocalizedString("staking.validator.other.oversubscribed.message", bundle: bundle, comment: "")
      }

      /// en translation: Oversubscribed. You will not receive rewards from the validator in this era.
      ///
      /// Locales: en, ru
      static func stakingValidatorMyOversubscribedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.my.oversubscribed.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.my.oversubscribed.message"
        }

        return NSLocalizedString("staking.validator.my.oversubscribed.message", bundle: bundle, comment: "")
      }

      /// en translation: Own
      ///
      /// Locales: en, ru
      static func stakingValidatorOwnStake(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.own.stake", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.own.stake"
        }

        return NSLocalizedString("staking.validator.own.stake", bundle: bundle, comment: "")
      }

      /// en translation: Owned by
      ///
      /// Locales: en, ru
      static func nftOwnerTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("nft.owner.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "nft.owner.title"
        }

        return NSLocalizedString("nft.owner.title", bundle: bundle, comment: "")
      }

      /// en translation: Password
      ///
      /// Locales: en, ru
      static func accountImportPasswordPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.password.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.password.placeholder"
        }

        return NSLocalizedString("account.import.password.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Password is required to encrypt your account and store as Restore JSON. Please, create password to continue operation.
      ///
      /// Locales: en, ru
      static func accountExportJsonHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.export.json.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.export.json.hint"
        }

        return NSLocalizedString("account.export.json.hint", bundle: bundle, comment: "")
      }

      /// en translation: Passwords do not match
      ///
      /// Locales: en, ru
      static func commonErrorPasswordMismatch(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.error.password.mismatch", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.error.password.mismatch"
        }

        return NSLocalizedString("common.error.password.mismatch", bundle: bundle, comment: "")
      }

      /// en translation: Paste
      ///
      /// Locales: en, ru
      static func commonPaste(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.paste", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.paste"
        }

        return NSLocalizedString("common.paste", bundle: bundle, comment: "")
      }

      /// en translation: Paste json
      ///
      /// Locales: en, ru
      static func accountImportRecoveryJsonPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.recovery.json.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.recovery.json.placeholder"
        }

        return NSLocalizedString("account.import.recovery.json.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Paste json or upload file
      ///
      /// Locales: en, ru
      static func recoverJsonHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("recover.json.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "recover.json.hint"
        }

        return NSLocalizedString("recover.json.hint", bundle: bundle, comment: "")
      }

      /// en translation: Payout
      ///
      /// Locales: en, ru
      static func stakingPayoutTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.payout.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.payout.title"
        }

        return NSLocalizedString("staking.payout.title", bundle: bundle, comment: "")
      }

      /// en translation: Payout
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsPayout(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.payout", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.payout"
        }

        return NSLocalizedString("staking.reward.details.payout", bundle: bundle, comment: "")
      }

      /// en translation: Payout account
      ///
      /// Locales: en, ru
      static func stakingRewardPayoutAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.payout.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.payout.account"
        }

        return NSLocalizedString("staking.reward.payout.account", bundle: bundle, comment: "")
      }

      /// en translation: Payout all (%@)
      ///
      /// Locales: en, ru
      static func stakingRewardPayoutsPayoutAll(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.reward.payouts.payout.all", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.payouts.payout.all"
        }

        let format = NSLocalizedString("staking.reward.payouts.payout.all", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Payout all rewards
      ///
      /// Locales: en, ru
      static func stakingPendingRewardsPayoutAll(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards.payout.all", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards.payout.all"
        }

        return NSLocalizedString("staking.pending.rewards.payout.all", bundle: bundle, comment: "")
      }

      /// en translation: Payout expired
      ///
      /// Locales: en, ru
      static func stakingPayoutExpired(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.payout.expired", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.payout.expired"
        }

        return NSLocalizedString("staking.payout.expired", bundle: bundle, comment: "")
      }

      /// en translation: Payout transaction sent
      ///
      /// Locales: en, ru
      static func stakingPayoutSent(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.payout.sent", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.payout.sent"
        }

        return NSLocalizedString("staking.payout.sent", bundle: bundle, comment: "")
      }

      /// en translation: Pending
      ///
      /// Locales: en, ru
      static func transactionStatusPending(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.status.pending", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.status.pending"
        }

        return NSLocalizedString("transaction.status.pending", bundle: bundle, comment: "")
      }

      /// en translation: Pending rewards
      ///
      /// Locales: en, ru
      static func stakingPendingRewards(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards"
        }

        return NSLocalizedString("staking.pending.rewards", bundle: bundle, comment: "")
      }

      /// en translation: Pending rewards
      ///
      /// Locales: en, ru
      static func stakingRewardPayoutsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.payouts.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.payouts.title"
        }

        return NSLocalizedString("staking.reward.payouts.title", bundle: bundle, comment: "")
      }

      /// en translation: Perfect! All rewards are paid.
      ///
      /// Locales: en, ru
      static func stakingRewardPayoutsEmptyRewards(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.payouts.empty.rewards", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.payouts.empty.rewards"
        }

        return NSLocalizedString("staking.reward.payouts.empty.rewards", bundle: bundle, comment: "")
      }

      /// en translation: Phishing detected
      ///
      /// Locales: en, ru
      static func dappPhishingTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.phishing.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.phishing.title"
        }

        return NSLocalizedString("dapp.phishing.title", bundle: bundle, comment: "")
      }

      /// en translation: Photos Access
      ///
      /// Locales: en, ru
      static func qrScanErrorGalleryTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.gallery.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.gallery.title"
        }

        return NSLocalizedString("qr.scan.error.gallery.title", bundle: bundle, comment: "")
      }

      /// en translation: Please make sure to write down your phrase correctly and legibly.
      ///
      /// Locales: en, ru
      static func accountBackupMnemonicCaption(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.backup.mnemonic.caption", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.backup.mnemonic.caption"
        }

        return NSLocalizedString("account.backup.mnemonic.caption", bundle: bundle, comment: "")
      }

      /// en translation: Please wait for the next era to start.
      ///
      /// Locales: en, ru
      static func stakingAlertStartNextEraMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.alert.start.next.era.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.alert.start.next.era.message"
        }

        return NSLocalizedString("staking.alert.start.next.era.message", bundle: bundle, comment: "")
      }

      /// en translation: Please wait until fee is calculated
      ///
      /// Locales: en, ru
      static func feeNotYetLoadedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("fee.not.yet.loaded.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "fee.not.yet.loaded.message"
        }

        return NSLocalizedString("fee.not.yet.loaded.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check internet connection and try again later.
      ///
      /// Locales: en, ru
      static func connectionErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.error.message"
        }

        return NSLocalizedString("connection.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check order of the words one more time.
      ///
      /// Locales: en, ru
      static func confirmMnemonicMismatchErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("confirm.mnemonic.mismatch.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "confirm.mnemonic.mismatch.error.message"
        }

        return NSLocalizedString("confirm.mnemonic.mismatch.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check password correctness and try again.
      ///
      /// Locales: en, ru
      static func accountImportKeystoreDecryptionErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.keystore.decryption.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.keystore.decryption.error.message"
        }

        return NSLocalizedString("account.import.keystore.decryption.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of characters not including /.
      ///
      /// Locales: en, ru
      static func commonInvalidHardSoftMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.hard.soft.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.hard.soft.message"
        }

        return NSLocalizedString("common.invalid.hard.soft.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of characters not including /. The path can end up with ///'password'. For example, //1/nova///mypass.
      ///
      /// Locales: en, ru
      static func commonInvalidPathWithSoftMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.path.with.soft.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.path.with.soft.message"
        }

        return NSLocalizedString("common.invalid.path.with.soft.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of digits not including /. For example, //44//60//0/0/0
      ///
      /// Locales: en, ru
      static func commonInvalidHardSoftNumericMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.hard.soft.numeric.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.hard.soft.numeric.message"
        }

        return NSLocalizedString("common.invalid.hard.soft.numeric.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check that input is a mix of //'hard' and /'soft' where 'hard' and 'soft' can be any sequence of digits not including /. The path can end up with ///'password'. For example, //44//60//0/0/0///mypass.
      ///
      /// Locales: en, ru
      static func commonInvalidHardSoftNumericPasswordMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.hard.soft.numeric.password.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.hard.soft.numeric.password.message"
        }

        return NSLocalizedString("common.invalid.hard.soft.numeric.password.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check that input is a mix of //'hard' where 'hard' can be any sequence of characters not including /.
      ///
      /// Locales: en, ru
      static func commonInvalidHardMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.hard.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.hard.message"
        }

        return NSLocalizedString("common.invalid.hard.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check that input is a mix of //'hard' where 'hard' can be any sequence of characters not including /. The path can end up with ///'password'. For example, //1//nova///mypass.
      ///
      /// Locales: en, ru
      static func commonInvalidPathWithoutSoftMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.path.without.soft.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.path.without.soft.message"
        }

        return NSLocalizedString("common.invalid.path.without.soft.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, check your connection or try again later
      ///
      /// Locales: en, ru
      static func connectionErrorMessage_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.error.message_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.error.message_v2_2_0"
        }

        return NSLocalizedString("connection.error.message_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Please, make sure that the mail application is installed on the device.
      ///
      /// Locales: en, ru
      static func noEmailBoundErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("no.email.bound.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "no.email.bound.error.message"
        }

        return NSLocalizedString("no.email.bound.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, make sure to write down your phrase correctly  and legibly
      ///
      /// Locales: en, ru
      static func exportMnemonicCheckHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.mnemonic.check.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.mnemonic.check.hint"
        }

        return NSLocalizedString("export.mnemonic.check.hint", bundle: bundle, comment: "")
      }

      /// en translation: Please, make sure to write down your secret correctly and legibly
      ///
      /// Locales: en, ru
      static func exportSeedHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.seed.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.seed.hint"
        }

        return NSLocalizedString("export.seed.hint", bundle: bundle, comment: "")
      }

      /// en translation: Please, try again later
      ///
      /// Locales: en, ru
      static func operationErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("operation.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "operation.error.message"
        }

        return NSLocalizedString("operation.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Please, try again with another input. If the error appears again, please, contact support.
      ///
      /// Locales: en, ru
      static func commonUndefinedErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.undefined.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.undefined.error.message"
        }

        return NSLocalizedString("common.undefined.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Preferences
      ///
      /// Locales: en, ru
      static func settingsPreferences(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.preferences", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.preferences"
        }

        return NSLocalizedString("settings.preferences", bundle: bundle, comment: "")
      }

      /// en translation: Price
      ///
      /// Locales: en, ru
      static func commonPrice(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.price", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.price"
        }

        return NSLocalizedString("common.price", bundle: bundle, comment: "")
      }

      /// en translation: Privacy Policy
      ///
      /// Locales: en, ru
      static func onboardingPrivacyPolicy(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.privacy.policy", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.privacy.policy"
        }

        return NSLocalizedString("onboarding.privacy.policy", bundle: bundle, comment: "")
      }

      /// en translation: Privacy policy
      ///
      /// Locales: en, ru
      static func aboutPrivacy(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.privacy", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.privacy"
        }

        return NSLocalizedString("about.privacy", bundle: bundle, comment: "")
      }

      /// en translation: Private crowdloan
      ///
      /// Locales: en, ru
      static func crowdloanPrivateCrowdloanTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.private.crowdloan.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.private.crowdloan.title"
        }

        return NSLocalizedString("crowdloan.private.crowdloan.title", bundle: bundle, comment: "")
      }

      /// en translation: Private crowdloans are not yet supported.
      ///
      /// Locales: en, ru
      static func crowdloanPrivateCrowdloanMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.private.crowdloan.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.private.crowdloan.message"
        }

        return NSLocalizedString("crowdloan.private.crowdloan.message", bundle: bundle, comment: "")
      }

      /// en translation: Proceed
      ///
      /// Locales: en, ru
      static func commonProceed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.proceed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.proceed"
        }

        return NSLocalizedString("common.proceed", bundle: bundle, comment: "")
      }

      /// en translation: Provide your Restore JSON
      ///
      /// Locales: en, ru
      static func walletImportKeystoreTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.keystore.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.keystore.title"
        }

        return NSLocalizedString("wallet.import.keystore.title", bundle: bundle, comment: "")
      }

      /// en translation: Provide your Restore JSON...
      ///
      /// Locales: en, ru
      static func walletImportNoJsonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.no.json.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.no.json.title"
        }

        return NSLocalizedString("wallet.import.no.json.title", bundle: bundle, comment: "")
      }

      /// en translation: Purchase initiated! Please wait up to 60 minutes. You can track status on the email.
      ///
      /// Locales: en, ru
      static func buyCompleted(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("buy.completed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "buy.completed"
        }

        return NSLocalizedString("buy.completed", bundle: bundle, comment: "")
      }

      /// en translation: QR can't be decoded
      ///
      /// Locales: en, ru
      static func qrScanErrorNoInfo(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.no.info", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.no.info"
        }

        return NSLocalizedString("qr.scan.error.no.info", bundle: bundle, comment: "")
      }

      /// en translation: Raised
      ///
      /// Locales: en, ru
      static func crowdloanRaised(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.raised", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.raised"
        }

        return NSLocalizedString("crowdloan.raised", bundle: bundle, comment: "")
      }

      /// en translation: Raised: %@ of %@
      ///
      /// Locales: en, ru
      static func crowdloanProgressFormat(_ value1: String, _ value2: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.progress.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.progress.format"
        }

        let format = NSLocalizedString("crowdloan.progress.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Rate us
      ///
      /// Locales: en, ru
      static func settingsRateUs(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.rate.us", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.rate.us"
        }

        return NSLocalizedString("settings.rate.us", bundle: bundle, comment: "")
      }

      /// en translation: Raw seed
      ///
      /// Locales: en, ru
      static func importRawSeed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.raw.seed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.raw.seed"
        }

        return NSLocalizedString("import.raw.seed", bundle: bundle, comment: "")
      }

      /// en translation: Raw seed
      ///
      /// Locales: en, ru
      static func secretTypeSeedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.seed.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.seed.title"
        }

        return NSLocalizedString("secret.type.seed.title", bundle: bundle, comment: "")
      }

      /// en translation: Raw seed: 128 hex symbols
      ///
      /// Locales: en, ru
      static func accountImportEthereumSeedPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.ethereum.seed.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.ethereum.seed.placeholder"
        }

        return NSLocalizedString("account.import.ethereum.seed.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Raw seed: 64 hex symbols
      ///
      /// Locales: en, ru
      static func accountImportSubstrateSeedPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.substrate.seed.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.substrate.seed.placeholder"
        }

        return NSLocalizedString("account.import.substrate.seed.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Rebond custom amount
      ///
      /// Locales: en, ru
      static func stakingRebondCustomAmount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond.custom.amount", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond.custom.amount"
        }

        return NSLocalizedString("staking.rebond.custom.amount", bundle: bundle, comment: "")
      }

      /// en translation: Receive
      ///
      /// Locales: en, ru
      static func walletAssetReceive(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.asset.receive", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.asset.receive"
        }

        return NSLocalizedString("wallet.asset.receive", bundle: bundle, comment: "")
      }

      /// en translation: Receive %@
      ///
      /// Locales: en, ru
      static func walletReceiveTitleFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("wallet.receive.title.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.receive.title.format"
        }

        let format = NSLocalizedString("wallet.receive.title.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Received
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsStatusReceived(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.status.received", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.status.received"
        }

        return NSLocalizedString("staking.reward.details.status.received", bundle: bundle, comment: "")
      }

      /// en translation: Receiving rewards
      ///
      /// Locales: en, ru
      static func stakingStoryRewardTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.reward.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.reward.title"
        }

        return NSLocalizedString("staking.story.reward.title", bundle: bundle, comment: "")
      }

      /// en translation: Recipient
      ///
      /// Locales: en, ru
      static func commonRecipient(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.recipient", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.recipient"
        }

        return NSLocalizedString("common.recipient", bundle: bundle, comment: "")
      }

      /// en translation: Recipient is not able to accept transfer
      ///
      /// Locales: en, ru
      static func walletSendDeadRecipientCommissionAssetTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.dead.recipient.commission.asset.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.dead.recipient.commission.asset.title"
        }

        return NSLocalizedString("wallet.send.dead.recipient.commission.asset.title", bundle: bundle, comment: "")
      }

      /// en translation: Recipient should be a valid %@ address
      ///
      /// Locales: en, ru
      static func commonValidationInvalidAddressMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.validation.invalid.address.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.validation.invalid.address.message"
        }

        let format = NSLocalizedString("common.validation.invalid.address.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Recipient's address must differ from sender
      ///
      /// Locales: en, ru
      static func commonSameReceiveAddressMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.same.receive.address.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.same.receive.address.message"
        }

        return NSLocalizedString("common.same.receive.address.message", bundle: bundle, comment: "")
      }

      /// en translation: Recommended validators
      ///
      /// Locales: en, ru
      static func stakingRecommendedSectionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.section.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.section.title"
        }

        return NSLocalizedString("staking.recommended.section.title", bundle: bundle, comment: "")
      }

      /// en translation: Redeem
      ///
      /// Locales: en, ru
      static func stakingRedeem(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.redeem", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.redeem"
        }

        return NSLocalizedString("staking.redeem", bundle: bundle, comment: "")
      }

      /// en translation: Redeem unstaked tokens.
      ///
      /// Locales: en, ru
      static func stakingRedeemUnbondedTokens(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.redeem.unbonded.tokens", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.redeem.unbonded.tokens"
        }

        return NSLocalizedString("staking.redeem.unbonded.tokens", bundle: bundle, comment: "")
      }

      /// en translation: Redeemable
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsStatusClaimable(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.status.claimable", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.status.claimable"
        }

        return NSLocalizedString("staking.reward.details.status.claimable", bundle: bundle, comment: "")
      }

      /// en translation: Redeemable
      ///
      /// Locales: en, ru
      static func walletBalanceRedeemable(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.redeemable", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.redeemable"
        }

        return NSLocalizedString("wallet.balance.redeemable", bundle: bundle, comment: "")
      }

      /// en translation: Redeemable: %@
      ///
      /// Locales: en, ru
      static func stakingRedeemableFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.redeemable.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.redeemable.format"
        }

        let format = NSLocalizedString("staking.redeemable.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Referral code
      ///
      /// Locales: en, ru
      static func commonReferralCodeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.referral.code.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.referral.code.title"
        }

        return NSLocalizedString("common.referral.code.title", bundle: bundle, comment: "")
      }

      /// en translation: Referral code is invalid. Please, try another one
      ///
      /// Locales: en, ru
      static func crowdloanReferralCodeInvalid(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.referral.code.invalid", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.referral.code.invalid"
        }

        return NSLocalizedString("crowdloan.referral.code.invalid", bundle: bundle, comment: "")
      }

      /// en translation: Referral code verification failed. Please, try again later.
      ///
      /// Locales: en, ru
      static func crowdloanReferralCodeInternal(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.referral.code.internal", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.referral.code.internal"
        }

        return NSLocalizedString("crowdloan.referral.code.internal", bundle: bundle, comment: "")
      }

      /// en translation: Reject
      ///
      /// Locales: en, ru
      static func commonReject(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.reject", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.reject"
        }

        return NSLocalizedString("common.reject", bundle: bundle, comment: "")
      }

      /// en translation: Reload
      ///
      /// Locales: en, ru
      static func commonReload(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.reload", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.reload"
        }

        return NSLocalizedString("common.reload", bundle: bundle, comment: "")
      }

      /// en translation: Remaining staking balance will drop under minimum value and also will be added to unstaking amount
      ///
      /// Locales: en, ru
      static func stakingUnbondingAllMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.all.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.all.message"
        }

        return NSLocalizedString("staking.unbonding.all.message", bundle: bundle, comment: "")
      }

      /// en translation: Remove
      ///
      /// Locales: en, ru
      static func commonRemove(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.remove", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.remove"
        }

        return NSLocalizedString("common.remove", bundle: bundle, comment: "")
      }

      /// en translation: Remove from Authorized?
      ///
      /// Locales: en, ru
      static func dappRemoveAuthorizedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.remove.authorized.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.remove.authorized.title"
        }

        return NSLocalizedString("dapp.remove.authorized.title", bundle: bundle, comment: "")
      }

      /// en translation: Remove from Favorites?
      ///
      /// Locales: en, ru
      static func dappRemoveFavoritesTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.remove.favorites.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.remove.favorites.title"
        }

        return NSLocalizedString("dapp.remove.favorites.title", bundle: bundle, comment: "")
      }

      /// en translation: Reserved
      ///
      /// Locales: en, ru
      static func walletBalanceReserved(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.reserved", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.reserved"
        }

        return NSLocalizedString("wallet.balance.reserved", bundle: bundle, comment: "")
      }

      /// en translation: Reset
      ///
      /// Locales: en, ru
      static func commonReset(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.reset", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.reset"
        }

        return NSLocalizedString("common.reset", bundle: bundle, comment: "")
      }

      /// en translation: Restake
      ///
      /// Locales: en, ru
      static func stakingRestakeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.restake.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.restake.title"
        }

        return NSLocalizedString("staking.restake.title", bundle: bundle, comment: "")
      }

      /// en translation: Restake
      ///
      /// Locales: en, ru
      static func stakingSetupRestakeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.setup.restake.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.restake.title"
        }

        return NSLocalizedString("staking.setup.restake.title", bundle: bundle, comment: "")
      }

      /// en translation: Restake rewards
      ///
      /// Locales: en, ru
      static func stakingRestakeTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.restake.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.restake.title_v2_2_0"
        }

        return NSLocalizedString("staking.restake.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Restake rewards
      ///
      /// Locales: en, ru
      static func stakingSetupRestakeTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.setup.restake.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.restake.title_v2_2_0"
        }

        return NSLocalizedString("staking.setup.restake.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Restore JSON
      ///
      /// Locales: en, ru
      static func importRecoveryJson(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.recovery.json", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.recovery.json"
        }

        return NSLocalizedString("import.recovery.json", bundle: bundle, comment: "")
      }

      /// en translation: Restore JSON
      ///
      /// Locales: en, ru
      static func secretTypeKeystoreTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.keystore.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.keystore.title"
        }

        return NSLocalizedString("secret.type.keystore.title", bundle: bundle, comment: "")
      }

      /// en translation: Retry
      ///
      /// Locales: en, ru
      static func commonRetry(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.retry", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.retry"
        }

        return NSLocalizedString("common.retry", bundle: bundle, comment: "")
      }

      /// en translation: Return to stake
      ///
      /// Locales: en, ru
      static func stakingRebond(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond"
        }

        return NSLocalizedString("staking.rebond", bundle: bundle, comment: "")
      }

      /// en translation: Returned tokens will be counted from the next era
      ///
      /// Locales: en, ru
      static func stakingRebondHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rebond.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rebond.hint"
        }

        return NSLocalizedString("staking.rebond.hint", bundle: bundle, comment: "")
      }

      /// en translation: Reward
      ///
      /// Locales: en, ru
      static func stakingReward(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward"
        }

        return NSLocalizedString("staking.reward", bundle: bundle, comment: "")
      }

      /// en translation: Reward
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsReward(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.reward", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.reward"
        }

        return NSLocalizedString("staking.reward.details.reward", bundle: bundle, comment: "")
      }

      /// en translation: Reward details
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.title"
        }

        return NSLocalizedString("staking.reward.details.title", bundle: bundle, comment: "")
      }

      /// en translation: Rewarded
      ///
      /// Locales: en, ru
      static func stakingTotalRewards_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.total.rewards_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.total.rewards_v1.9.0"
        }

        return NSLocalizedString("staking.total.rewards_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Rewards
      ///
      /// Locales: en, ru
      static func stakingRewardsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rewards.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rewards.title"
        }

        return NSLocalizedString("staking.rewards.title", bundle: bundle, comment: "")
      }

      /// en translation: Rewards (APY)
      ///
      /// Locales: en, ru
      static func stakingCommonRewardsApy(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.common.rewards.apy", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.common.rewards.apy"
        }

        return NSLocalizedString("staking.common.rewards.apy", bundle: bundle, comment: "")
      }

      /// en translation: Rewards (APY)
      ///
      /// Locales: en, ru
      static func stakingFilterTitleRewards(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.filter.title.rewards", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.filter.title.rewards"
        }

        return NSLocalizedString("staking.filter.title.rewards", bundle: bundle, comment: "")
      }

      /// en translation: Rewards and Slashes
      ///
      /// Locales: en, ru
      static func walletFiltersRewardsAndSlashes(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.filters.rewards.and.slashes", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.filters.rewards.and.slashes"
        }

        return NSLocalizedString("wallet.filters.rewards.and.slashes", bundle: bundle, comment: "")
      }

      /// en translation: Rewards are paid every 23 days by validators
      ///
      /// Locales: en, ru
      static func stakingPendingRewardsHintTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards.hint.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards.hint.title"
        }

        return NSLocalizedString("staking.pending.rewards.hint.title", bundle: bundle, comment: "")
      }

      /// en translation: Rewards are paid every 23 days by validators. You can payout them by yourself, when they are close to expire, but you will pay the fee
      ///
      /// Locales: en, ru
      static func stakingPendingRewardsExplanationMessage_2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards.explanation.message_2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards.explanation.message_2_2_0"
        }

        return NSLocalizedString("staking.pending.rewards.explanation.message_2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Rewards destination
      ///
      /// Locales: en, ru
      static func stakingRewardsDestinationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rewards.destination.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rewards.destination.title"
        }

        return NSLocalizedString("staking.rewards.destination.title", bundle: bundle, comment: "")
      }

      /// en translation: Rewards destination
      ///
      /// Locales: en, ru
      static func stakingRewardsDestinationTitle_v2_0_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.rewards.destination.title_v2_0_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.rewards.destination.title_v2_0_0"
        }

        return NSLocalizedString("staking.rewards.destination.title_v2_0_0", bundle: bundle, comment: "")
      }

      /// en translation: Rewards for staking are available to payout at the end of each era (6 hours in Kusama and 24 hours in Polkadot). Network stores pending rewards during 84 eras and in most cases validators are paying out the rewards for everyone. However, validators might forget or something might happen with them, so nominators can payout their rewards by themselves.
      ///
      /// Locales: en, ru
      static func stakingStoryRewardPage1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.reward.page.1", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.reward.page.1"
        }

        return NSLocalizedString("staking.story.reward.page.1", bundle: bundle, comment: "")
      }

      /// en translation: Save
      ///
      /// Locales: en, ru
      static func commonSave(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.save", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.save"
        }

        return NSLocalizedString("common.save", bundle: bundle, comment: "")
      }

      /// en translation: Save transfer request as a qr code
      ///
      /// Locales: en, ru
      static func nsPhotoLibraryAddUsageDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("NSPhotoLibraryAddUsageDescription", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "NSPhotoLibraryAddUsageDescription"
        }

        return NSLocalizedString("NSPhotoLibraryAddUsageDescription", bundle: bundle, comment: "")
      }

      /// en translation: Save your secret and store it in a safe place
      ///
      /// Locales: en, ru
      static func exportRestoreJsonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.restore.json.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.restore.json.title"
        }

        return NSLocalizedString("export.restore.json.title", bundle: bundle, comment: "")
      }

      /// en translation: Saved
      ///
      /// Locales: en, ru
      static func commonSaved(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.saved", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.saved"
        }

        return NSLocalizedString("common.saved", bundle: bundle, comment: "")
      }

      /// en translation: Scam alert
      ///
      /// Locales: en, ru
      static func walletSendPhishingWarningTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.phishing.warning.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.phishing.warning.title"
        }

        return NSLocalizedString("wallet.send.phishing.warning.title", bundle: bundle, comment: "")
      }

      /// en translation: Scan QR
      ///
      /// Locales: en, ru
      static func recepientScanTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("recepient.scan.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "recepient.scan.title"
        }

        return NSLocalizedString("recepient.scan.title", bundle: bundle, comment: "")
      }

      /// en translation: Scan QR code from receiver
      ///
      /// Locales: en, ru
      static func recepientScanMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("recepient.scan.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "recepient.scan.message"
        }

        return NSLocalizedString("recepient.scan.message", bundle: bundle, comment: "")
      }

      /// en translation: Schnorrkel
      ///
      /// Locales: en, ru
      static func sr25519SelectionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("sr25519.selection.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "sr25519.selection.title"
        }

        return NSLocalizedString("sr25519.selection.title", bundle: bundle, comment: "")
      }

      /// en translation: Search
      ///
      /// Locales: en, ru
      static func commonSearch(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.search", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.search"
        }

        return NSLocalizedString("common.search", bundle: bundle, comment: "")
      }

      /// en translation: Search
      ///
      /// Locales: en, ru
      static func dappSearchQuerySection(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.search.query.section", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.search.query.section"
        }

        return NSLocalizedString("dapp.search.query.section", bundle: bundle, comment: "")
      }

      /// en translation: Search by address or name
      ///
      /// Locales: en, ru
      static func stakingValidatorSearchPlaceholder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.search.placeholder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.search.placeholder"
        }

        return NSLocalizedString("staking.validator.search.placeholder", bundle: bundle, comment: "")
      }

      /// en translation: Search by address or name
      ///
      /// Locales: en, ru
      static func walletContactsSearchPlaceholder_v110(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.contacts.search.placeholder_v1.10", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.contacts.search.placeholder_v1.10"
        }

        return NSLocalizedString("wallet.contacts.search.placeholder_v1.10", bundle: bundle, comment: "")
      }

      /// en translation: Search by name or enter URL
      ///
      /// Locales: en, ru
      static func dappListSearch(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.list.search", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.list.search"
        }

        return NSLocalizedString("dapp.list.search", bundle: bundle, comment: "")
      }

      /// en translation: Search results will be displayed here
      ///
      /// Locales: en, ru
      static func commonSearchStartTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.search.start.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.search.start.title_v2_2_0"
        }

        return NSLocalizedString("common.search.start.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Search results: %li
      ///
      /// Locales: en, ru
      static func commonSearchResultsNumber(_ value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.search.results.number", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.search.results.number"
        }

        let format = NSLocalizedString("common.search.results.number", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Searching pending rewards...
      ///
      /// Locales: en, ru
      static func stakingPendingRewardSearch(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.reward.search", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.reward.search"
        }

        return NSLocalizedString("staking.pending.reward.search", bundle: bundle, comment: "")
      }

      /// en translation: Secret derivation path
      ///
      /// Locales: en, ru
      static func commonSecretDerivationPath(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.secret.derivation.path", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.secret.derivation.path"
        }

        return NSLocalizedString("common.secret.derivation.path", bundle: bundle, comment: "")
      }

      /// en translation: Security
      ///
      /// Locales: en, ru
      static func settingsSecurity(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.security", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.security"
        }

        return NSLocalizedString("settings.security", bundle: bundle, comment: "")
      }

      /// en translation: Seed is invalid. Please, make sure that your input contains 64 hex symbols.
      ///
      /// Locales: en, ru
      static func accountImportInvalidSeed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.import.invalid.seed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.import.invalid.seed"
        }

        return NSLocalizedString("account.import.invalid.seed", bundle: bundle, comment: "")
      }

      /// en translation: Select another account as a controller to delegate staking management operations to it
      ///
      /// Locales: en, ru
      static func stakingControllerBannerMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.banner.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.banner.message"
        }

        return NSLocalizedString("staking.controller.banner.message", bundle: bundle, comment: "")
      }

      /// en translation: Select another account as a controller to improve staking security by delegating staking management operations to it
      ///
      /// Locales: en, ru
      static func stakingSetSeparateAccountController_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.set.separate.account.controller_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.set.separate.account.controller_v2_2_0"
        }

        return NSLocalizedString("staking.set.separate.account.controller_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Select asset
      ///
      /// Locales: en, ru
      static func commonSelectAsset(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.select.asset", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.select.asset"
        }

        return NSLocalizedString("common.select.asset", bundle: bundle, comment: "")
      }

      /// en translation: Select by yourself
      ///
      /// Locales: en, ru
      static func stakingSelectValidatorsCustomButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.select.validators.custom.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.select.validators.custom.button.title"
        }

        return NSLocalizedString("staking.select.validators.custom.button.title", bundle: bundle, comment: "")
      }

      /// en translation: Select network
      ///
      /// Locales: en, ru
      static func commonSelectNetwork(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.select.network", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.select.network"
        }

        return NSLocalizedString("common.select.network", bundle: bundle, comment: "")
      }

      /// en translation: Select parachains to contribute your %@. You will receive rewards if the parachain acquires a slot by the end of the auction.
      ///
      /// Locales: en, ru
      static func crowdloanListSectionFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.list.section.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.list.section.format"
        }

        let format = NSLocalizedString("crowdloan.list.section.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Select recommended
      ///
      /// Locales: en, ru
      static func stakingSelectValidatorsRecommendedButtonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.select.validators.recommended.button.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.select.validators.recommended.button.title"
        }

        return NSLocalizedString("staking.select.validators.recommended.button.title", bundle: bundle, comment: "")
      }

      /// en translation: Select the controller account
      ///
      /// Locales: en, ru
      static func stakingControllerSelectTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.select.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.select.title"
        }

        return NSLocalizedString("staking.controller.select.title", bundle: bundle, comment: "")
      }

      /// en translation: Select the words in the right order.
      ///
      /// Locales: en, ru
      static func confirmMnemonicSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("confirm.mnemonic.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "confirm.mnemonic.subtitle"
        }

        return NSLocalizedString("confirm.mnemonic.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Select the words...
      ///
      /// Locales: en, ru
      static func confirmMnemonicSelectWord(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("confirm.mnemonic.select.word", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "confirm.mnemonic.select.word"
        }

        return NSLocalizedString("confirm.mnemonic.select.word", bundle: bundle, comment: "")
      }

      /// en translation: Select validators
      ///
      /// Locales: en, ru
      static func stakingCustomValidatorsListTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.validators.list.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.validators.list.title"
        }

        return NSLocalizedString("staking.custom.validators.list.title", bundle: bundle, comment: "")
      }

      /// en translation: Select validators (max %li)
      ///
      /// Locales: en, ru
      static func stakingCustomProceedButtonDisabledTitle(_ value1: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.custom.proceed.button.disabled.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.proceed.button.disabled.title"
        }

        let format = NSLocalizedString("staking.custom.proceed.button.disabled.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Select validators to start staking
      ///
      /// Locales: en, ru
      static func stakingSetValidatorsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.set.validators.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.set.validators.title"
        }

        return NSLocalizedString("staking.set.validators.title", bundle: bundle, comment: "")
      }

      /// en translation: Select your rewards type
      ///
      /// Locales: en, ru
      static func stakingSetupRewardDestinationSectionTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.setup.reward.destination.section.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.reward.destination.section.title_v2_2_0"
        }

        return NSLocalizedString("staking.setup.reward.destination.section.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Select your secret type
      ///
      /// Locales: en, ru
      static func secretTypePickerTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("secret.type.picker.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "secret.type.picker.title"
        }

        return NSLocalizedString("secret.type.picker.title", bundle: bundle, comment: "")
      }

      /// en translation: Selected (%@)
      ///
      /// Locales: en, ru
      static func stakingYourSelectedFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.your.selected.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.selected.format"
        }

        let format = NSLocalizedString("staking.your.selected.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Selected account is already in use as controller
      ///
      /// Locales: en, ru
      static func stakingAccountIsUsedAsController(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.account.is.used.as.controller", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.account.is.used.as.controller"
        }

        return NSLocalizedString("staking.account.is.used.as.controller", bundle: bundle, comment: "")
      }

      /// en translation: Selected validators
      ///
      /// Locales: en, ru
      static func stakingSelectedValidatorsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.selected.validators.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.selected.validators.title"
        }

        return NSLocalizedString("staking.selected.validators.title", bundle: bundle, comment: "")
      }

      /// en translation: Send
      ///
      /// Locales: en, ru
      static func walletSendTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.title"
        }

        return NSLocalizedString("wallet.send.title", bundle: bundle, comment: "")
      }

      /// en translation: Send %@
      ///
      /// Locales: en, ru
      static func walletSendTokenTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("wallet.send.token.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.token.title"
        }

        let format = NSLocalizedString("wallet.send.token.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Send %@ on
      ///
      /// Locales: en, ru
      static func walletTransferTokenFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("wallet.transfer.token.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.transfer.token.format"
        }

        let format = NSLocalizedString("wallet.transfer.token.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Send to this contact
      ///
      /// Locales: en, ru
      static func txDetailsSendTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tx.details.send.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tx.details.send.title"
        }

        return NSLocalizedString("tx.details.send.title", bundle: bundle, comment: "")
      }

      /// en translation: Sender
      ///
      /// Locales: en, ru
      static func commonSender(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.sender", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.sender"
        }

        return NSLocalizedString("common.sender", bundle: bundle, comment: "")
      }

      /// en translation: Set a new password
      ///
      /// Locales: en, ru
      static func exportPasswordTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.password.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.password.title"
        }

        return NSLocalizedString("export.password.title", bundle: bundle, comment: "")
      }

      /// en translation: Set a separate account as a controller to increase staking management security.
      ///
      /// Locales: en, ru
      static func stakingSetSeparateAccountController(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.set.separate.account.controller", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.set.separate.account.controller"
        }

        return NSLocalizedString("staking.set.separate.account.controller", bundle: bundle, comment: "")
      }

      /// en translation: Set password
      ///
      /// Locales: en, ru
      static func commonSetPassword(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.set.password", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.set.password"
        }

        return NSLocalizedString("common.set.password", bundle: bundle, comment: "")
      }

      /// en translation: Set password...
      ///
      /// Locales: en, ru
      static func exportPasswordProceedSetTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.password.proceed.set.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.password.proceed.set.title"
        }

        return NSLocalizedString("export.password.proceed.set.title", bundle: bundle, comment: "")
      }

      /// en translation: Set validators
      ///
      /// Locales: en, ru
      static func stakingSetValidators(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.set.validators", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.set.validators"
        }

        return NSLocalizedString("staking.set.validators", bundle: bundle, comment: "")
      }

      /// en translation: Set your pin code
      ///
      /// Locales: en, ru
      static func pincodeSetYourPinCode(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("pincode.set.your.pin.code", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "pincode.set.your.pin.code"
        }

        return NSLocalizedString("pincode.set.your.pin.code", bundle: bundle, comment: "")
      }

      /// en translation: Settings
      ///
      /// Locales: en, ru
      static func profileTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("profile.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "profile.title"
        }

        return NSLocalizedString("profile.title", bundle: bundle, comment: "")
      }

      /// en translation: Settings
      ///
      /// Locales: en, ru
      static func tabbarSettingsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.settings.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.settings.title"
        }

        return NSLocalizedString("tabbar.settings.title", bundle: bundle, comment: "")
      }

      /// en translation: Share QR code
      ///
      /// Locales: en, ru
      static func walletReceiveShareTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.receive.share.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.receive.share.title"
        }

        return NSLocalizedString("wallet.receive.share.title", bundle: bundle, comment: "")
      }

      /// en translation: Share this QR to sender
      ///
      /// Locales: en, ru
      static func walletReceiveDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.receive.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.receive.description"
        }

        return NSLocalizedString("wallet.receive.description", bundle: bundle, comment: "")
      }

      /// en translation: Sharing or copying your secret is a high risk operation, dont send it to anyone. Would you like to proceed with sharing/copying process?
      ///
      /// Locales: en, ru
      static func accountExportWarningMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.export.warning.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.export.warning.message"
        }

        return NSLocalizedString("account.export.warning.message", bundle: bundle, comment: "")
      }

      /// en translation: Show
      ///
      /// Locales: en, ru
      static func walletFiltersHeader(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.filters.header", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.filters.header"
        }

        return NSLocalizedString("wallet.filters.header", bundle: bundle, comment: "")
      }

      /// en translation: Show selected: %li (max %li)
      ///
      /// Locales: en, ru
      static func stakingCustomProceedButtonEnabledTitle(_ value1: Int, _ value2: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.custom.proceed.button.enabled.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.proceed.button.enabled.title"
        }

        let format = NSLocalizedString("staking.custom.proceed.button.enabled.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Skip
      ///
      /// Locales: en, ru
      static func commonSkip(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.skip", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.skip"
        }

        return NSLocalizedString("common.skip", bundle: bundle, comment: "")
      }

      /// en translation: Skip process
      ///
      /// Locales: en, ru
      static func confirmationSkipAction(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("confirmation.skip.action", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "confirmation.skip.action"
        }

        return NSLocalizedString("confirmation.skip.action", bundle: bundle, comment: "")
      }

      /// en translation: Slash
      ///
      /// Locales: en, ru
      static func stakingSlash(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.slash", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.slash"
        }

        return NSLocalizedString("staking.slash", bundle: bundle, comment: "")
      }

      /// en translation: Sorry, you don't have enough funds to pay the network fee.
      ///
      /// Locales: en, ru
      static func commonNotEnoughFeeMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.not.enough.fee.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.not.enough.fee.message"
        }

        return NSLocalizedString("common.not.enough.fee.message", bundle: bundle, comment: "")
      }

      /// en translation: Sorry, you don't have enough funds to spend specified amount
      ///
      /// Locales: en, ru
      static func commonNotEnoughBalanceMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.not.enough.balance.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.not.enough.balance.message"
        }

        return NSLocalizedString("common.not.enough.balance.message", bundle: bundle, comment: "")
      }

      /// en translation: Sort by:
      ///
      /// Locales: en, ru
      static func commonFilterSortHeader(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.filter.sort.header", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.filter.sort.header"
        }

        return NSLocalizedString("common.filter.sort.header", bundle: bundle, comment: "")
      }

      /// en translation: Source type
      ///
      /// Locales: en, ru
      static func importSourcePickerTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("import.source.picker.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "import.source.picker.title"
        }

        return NSLocalizedString("import.source.picker.title", bundle: bundle, comment: "")
      }

      /// en translation: Stake
      ///
      /// Locales: en, ru
      static func stakingStake(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.stake", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stake"
        }

        return NSLocalizedString("staking.stake", bundle: bundle, comment: "")
      }

      /// en translation: Stake %@
      ///
      /// Locales: en, ru
      static func stakingStakeFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.stake.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stake.format"
        }

        let format = NSLocalizedString("staking.stake.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Stake more
      ///
      /// Locales: en, ru
      static func stakingBondMore_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.bond.more_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.bond.more_v1.9.0"
        }

        return NSLocalizedString("staking.bond.more_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Stake more request has been submitted
      ///
      /// Locales: en, ru
      static func stakingBondMoreCompletion(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.bond.more.completion", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.bond.more.completion"
        }

        return NSLocalizedString("staking.bond.more.completion", bundle: bundle, comment: "")
      }

      /// en translation: Stake more tokens.
      ///
      /// Locales: en, ru
      static func stakingBondMoreTokens(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.bond.more.tokens", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.bond.more.tokens"
        }

        return NSLocalizedString("staking.bond.more.tokens", bundle: bundle, comment: "")
      }

      /// en translation: Stake with recommended validators
      ///
      /// Locales: en, ru
      static func stakingRecommendedBannerTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.banner.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.banner.title"
        }

        return NSLocalizedString("staking.recommended.banner.title", bundle: bundle, comment: "")
      }

      /// en translation: Stake with your validators
      ///
      /// Locales: en, ru
      static func stakingSelectValidatorsCustomTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.select.validators.custom.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.select.validators.custom.title"
        }

        return NSLocalizedString("staking.select.validators.custom.title", bundle: bundle, comment: "")
      }

      /// en translation: Staked
      ///
      /// Locales: en, ru
      static func stakingMainStakeBalanceStaked(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.main.stake.balance.staked", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.main.stake.balance.staked"
        }

        return NSLocalizedString("staking.main.stake.balance.staked", bundle: bundle, comment: "")
      }

      /// en translation: Staked
      ///
      /// Locales: en, ru
      static func walletBalanceBonded(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.bonded", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.bonded"
        }

        return NSLocalizedString("wallet.balance.bonded", bundle: bundle, comment: "")
      }

      /// en translation: Staked tokens generate rewards each era (%@).
      ///
      /// Locales: en, ru
      static func stakingHintRewardsFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.hint.rewards.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.rewards.format"
        }

        let format = NSLocalizedString("staking.hint.rewards.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Staked:
      ///
      /// Locales: en, ru
      static func commonStakedPrefix(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.staked.prefix", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.staked.prefix"
        }

        return NSLocalizedString("common.staked.prefix", bundle: bundle, comment: "")
      }

      /// en translation: Staking
      ///
      /// Locales: en, ru
      static func stakingTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.title"
        }

        return NSLocalizedString("staking.title", bundle: bundle, comment: "")
      }

      /// en translation: Staking
      ///
      /// Locales: en, ru
      static func tabbarStakingTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.staking.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.staking.title"
        }

        return NSLocalizedString("tabbar.staking.title", bundle: bundle, comment: "")
      }

      /// en translation: Staking balance
      ///
      /// Locales: en, ru
      static func stakingBalanceTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.balance.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.balance.title"
        }

        return NSLocalizedString("staking.balance.title", bundle: bundle, comment: "")
      }

      /// en translation: Staking for validator
      ///
      /// Locales: en, ru
      static func stakingValidatorSummaryTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.summary.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.summary.title"
        }

        return NSLocalizedString("staking.validator.summary.title", bundle: bundle, comment: "")
      }

      /// en translation: Staking is an important part of network security and reliability. Anyone can run validator nodes, but only those who have enough tokens staked will be elected by the network to participate in composing new blocks and receive the rewards. Validators often do not have enough tokens by themselves, so nominators are helping them by locking their tokens for them to achieve the required amount of stake.
      ///
      /// Locales: en, ru
      static func stakingStoryStakingPage2(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.staking.page.2", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.staking.page.2"
        }

        return NSLocalizedString("staking.story.staking.page.2", bundle: bundle, comment: "")
      }

      /// en translation: Staking is an option to earn passive income by locking your tokens in the network. Staking rewards are allocated every era (6 hours on Kusama and 24 hours on Polkadot). You can stake as long as you wish, and for unstaking your tokens you need to wait for the unstacking period to end, making your tokens available to be redeemed.
      ///
      /// Locales: en, ru
      static func stakingStoryStakingPage1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.staking.page.1", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.staking.page.1"
        }

        return NSLocalizedString("staking.story.staking.page.1", bundle: bundle, comment: "")
      }

      /// en translation: Staking is currently inactive. Current minimal stake is %@.
      ///
      /// Locales: en, ru
      static func stakingInactiveCurrentMinimalStake(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.inactive.current.minimal.stake", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.inactive.current.minimal.stake"
        }

        let format = NSLocalizedString("staking.inactive.current.minimal.stake", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Staking period
      ///
      /// Locales: en, ru
      static func stakingNetworkInfoStakingPeriodTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.network.info.staking.period.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.network.info.staking.period.title"
        }

        return NSLocalizedString("staking.network.info.staking.period.title", bundle: bundle, comment: "")
      }

      /// en translation: Staking setup transaction sent
      ///
      /// Locales: en, ru
      static func stakingSetupSentMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.setup.sent.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.sent.message"
        }

        return NSLocalizedString("staking.setup.sent.message", bundle: bundle, comment: "")
      }

      /// en translation: Staking was active
      ///
      /// Locales: en, ru
      static func stakingAnalyticsStakingWasActive(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.staking.was.active", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.staking.was.active"
        }

        return NSLocalizedString("staking.analytics.staking.was.active", bundle: bundle, comment: "")
      }

      /// en translation: Staking was inactive
      ///
      /// Locales: en, ru
      static func stakingAnalyticsStakingWasInactive(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.staking.was.inactive", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.staking.was.inactive"
        }

        return NSLocalizedString("staking.analytics.staking.was.inactive", bundle: bundle, comment: "")
      }

      /// en translation: Start staking
      ///
      /// Locales: en, ru
      static func stakingStartTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.start.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.start.title"
        }

        return NSLocalizedString("staking.start.title", bundle: bundle, comment: "")
      }

      /// en translation: Stash
      ///
      /// Locales: en, ru
      static func stakingStash(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.stash", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stash"
        }

        return NSLocalizedString("staking.stash", bundle: bundle, comment: "")
      }

      /// en translation: Stash account
      ///
      /// Locales: en, ru
      static func stackingStashAccount(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("stacking.stash.account", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "stacking.stash.account"
        }

        return NSLocalizedString("stacking.stash.account", bundle: bundle, comment: "")
      }

      /// en translation: Stash account %@ is unavailable to update staking setup.
      ///
      /// Locales: en, ru
      static func stakingStashMissingMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.stash.missing.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stash.missing.message"
        }

        let format = NSLocalizedString("staking.stash.missing.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Stash can stake more and set the controller.
      ///
      /// Locales: en, ru
      static func stakingStashCanHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.stash.can.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stash.can.hint"
        }

        return NSLocalizedString("staking.stash.can.hint", bundle: bundle, comment: "")
      }

      /// en translation: Stash is used to: stake more and set the controller
      ///
      /// Locales: en, ru
      static func stakingStashCanHint_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.stash.can.hint_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stash.can.hint_v2_2_0"
        }

        return NSLocalizedString("staking.stash.can.hint_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Status
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsStatus(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.status", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.status"
        }

        return NSLocalizedString("staking.reward.details.status", bundle: bundle, comment: "")
      }

      /// en translation: Status
      ///
      /// Locales: en, ru
      static func transactionDetailStatus(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.detail.status", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.detail.status"
        }

        return NSLocalizedString("transaction.detail.status", bundle: bundle, comment: "")
      }

      /// en translation: Stop staking
      ///
      /// Locales: en, ru
      static func stakingUnbondingAllTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.all.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.all.title"
        }

        return NSLocalizedString("staking.unbonding.all.title", bundle: bundle, comment: "")
      }

      /// en translation: Submit agreement
      ///
      /// Locales: en, ru
      static func crowdloanSubmitAgreement(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.submit.agreement", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.submit.agreement"
        }

        return NSLocalizedString("crowdloan.submit.agreement", bundle: bundle, comment: "")
      }

      /// en translation: Substrate keypair crypto type
      ///
      /// Locales: en, ru
      static func commonCryptoTypeSubstrate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.crypto.type.substrate", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.crypto.type.substrate"
        }

        return NSLocalizedString("common.crypto.type.substrate", bundle: bundle, comment: "")
      }

      /// en translation: Substrate secret derivation path
      ///
      /// Locales: en, ru
      static func commonSecretDerivationPathSubstrate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.secret.derivation.path.substrate", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.secret.derivation.path.substrate"
        }

        return NSLocalizedString("common.secret.derivation.path.substrate", bundle: bundle, comment: "")
      }

      /// en translation: Support & Feedback
      ///
      /// Locales: en, ru
      static func settingsSupport(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.support", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.support"
        }

        return NSLocalizedString("settings.support", bundle: bundle, comment: "")
      }

      /// en translation: Switch your account to stash to set the controller.
      ///
      /// Locales: en, ru
      static func stakingSwitchAccountToStash(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.switch.account.to.stash", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.switch.account.to.stash"
        }

        return NSLocalizedString("staking.switch.account.to.stash", bundle: bundle, comment: "")
      }

      /// en translation: Telegram
      ///
      /// Locales: en, ru
      static func aboutTelegram(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.telegram", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.telegram"
        }

        return NSLocalizedString("about.telegram", bundle: bundle, comment: "")
      }

      /// en translation: Terms and Conditions
      ///
      /// Locales: en, ru
      static func aboutTerms(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.terms", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.terms"
        }

        return NSLocalizedString("about.terms", bundle: bundle, comment: "")
      }

      /// en translation: Terms and Conditions
      ///
      /// Locales: en, ru
      static func crowdloanTermsValue(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.terms.value", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.terms.value"
        }

        return NSLocalizedString("crowdloan.terms.value", bundle: bundle, comment: "")
      }

      /// en translation: Terms and Conditions
      ///
      /// Locales: en, ru
      static func onboardingTermsAndConditions2(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("onboarding.terms.and.conditions.2", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "onboarding.terms.and.conditions.2"
        }

        return NSLocalizedString("onboarding.terms.and.conditions.2", bundle: bundle, comment: "")
      }

      /// en translation: The minimum allowed amount to contribute is %@.
      ///
      /// Locales: en, ru
      static func crowdloanTooSmallContributionMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.too.small.contribution.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.too.small.contribution.message"
        }

        let format = NSLocalizedString("crowdloan.too.small.contribution.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: The network type is not supported yet. Please, choose another one.
      ///
      /// Locales: en, ru
      static func commonUnsupportedNetworkMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.unsupported.network.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.unsupported.network.message"
        }

        return NSLocalizedString("common.unsupported.network.message", bundle: bundle, comment: "")
      }

      /// en translation: The node has already been added previously. Please, try another node.
      ///
      /// Locales: en, ru
      static func connectionAddAlreadyExistsError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("connection.add.already.exists.error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.add.already.exists.error"
        }

        return NSLocalizedString("connection.add.already.exists.error", bundle: bundle, comment: "")
      }

      /// en translation: The reward destination will be changed to your account to avoid a bonded remnant since staking will be stopped
      ///
      /// Locales: en, ru
      static func stakingUnbondPayeeResetMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbond.payee.reset.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbond.payee.reset.message"
        }

        return NSLocalizedString("staking.unbond.payee.reset.message", bundle: bundle, comment: "")
      }

      /// en translation: The reward is less than the network fee.
      ///
      /// Locales: en, ru
      static func stakingWarningTinyPayout(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.warning.tiny.payout", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.warning.tiny.payout"
        }

        return NSLocalizedString("staking.warning.tiny.payout", bundle: bundle, comment: "")
      }

      /// en translation: The validator runs a blockchain node 24/7 and is required to have enough stake locked (both owned and provided by nominators) to be elected by the network. Validators should maintain their nodes' performance and reliability to be rewarded. Being a validator is almost a full-time job, there are companies that are focused to be validators on the blockchain networks.
      ///
      /// Locales: en, ru
      static func stakingStoryValidatorPage1(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.validator.page.1", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.validator.page.1"
        }

        return NSLocalizedString("staking.story.validator.page.1", bundle: bundle, comment: "")
      }

      /// en translation: This crowdloan isn't available in your location.
      ///
      /// Locales: en, ru
      static func crowdloanMoonbeamRegionRestrictionMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.moonbeam.region.restriction.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.moonbeam.region.restriction.message"
        }

        return NSLocalizedString("crowdloan.moonbeam.region.restriction.message", bundle: bundle, comment: "")
      }

      /// en translation: This name will be displayed only for you and stored locally on your mobile device.
      ///
      /// Locales: en, ru
      static func accountUsernameSetupHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.username.setup.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.username.setup.hint"
        }

        return NSLocalizedString("account.username.setup.hint", bundle: bundle, comment: "")
      }

      /// en translation: This nickname will be displayed only for you and stored locally on your mobile device.
      ///
      /// Locales: en, ru
      static func walletNicknameCreateSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.nickname.create.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.nickname.create.subtitle"
        }

        return NSLocalizedString("wallet.nickname.create.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: This validator is not accepting nominations at this moment. Please, try again in the next era.
      ///
      /// Locales: en, ru
      static func stakingCustomBlockedWarning(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.blocked.warning", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.blocked.warning"
        }

        return NSLocalizedString("staking.custom.blocked.warning", bundle: bundle, comment: "")
      }

      /// en translation: Time left
      ///
      /// Locales: en, ru
      static func commonTimeLeft(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.time.left", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.time.left"
        }

        return NSLocalizedString("common.time.left", bundle: bundle, comment: "")
      }

      /// en translation: Title
      ///
      /// Locales: en, ru
      static func commonTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.title"
        }

        return NSLocalizedString("common.title", bundle: bundle, comment: "")
      }

      /// en translation: To
      ///
      /// Locales: en, ru
      static func walletSendReceiverTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.receiver.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.receiver.title"
        }

        return NSLocalizedString("wallet.send.receiver.title", bundle: bundle, comment: "")
      }

      /// en translation: To unstake tokens you will have to wait for the unstaking period (%@)
      ///
      /// Locales: en, ru
      static func stakingHintUnstakeFormat_v2_2_0(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.hint.unstake.format_v2_2_0", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.unstake.format_v2_2_0"
        }

        let format = NSLocalizedString("staking.hint.unstake.format_v2_2_0", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Tokens in stake produce rewards each era (%@)
      ///
      /// Locales: en, ru
      static func stakingHintRewardsFormat_v2_2_0(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.hint.rewards.format_v2_2_0", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.rewards.format_v2_2_0"
        }

        let format = NSLocalizedString("staking.hint.rewards.format_v2_2_0", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Tokens in unstaking period generate no rewards.
      ///
      /// Locales: en, ru
      static func stakingHintNoRewards(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.no.rewards", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.no.rewards"
        }

        return NSLocalizedString("staking.hint.no.rewards", bundle: bundle, comment: "")
      }

      /// en translation: Total
      ///
      /// Locales: en, ru
      static func walletTransferTotalTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.transfer.total.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.transfer.total.title"
        }

        return NSLocalizedString("wallet.transfer.total.title", bundle: bundle, comment: "")
      }

      /// en translation: Total after transfer
      ///
      /// Locales: en, ru
      static func walletSendBalanceTotalAfterTransfer(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.balance.total.after.transfer", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.balance.total.after.transfer"
        }

        return NSLocalizedString("wallet.send.balance.total.after.transfer", bundle: bundle, comment: "")
      }

      /// en translation: Total balance
      ///
      /// Locales: en, ru
      static func walletSendBalanceTotal(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.balance.total", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.balance.total"
        }

        return NSLocalizedString("wallet.send.balance.total", bundle: bundle, comment: "")
      }

      /// en translation: Total balance
      ///
      /// Locales: en, ru
      static func walletTotalBalance(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.total.balance", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.total.balance"
        }

        return NSLocalizedString("wallet.total.balance", bundle: bundle, comment: "")
      }

      /// en translation: Total stake
      ///
      /// Locales: en, ru
      static func stakingValidatorTotalStake(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.total.stake", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.total.stake"
        }

        return NSLocalizedString("staking.validator.total.stake", bundle: bundle, comment: "")
      }

      /// en translation: Total stake (%@)
      ///
      /// Locales: en, ru
      static func stakingValidatorTotalStakeToken(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.validator.total.stake.token", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.total.stake.token"
        }

        let format = NSLocalizedString("staking.validator.total.stake.token", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Total staked
      ///
      /// Locales: en, ru
      static func stakingMainTotalStakedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.main.total.staked.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.main.total.staked.title"
        }

        return NSLocalizedString("staking.main.total.staked.title", bundle: bundle, comment: "")
      }

      /// en translation: Touch ID
      ///
      /// Locales: en, ru
      static func askTouchidTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ask.touchid.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ask.touchid.title"
        }

        return NSLocalizedString("ask.touchid.title", bundle: bundle, comment: "")
      }

      /// en translation: Transaction ID
      ///
      /// Locales: en, ru
      static func commonTxId(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.tx.id", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.tx.id"
        }

        return NSLocalizedString("common.tx.id", bundle: bundle, comment: "")
      }

      /// en translation: Transaction details
      ///
      /// Locales: en, ru
      static func commonTxDetails(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.tx.details", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.tx.details"
        }

        return NSLocalizedString("common.tx.details", bundle: bundle, comment: "")
      }

      /// en translation: Transaction failed. Please, try again later.
      ///
      /// Locales: en, ru
      static func commonTransactionFailed(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.transaction.failed", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.transaction.failed"
        }

        return NSLocalizedString("common.transaction.failed", bundle: bundle, comment: "")
      }

      /// en translation: Transaction submitted
      ///
      /// Locales: en, ru
      static func commonTransactionSubmitted(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.transaction.submitted", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.transaction.submitted"
        }

        return NSLocalizedString("common.transaction.submitted", bundle: bundle, comment: "")
      }

      /// en translation: Transfer
      ///
      /// Locales: en, ru
      static func transferTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transfer.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transfer.title"
        }

        return NSLocalizedString("transfer.title", bundle: bundle, comment: "")
      }

      /// en translation: Transfer fee
      ///
      /// Locales: en, ru
      static func walletSendFeeTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.fee.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.fee.title"
        }

        return NSLocalizedString("wallet.send.fee.title", bundle: bundle, comment: "")
      }

      /// en translation: Transferable
      ///
      /// Locales: en, ru
      static func walletBalanceAvailable(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.available", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.available"
        }

        return NSLocalizedString("wallet.balance.available", bundle: bundle, comment: "")
      }

      /// en translation: Transferable rewards
      ///
      /// Locales: en, ru
      static func stakingPayoutTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.payout.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.payout.title_v2_2_0"
        }

        return NSLocalizedString("staking.payout.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Transferable rewards
      ///
      /// Locales: en, ru
      static func stakingSetupPayoutTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.setup.payout.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.setup.payout.title"
        }

        return NSLocalizedString("staking.setup.payout.title", bundle: bundle, comment: "")
      }

      /// en translation: Transferable:
      ///
      /// Locales: en, ru
      static func commonTransferablePrefix(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.transferable.prefix", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.transferable.prefix"
        }

        return NSLocalizedString("common.transferable.prefix", bundle: bundle, comment: "")
      }

      /// en translation: Transfers
      ///
      /// Locales: en, ru
      static func walletFiltersTransfers(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.filters.transfers", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.filters.transfers"
        }

        return NSLocalizedString("wallet.filters.transfers", bundle: bundle, comment: "")
      }

      /// en translation: Twitter
      ///
      /// Locales: en, ru
      static func settingsTwitter(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.twitter", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.twitter"
        }

        return NSLocalizedString("settings.twitter", bundle: bundle, comment: "")
      }

      /// en translation: Type
      ///
      /// Locales: en, ru
      static func stakingAnalyticsDetailsType(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.details.type", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.details.type"
        }

        return NSLocalizedString("staking.analytics.details.type", bundle: bundle, comment: "")
      }

      /// en translation: Typically 12-word phrase (but may be 15, 18, 21 or 24)
      ///
      /// Locales: en, ru
      static func walletImportMnemonicHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.mnemonic.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.mnemonic.hint"
        }

        return NSLocalizedString("wallet.import.mnemonic.hint", bundle: bundle, comment: "")
      }

      /// en translation: Undefined error
      ///
      /// Locales: en, ru
      static func commonUndefinedErrorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.undefined.error.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.undefined.error.title"
        }

        return NSLocalizedString("common.undefined.error.title", bundle: bundle, comment: "")
      }

      /// en translation: Unexpected corrupted data found. Please, contact support.
      ///
      /// Locales: en, ru
      static func commonDataCorruptionError(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.data.corruption.error", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.data.corruption.error"
        }

        return NSLocalizedString("common.data.corruption.error", bundle: bundle, comment: "")
      }

      /// en translation: Unfortunately, access to the camera is restricted.
      ///
      /// Locales: en, ru
      static func qrScanErrorCameraRestricted(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.camera.restricted", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.camera.restricted"
        }

        return NSLocalizedString("qr.scan.error.camera.restricted", bundle: bundle, comment: "")
      }

      /// en translation: Unfortunately, access to the photos is restricted.
      ///
      /// Locales: en, ru
      static func qrScanErrorGalleryRestricted(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.gallery.restricted", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.gallery.restricted"
        }

        return NSLocalizedString("qr.scan.error.gallery.restricted", bundle: bundle, comment: "")
      }

      /// en translation: Unfortunately, the network is unsupported. Please, try one of the following: %@.
      ///
      /// Locales: en, ru
      static func connectionAddUnsupportedError(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("connection.add.unsupported.error", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "connection.add.unsupported.error"
        }

        let format = NSLocalizedString("connection.add.unsupported.error", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Unfortunately, you denied access to camera previously. Would you like to allow access now?
      ///
      /// Locales: en, ru
      static func qrScanErrorCameraRestricted_previously(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.camera.restricted_previously", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.camera.restricted_previously"
        }

        return NSLocalizedString("qr.scan.error.camera.restricted_previously", bundle: bundle, comment: "")
      }

      /// en translation: Unfortunately, you denied access to photos previously. Would you like to allow access now?
      ///
      /// Locales: en, ru
      static func qrScanErrorGalleryRestrictedPreviously(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.error.gallery.restricted.previously", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.error.gallery.restricted.previously"
        }

        return NSLocalizedString("qr.scan.error.gallery.restricted.previously", bundle: bundle, comment: "")
      }

      /// en translation: Unlimited
      ///
      /// Locales: en, ru
      static func stakingNetworkInfoStakingPeriodValue(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.network.info.staking.period.value", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.network.info.staking.period.value"
        }

        return NSLocalizedString("staking.network.info.staking.period.value", bundle: bundle, comment: "")
      }

      /// en translation: Unlimited series
      ///
      /// Locales: en, ru
      static func nftListItemUnlimited(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("nft.list.item.unlimited", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "nft.list.item.unlimited"
        }

        return NSLocalizedString("nft.list.item.unlimited", bundle: bundle, comment: "")
      }

      /// en translation: Unpaid rewards
      ///
      /// Locales: en, ru
      static func stakingPendingRewards_v2_0_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards_v2_0_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards_v2_0_0"
        }

        return NSLocalizedString("staking.pending.rewards_v2_0_0", bundle: bundle, comment: "")
      }

      /// en translation: Unpaid rewards
      ///
      /// Locales: en, ru
      static func stakingRewardPayoutsTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.payouts.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.payouts.title_v2_2_0"
        }

        return NSLocalizedString("staking.reward.payouts.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Unstake
      ///
      /// Locales: en, ru
      static func stakingUnbond_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbond_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbond_v1.9.0"
        }

        return NSLocalizedString("staking.unbond_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking
      ///
      /// Locales: en, ru
      static func walletBalanceUnbonding_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balance.unbonding_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balance.unbonding_v1.9.0"
        }

        return NSLocalizedString("wallet.balance.unbonding_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking period
      ///
      /// Locales: en, ru
      static func stakingMainLockupPeriodTitle_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.main.lockup.period.title_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.main.lockup.period.title_v1.9.0"
        }

        return NSLocalizedString("staking.main.lockup.period.title_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking period
      ///
      /// Locales: en, ru
      static func stakingUnbondingPeriod_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.period_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.period_v1.9.0"
        }

        return NSLocalizedString("staking.unbonding.period_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking requests limit reached
      ///
      /// Locales: en, ru
      static func stakingUnbondingLimitReachedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.limit.reached.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.limit.reached.title"
        }

        return NSLocalizedString("staking.unbonding.limit.reached.title", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking transactions will appear here
      ///
      /// Locales: en, ru
      static func stakingUnbondingEmptyList_v190(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.empty.list_v1.9.0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.empty.list_v1.9.0"
        }

        return NSLocalizedString("staking.unbonding.empty.list_v1.9.0", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking transactions will be displayed here
      ///
      /// Locales: en, ru
      static func stakingUnbondingEmptyList_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.empty.list_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.empty.list_v2_2_0"
        }

        return NSLocalizedString("staking.unbonding.empty.list_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking:
      ///
      /// Locales: en, ru
      static func commonUnstakingPrefix(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.unstaking.prefix", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.unstaking.prefix"
        }

        return NSLocalizedString("common.unstaking.prefix", bundle: bundle, comment: "")
      }

      /// en translation: Unstaking: %@
      ///
      /// Locales: en, ru
      static func stakingUnbondingFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.unbonding.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.format"
        }

        let format = NSLocalizedString("staking.unbonding.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Update
      ///
      /// Locales: en, ru
      static func commonUpdate(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.update", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.update"
        }

        return NSLocalizedString("common.update", bundle: bundle, comment: "")
      }

      /// en translation: Update your list
      ///
      /// Locales: en, ru
      static func stakingCustomValidatorsUpdateList(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.validators.update.list", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.validators.update.list"
        }

        return NSLocalizedString("staking.custom.validators.update.list", bundle: bundle, comment: "")
      }

      /// en translation: Upload from gallery
      ///
      /// Locales: en, ru
      static func qrScanUploadGallery(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("qr.scan.upload.gallery", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "qr.scan.upload.gallery"
        }

        return NSLocalizedString("qr.scan.upload.gallery", bundle: bundle, comment: "")
      }

      /// en translation: Use
      ///
      /// Locales: en, ru
      static func commonUse(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.use", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.use"
        }

        return NSLocalizedString("common.use", bundle: bundle, comment: "")
      }

      /// en translation: Use non digital way to backup, such as writing the sequence of mnemonic words and derivation path (if set) down on paper.
      ///
      /// Locales: en, ru
      static func exportMnemonicHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.mnemonic.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.mnemonic.hint"
        }

        return NSLocalizedString("export.mnemonic.hint", bundle: bundle, comment: "")
      }

      /// en translation: Use nondigital way to back up, such as writing it down on paper.
      ///
      /// Locales: en, ru
      static func accountCreateDetails(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.create.details", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.create.details"
        }

        return NSLocalizedString("account.create.details", bundle: bundle, comment: "")
      }

      /// en translation: Validator
      ///
      /// Locales: en, ru
      static func stakingCommonValidator(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.common.validator", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.common.validator"
        }

        return NSLocalizedString("staking.common.validator", bundle: bundle, comment: "")
      }

      /// en translation: Validator
      ///
      /// Locales: en, ru
      static func stakingRewardDetailsValidator(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.details.validator", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.details.validator"
        }

        return NSLocalizedString("staking.reward.details.validator", bundle: bundle, comment: "")
      }

      /// en translation: Validator info
      ///
      /// Locales: en, ru
      static func stakingValidatorInfoTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.info.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.info.title"
        }

        return NSLocalizedString("staking.validator.info.title", bundle: bundle, comment: "")
      }

      /// en translation: Validator is slashed for misbehaves (e.g. goes offline, attacks the network, or runs modified software) in the network.
      ///
      /// Locales: en, ru
      static func stakingValidatorSlashedDesc(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.validator.slashed.desc", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.validator.slashed.desc"
        }

        return NSLocalizedString("staking.validator.slashed.desc", bundle: bundle, comment: "")
      }

      /// en translation: Validator's own stake
      ///
      /// Locales: en, ru
      static func stakingFilterTitleOwnStake(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.filter.title.own.stake", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.filter.title.own.stake"
        }

        return NSLocalizedString("staking.filter.title.own.stake", bundle: bundle, comment: "")
      }

      /// en translation: Validator's own stake (%@)
      ///
      /// Locales: en, ru
      static func stakingFilterTitleOwnStakeToken(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.filter.title.own.stake.token", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.filter.title.own.stake.token"
        }

        let format = NSLocalizedString("staking.filter.title.own.stake.token", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Validators
      ///
      /// Locales: en, ru
      static func stakingRecommendedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.title"
        }

        return NSLocalizedString("staking.recommended.title", bundle: bundle, comment: "")
      }

      /// en translation: Validators are not selected
      ///
      /// Locales: en, ru
      static func stakingSetValidatorsMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.set.validators.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.set.validators.message"
        }

        return NSLocalizedString("staking.set.validators.message", bundle: bundle, comment: "")
      }

      /// en translation: Validators payout the rewards every 25 days. However, you can payout them by yourself, especially if rewards are close to expiring, but you will pay the fee.
      ///
      /// Locales: en, ru
      static func stakingPendingRewardsExplanationMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards.explanation.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards.explanation.message"
        }

        return NSLocalizedString("staking.pending.rewards.explanation.message", bundle: bundle, comment: "")
      }

      /// en translation: Validators who were not elected in this era.
      ///
      /// Locales: en, ru
      static func stakingYourInactiveDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.inactive.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.inactive.description"
        }

        return NSLocalizedString("staking.your.inactive.description", bundle: bundle, comment: "")
      }

      /// en translation: Validators without enough stake to be elected
      ///
      /// Locales: en, ru
      static func stakingYourInactiveDescription_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.inactive.description_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.inactive.description_v2_2_0"
        }

        return NSLocalizedString("staking.your.inactive.description_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Validators: %li of %li
      ///
      /// Locales: en, ru
      static func stakingCustomHeaderValidatorsTitle(_ value1: Int, _ value2: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.custom.header.validators.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.header.validators.title"
        }

        let format = NSLocalizedString("staking.custom.header.validators.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: Vesting
      ///
      /// Locales: en, ru
      static func walletAccountLocksVesting(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.account.locks.vesting", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.account.locks.vesting"
        }

        return NSLocalizedString("wallet.account.locks.vesting", bundle: bundle, comment: "")
      }

      /// en translation: View in %@
      ///
      /// Locales: en, ru
      static func commmonViewInFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("commmon.view.in.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "commmon.view.in.format"
        }

        let format = NSLocalizedString("commmon.view.in.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: View in Polkascan
      ///
      /// Locales: en, ru
      static func transactionDetailsViewPolkascan(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.details.view.polkascan", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.details.view.polkascan"
        }

        return NSLocalizedString("transaction.details.view.polkascan", bundle: bundle, comment: "")
      }

      /// en translation: View in Subscan
      ///
      /// Locales: en, ru
      static func transactionDetailsViewSubscan(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("transaction.details.view.subscan", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "transaction.details.view.subscan"
        }

        return NSLocalizedString("transaction.details.view.subscan", bundle: bundle, comment: "")
      }

      /// en translation: Waiting for the next Era
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusWaiting(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.waiting", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.waiting"
        }

        return NSLocalizedString("staking.nominator.status.waiting", bundle: bundle, comment: "")
      }

      /// en translation: Wallet
      ///
      /// Locales: en, ru
      static func commonWallet(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.wallet", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.wallet"
        }

        return NSLocalizedString("common.wallet", bundle: bundle, comment: "")
      }

      /// en translation: Wallet
      ///
      /// Locales: en, ru
      static func tabbarWalletTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("tabbar.wallet.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "tabbar.wallet.title"
        }

        return NSLocalizedString("tabbar.wallet.title", bundle: bundle, comment: "")
      }

      /// en translation: Wallet
      ///
      /// Locales: en, ru
      static func walletChainManagementTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.chain.management.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.chain.management.title"
        }

        return NSLocalizedString("wallet.chain.management.title", bundle: bundle, comment: "")
      }

      /// en translation: Wallet account
      ///
      /// Locales: en, ru
      static func stakingStashTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.stash.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.stash.title"
        }

        return NSLocalizedString("staking.stash.title", bundle: bundle, comment: "")
      }

      /// en translation: Wallet name
      ///
      /// Locales: en, ru
      static func walletUsernameSetupChooseTitle_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.username.setup.choose.title_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.username.setup.choose.title_v2_2_0"
        }

        return NSLocalizedString("wallet.username.setup.choose.title_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Wallet nickname
      ///
      /// Locales: en, ru
      static func walletUsernameSetupChooseTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.username.setup.choose.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.username.setup.choose.title"
        }

        return NSLocalizedString("wallet.username.setup.choose.title", bundle: bundle, comment: "")
      }

      /// en translation: Wallets
      ///
      /// Locales: en, ru
      static func profileWalletsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("profile.wallets.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "profile.wallets.title"
        }

        return NSLocalizedString("profile.wallets.title", bundle: bundle, comment: "")
      }

      /// en translation: Warning
      ///
      /// Locales: en, ru
      static func commonWarning(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.warning", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.warning"
        }

        return NSLocalizedString("common.warning", bundle: bundle, comment: "")
      }

      /// en translation: We are going to show your mnemonic. Make sure no one can see your screen and do not take screenshots  they can be collected by third-party malware
      ///
      /// Locales: en, ru
      static func commonNoScreenshotMessage_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.no.screenshot.message_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.no.screenshot.message_v2_2_0"
        }

        return NSLocalizedString("common.no.screenshot.message_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: We found that this account has no free tokens, are you sure that you want to change the controller?
      ///
      /// Locales: en, ru
      static func stakingControllerAccountZeroBalance(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.controller.account.zero.balance", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.controller.account.zero.balance"
        }

        return NSLocalizedString("staking.controller.account.zero.balance", bundle: bundle, comment: "")
      }

      /// en translation: Web
      ///
      /// Locales: en, ru
      static func identityWebTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("identity.web.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "identity.web.title"
        }

        return NSLocalizedString("identity.web.title", bundle: bundle, comment: "")
      }

      /// en translation: Website
      ///
      /// Locales: en, ru
      static func aboutWebsite(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("about.website", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "about.website"
        }

        return NSLocalizedString("about.website", bundle: bundle, comment: "")
      }

      /// en translation: Websites to which you allowed access to see your address when you use them
      ///
      /// Locales: en, ru
      static func dappAuthorizedInfo(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.authorized.info", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.authorized.info"
        }

        return NSLocalizedString("dapp.authorized.info", bundle: bundle, comment: "")
      }

      /// en translation: Welcome to DApp portal
      ///
      /// Locales: en, ru
      static func dappDecorationTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.decoration.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.decoration.title"
        }

        return NSLocalizedString("dapp.decoration.title", bundle: bundle, comment: "")
      }

      /// en translation: Welcome to Nova browser
      ///
      /// Locales: en, ru
      static func dappDecorationTitle_2_4_3(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("dapp.decoration.title_2_4_3", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.decoration.title_2_4_3"
        }

        return NSLocalizedString("dapp.decoration.title_2_4_3", bundle: bundle, comment: "")
      }

      /// en translation: What is staking?
      ///
      /// Locales: en, ru
      static func stakingStoryStakingTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.staking.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.staking.title"
        }

        return NSLocalizedString("staking.story.staking.title", bundle: bundle, comment: "")
      }

      /// en translation: Who is a nominator?
      ///
      /// Locales: en, ru
      static func stakingStoryNominatorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.nominator.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.nominator.title"
        }

        return NSLocalizedString("staking.story.nominator.title", bundle: bundle, comment: "")
      }

      /// en translation: Who is a validator?
      ///
      /// Locales: en, ru
      static func stakingStoryValidatorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.story.validator.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.story.validator.title"
        }

        return NSLocalizedString("staking.story.validator.title", bundle: bundle, comment: "")
      }

      /// en translation: Would you like to use Face ID for authentication?
      ///
      /// Locales: en, ru
      static func askFaceidMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ask.faceid.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ask.faceid.message"
        }

        return NSLocalizedString("ask.faceid.message", bundle: bundle, comment: "")
      }

      /// en translation: Would you like to use Touch ID for authentication?
      ///
      /// Locales: en, ru
      static func askTouchidMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ask.touchid.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ask.touchid.message"
        }

        return NSLocalizedString("ask.touchid.message", bundle: bundle, comment: "")
      }

      /// en translation: Write down the phrase and store it in a safe place
      ///
      /// Locales: en, ru
      static func accountBackupMnemonicTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.backup.mnemonic.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.backup.mnemonic.title"
        }

        return NSLocalizedString("account.backup.mnemonic.title", bundle: bundle, comment: "")
      }

      /// en translation: Write down your secret and store it in a safe place
      ///
      /// Locales: en, ru
      static func exportSeedTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("export.seed.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "export.seed.title"
        }

        return NSLocalizedString("export.seed.title", bundle: bundle, comment: "")
      }

      /// en translation: Write words separately with one space, no commas or other signs
      ///
      /// Locales: en, ru
      static func walletImportMnemonicSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.import.mnemonic.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.import.mnemonic.subtitle"
        }

        return NSLocalizedString("wallet.import.mnemonic.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: Yearly
      ///
      /// Locales: en, ru
      static func stakingYearPeriodTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.year.period.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.year.period.title"
        }

        return NSLocalizedString("staking.year.period.title", bundle: bundle, comment: "")
      }

      /// en translation: You are about to deselect all the validators you selected earlier.
      ///
      /// Locales: en, ru
      static func stakingCustomDeselectWarning(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.custom.deselect.warning", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.custom.deselect.warning"
        }

        return NSLocalizedString("staking.custom.deselect.warning", bundle: bundle, comment: "")
      }

      /// en translation: You are neither nominating nor validating
      ///
      /// Locales: en, ru
      static func stakingBondedInactive(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.bonded.inactive", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.bonded.inactive"
        }

        return NSLocalizedString("staking.bonded.inactive", bundle: bundle, comment: "")
      }

      /// en translation: You can payout them by yourself, when they are close to expire, but you will pay the fee
      ///
      /// Locales: en, ru
      static func stakingPendingRewardsHintMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.pending.rewards.hint.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.pending.rewards.hint.message"
        }

        return NSLocalizedString("staking.pending.rewards.hint.message", bundle: bundle, comment: "")
      }

      /// en translation: You dont have account for this network, you can create or import account.
      ///
      /// Locales: en, ru
      static func accountNeededMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("account.needed.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "account.needed.message"
        }

        return NSLocalizedString("account.needed.message", bundle: bundle, comment: "")
      }

      /// en translation: You have not applied bonus
      ///
      /// Locales: en, ru
      static func crowdloanHavenotAppliedBonusTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.havenot.applied.bonus.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.havenot.applied.bonus.title"
        }

        return NSLocalizedString("crowdloan.havenot.applied.bonus.title", bundle: bundle, comment: "")
      }

      /// en translation: You need to submit agreement with Terms & Conditions on the blockchain to proceed. This is required to be done only once for all following Moonbeam contributions
      ///
      /// Locales: en, ru
      static func crowdloanMoonbeamTermsDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.moonbeam.terms.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.moonbeam.terms.description"
        }

        return NSLocalizedString("crowdloan.moonbeam.terms.description", bundle: bundle, comment: "")
      }

      /// en translation: You should add Moonbeam account to the wallet in order to participate in Moonbeam crowdloan
      ///
      /// Locales: en, ru
      static func crowdloanMoonbeamMissingAccountMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.moonbeam.missing.account.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.moonbeam.missing.account.message"
        }

        return NSLocalizedString("crowdloan.moonbeam.missing.account.message", bundle: bundle, comment: "")
      }

      /// en translation: You should have funds to pay fee and remain above minimal balance.
      ///
      /// Locales: en, ru
      static func walletFeeOverExistentialDeposit(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.fee.over.existential.deposit", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.fee.over.existential.deposit"
        }

        return NSLocalizedString("wallet.fee.over.existential.deposit", bundle: bundle, comment: "")
      }

      /// en translation: You should trust your nominations to act competently and honest, basing your decision purely on their current profitability could lead to reduced profits or even loss of funds.
      ///
      /// Locales: en, ru
      static func stakingSelectValidatorsCustomDesc(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.select.validators.custom.desc", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.select.validators.custom.desc"
        }

        return NSLocalizedString("staking.select.validators.custom.desc", bundle: bundle, comment: "")
      }

      /// en translation: You will get increased rewards starting from next era
      ///
      /// Locales: en, ru
      static func stakingHintRewardBondMore_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.reward.bond.more_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.reward.bond.more_v2_2_0"
        }

        return NSLocalizedString("staking.hint.reward.bond.more_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Your %@ tokens will be returned after the leasing period.
      ///
      /// Locales: en, ru
      static func crowdloanUnlockHint(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("crowdloan.unlock.hint", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.unlock.hint"
        }

        let format = NSLocalizedString("crowdloan.unlock.hint", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Your NFTs
      ///
      /// Locales: en, ru
      static func walletListYourNftsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.list.your.nfts.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.list.your.nfts.title"
        }

        return NSLocalizedString("wallet.list.your.nfts.title", bundle: bundle, comment: "")
      }

      /// en translation: Your account will be removed from blockchain after this operation cause it makes total balance lower than minimal
      ///
      /// Locales: en, ru
      static func commonExistentialWarningMessage_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.existential.warning.message_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.existential.warning.message_v2_2_0"
        }

        return NSLocalizedString("common.existential.warning.message_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Your account will be removed from blockchain after transfer cause it makes total balance lower than minimal
      ///
      /// Locales: en, ru
      static func walletSendExistentialWarning_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.existential.warning_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.existential.warning_v2_2_0"
        }

        return NSLocalizedString("wallet.send.existential.warning_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Your accounts and contacts to whom you were sending transfers will appear here
      ///
      /// Locales: en, ru
      static func walletContactsEmptyTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.contacts.empty.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.contacts.empty.title"
        }

        return NSLocalizedString("wallet.contacts.empty.title", bundle: bundle, comment: "")
      }

      /// en translation: Your accounts and contacts to whom you were sending transfers will appear here
      ///
      /// Locales: en, ru
      static func walletContactsEmptyTitle_v110(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.contacts.empty.title_v1.10", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.contacts.empty.title_v1.10"
        }

        return NSLocalizedString("wallet.contacts.empty.title_v1.10", bundle: bundle, comment: "")
      }

      /// en translation: Your assets will appear here. Make sure the "Hide zero balances" filter is turned off
      ///
      /// Locales: en, ru
      static func walletListEmptyMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.list.empty.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.list.empty.message"
        }

        return NSLocalizedString("wallet.list.empty.message", bundle: bundle, comment: "")
      }

      /// en translation: Your balance
      ///
      /// Locales: en, ru
      static func walletBalancesWidgetTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.balances.widget.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.balances.widget.title"
        }

        return NSLocalizedString("wallet.balances.widget.title", bundle: bundle, comment: "")
      }

      /// en translation: Your contributions
      ///
      /// Locales: en, ru
      static func crowdloanYouContributionsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.you.contributions.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.you.contributions.title"
        }

        return NSLocalizedString("crowdloan.you.contributions.title", bundle: bundle, comment: "")
      }

      /// en translation: Your derivation path contains unsupported symbols or has incorrect structure
      ///
      /// Locales: en, ru
      static func commonInvalidDerivationPathMessage_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.invalid.derivation.path.message_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.invalid.derivation.path.message_v2_2_0"
        }

        return NSLocalizedString("common.invalid.derivation.path.message_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Your mnemonic is invalid. Please, try another one.
      ///
      /// Locales: en, ru
      static func accessRestorePhraseErrorMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("access.restore.phrase.error.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "access.restore.phrase.error.message"
        }

        return NSLocalizedString("access.restore.phrase.error.message", bundle: bundle, comment: "")
      }

      /// en translation: Your operations will be displayed here
      ///
      /// Locales: en, ru
      static func walletEmptyDescription_v2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.empty.description_v2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.empty.description_v2_2_0"
        }

        return NSLocalizedString("wallet.empty.description_v2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Your region is not supported
      ///
      /// Locales: en, ru
      static func crowdloanMoonbeamRegionRestrictionTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("crowdloan.moonbeam.region.restriction.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "crowdloan.moonbeam.region.restriction.title"
        }

        return NSLocalizedString("crowdloan.moonbeam.region.restriction.title", bundle: bundle, comment: "")
      }

      /// en translation: Your rewards
      ///
      /// Locales: en, ru
      static func stakingRewardWidgetTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.reward.widget.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.reward.widget.title"
        }

        return NSLocalizedString("staking.reward.widget.title", bundle: bundle, comment: "")
      }

      /// en translation: Your rewards  will appear here
      ///
      /// Locales: en, ru
      static func stakingAnalyticsRewardsEmptyMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.rewards.empty.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.rewards.empty.message"
        }

        return NSLocalizedString("staking.analytics.rewards.empty.message", bundle: bundle, comment: "")
      }

      /// en translation: Your rewards will be increased starting from the next era.
      ///
      /// Locales: en, ru
      static func stakingHintRewardBondMore(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.hint.reward.bond.more", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.hint.reward.bond.more"
        }

        return NSLocalizedString("staking.hint.reward.bond.more", bundle: bundle, comment: "")
      }

      /// en translation: Your stake
      ///
      /// Locales: en, ru
      static func stakingYourStake(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.stake", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.stake"
        }

        return NSLocalizedString("staking.your.stake", bundle: bundle, comment: "")
      }

      /// en translation: Your stake changes will appear here
      ///
      /// Locales: en, ru
      static func stakingAnalyticsStakeEmptyMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.analytics.stake.empty.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.analytics.stake.empty.message"
        }

        return NSLocalizedString("staking.analytics.stake.empty.message", bundle: bundle, comment: "")
      }

      /// en translation: Your stake is allocated to the following validators.
      ///
      /// Locales: en, ru
      static func stakingYourAllocatedDescription(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.allocated.description", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.allocated.description"
        }

        return NSLocalizedString("staking.your.allocated.description", bundle: bundle, comment: "")
      }

      /// en translation: Your stake is assigned to next validators
      ///
      /// Locales: en, ru
      static func stakingYourAllocatedDescription_2_2_0(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.allocated.description_2_2_0", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.allocated.description_2_2_0"
        }

        return NSLocalizedString("staking.your.allocated.description_2_2_0", bundle: bundle, comment: "")
      }

      /// en translation: Your staked amount is less than the minimum stake to get a reward.
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusAlertLowStake(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.alert.low.stake", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.alert.low.stake"
        }

        return NSLocalizedString("staking.nominator.status.alert.low.stake", bundle: bundle, comment: "")
      }

      /// en translation: Your staking will start in the next era.
      ///
      /// Locales: en, ru
      static func stakingNominatorStatusAlertWaitingMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.nominator.status.alert.waiting.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.nominator.status.alert.waiting.message"
        }

        return NSLocalizedString("staking.nominator.status.alert.waiting.message", bundle: bundle, comment: "")
      }

      /// en translation: Your tokens are allocated to the oversubscribed validators. You will not receive rewards in this era.
      ///
      /// Locales: en, ru
      static func stakingYourOversubscribedMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.oversubscribed.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.oversubscribed.message"
        }

        return NSLocalizedString("staking.your.oversubscribed.message", bundle: bundle, comment: "")
      }

      /// en translation: Your tokens will be available to redeem after the unstaking period.
      ///
      /// Locales: en, ru
      static func stakingUnbondingHint(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.unbonding.hint", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.unbonding.hint"
        }

        return NSLocalizedString("staking.unbonding.hint", bundle: bundle, comment: "")
      }

      /// en translation: Your transfer will fail since the destination account does not have enough %@ to accept other token transfers
      ///
      /// Locales: en, ru
      static func walletSendDeadRecipientCommissionAssetMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("wallet.send.dead.recipient.commission.asset.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.dead.recipient.commission.asset.message"
        }

        let format = NSLocalizedString("wallet.send.dead.recipient.commission.asset.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: Your transfer will fail since the final amount on the destination account will be less than the minimal balance. Please, try to increase the amount.
      ///
      /// Locales: en, ru
      static func walletSendDeadRecipientMessage(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.dead.recipient.message", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.dead.recipient.message"
        }

        return NSLocalizedString("wallet.send.dead.recipient.message", bundle: bundle, comment: "")
      }

      /// en translation: Your transfer will remove account from blockstore since it will make total balance lower than minimal balance.
      ///
      /// Locales: en, ru
      static func walletSendExistentialWarning(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.send.existential.warning", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.send.existential.warning"
        }

        return NSLocalizedString("wallet.send.existential.warning", bundle: bundle, comment: "")
      }

      /// en translation: Your validator
      ///
      /// Locales: en, ru
      static func stakingYourValidatorTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.validator.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.validator.title"
        }

        return NSLocalizedString("staking.your.validator.title", bundle: bundle, comment: "")
      }

      /// en translation: Your validators
      ///
      /// Locales: en, ru
      static func stakingYourValidatorsTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.validators.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.validators.title"
        }

        return NSLocalizedString("staking.your.validators.title", bundle: bundle, comment: "")
      }

      /// en translation: Your validators will change in the next era.
      ///
      /// Locales: en, ru
      static func stakingYourValidatorsChangingTitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.your.validators.changing.title", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.your.validators.changing.title"
        }

        return NSLocalizedString("staking.your.validators.changing.title", bundle: bundle, comment: "")
      }

      /// en translation: Youtube
      ///
      /// Locales: en, ru
      static func settingsYoutube(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("settings.youtube", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "settings.youtube"
        }

        return NSLocalizedString("settings.youtube", bundle: bundle, comment: "")
      }

      /// en translation: ed25519 (alternative)
      ///
      /// Locales: en, ru
      static func ed25519SelectionSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("ed25519.selection.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "ed25519.selection.subtitle"
        }

        return NSLocalizedString("ed25519.selection.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: era #%@
      ///
      /// Locales: en, ru
      static func stakingEraTitle(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.era.title", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.era.title"
        }

        let format = NSLocalizedString("staking.era.title", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: max
      ///
      /// Locales: en, ru
      static func commonMax(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("common.max", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.max"
        }

        return NSLocalizedString("common.max", bundle: bundle, comment: "")
      }

      /// en translation: my accounts
      ///
      /// Locales: en, ru
      static func walletSearchAccounts(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("wallet.search.accounts", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "wallet.search.accounts"
        }

        return NSLocalizedString("wallet.search.accounts", bundle: bundle, comment: "")
      }

      /// en translation: selected %li (max %li)
      ///
      /// Locales: en, ru
      static func stakingSelectedValidatorsCount_v191(_ value1: Int, _ value2: Int, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.selected.validators.count_v1.9.1", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1, value2)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.selected.validators.count_v1.9.1"
        }

        let format = NSLocalizedString("staking.selected.validators.count_v1.9.1", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1, value2)
      }

      /// en translation: sr25519 (recommended)
      ///
      /// Locales: en, ru
      static func sr25519SelectionSubtitle(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("sr25519.selection.subtitle", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "sr25519.selection.subtitle"
        }

        return NSLocalizedString("sr25519.selection.subtitle", bundle: bundle, comment: "")
      }

      /// en translation: till %@
      ///
      /// Locales: en, ru
      static func commonTillDate(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("common.till.date", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "common.till.date"
        }

        let format = NSLocalizedString("common.till.date", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: waiting for the next era (%@)
      ///
      /// Locales: en, ru
      static func stakingWaitingNextEraFormat(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("staking.waiting.next.era.format", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.waiting.next.era.format"
        }

        let format = NSLocalizedString("staking.waiting.next.era.format", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: with at least one identity contact
      ///
      /// Locales: en, ru
      static func stakingRecommendedHint3Addition(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("staking.recommended.hint3.addition", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "staking.recommended.hint3.addition"
        }

        return NSLocalizedString("staking.recommended.hint3.addition", bundle: bundle, comment: "")
      }

      /// en translation: %@ DApp will be removed from Authorized
      ///
      /// Locales: en, ru
      static func dappRemoveAuthorizedMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("dapp.remove.authorized.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.remove.authorized.message"
        }

        let format = NSLocalizedString("dapp.remove.authorized.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      /// en translation: %@ DApp will be removed from Favorites
      ///
      /// Locales: en, ru
      static func dappRemoveFavoritesMessage(_ value1: String, preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          let format = NSLocalizedString("dapp.remove.favorites.message", bundle: hostingBundle, comment: "")
          return String(format: format, locale: applicationLocale, value1)
        }

        guard let (locale, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "dapp.remove.favorites.message"
        }

        let format = NSLocalizedString("dapp.remove.favorites.message", bundle: bundle, comment: "")
        return String(format: format, locale: locale, value1)
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _AssetDetailsView.validate()
      try _IconWithTitleTableViewCell.validate()
      try _OnbordingMain.validate()
      try _PinSetupViewController.validate()
      try _PurchaseProviderPickerTableViewCell.validate()
      try _TitleWithSubtitleTableViewCell.validate()
      try _WalletCompoundDetailsView.validate()
      try _WalletTokenView.validate()
    }

    struct _AccountConfirmViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "AccountConfirmViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _AccountManagementViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "AccountManagementViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _AssetDetailsView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "AssetDetailsView"

      static func validate() throws {
        if UIKit.UIImage(named: "iconBuy", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconBuy' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconInfoFilled", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconInfoFilled' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconReceive", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconReceive' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconSend", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconSend' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorBlurSeparator", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorBlurSeparator' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorGreen", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorGreen' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorHighlightedAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorHighlightedAccent' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorTransparentText", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorTransparentText' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite24", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite24' is used in nib 'AssetDetailsView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _DetailsDisplayTableViewCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "DetailsDisplayTableViewCell"

      fileprivate init() {}
    }

    struct _IconWithTitleTableViewCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "IconWithTitleTableViewCell"

      static func validate() throws {
        if UIKit.UIImage(named: "iconCheckmark", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconCheckmark' is used in nib 'IconWithTitleTableViewCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconKsmSmallBg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconKsmSmallBg' is used in nib 'IconWithTitleTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorAlmostBlack", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorAlmostBlack' is used in nib 'IconWithTitleTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'IconWithTitleTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _ModalPickerViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "ModalPickerViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _OnbordingMain: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "OnbordingMain"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      func secondView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[1] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "iconImportWallet", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconImportWallet' is used in nib 'OnbordingMain', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconPlusFilled", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconPlusFilled' is used in nib 'OnbordingMain', but couldn't be loaded.") }
        if UIKit.UIImage(named: "logo", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'logo' is used in nib 'OnbordingMain', but couldn't be loaded.") }
        if UIKit.UIImage(named: "novabg-splash", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'novabg-splash' is used in nib 'OnbordingMain', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorAccent' is used in nib 'OnbordingMain', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorHighlightedAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorHighlightedAccent' is used in nib 'OnbordingMain', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'OnbordingMain', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _PinSetupViewController: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "PinSetupViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "pinBackspace", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'pinBackspace' is used in nib 'PinSetupViewController', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorAccent' is used in nib 'PinSetupViewController', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorBlack", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorBlack' is used in nib 'PinSetupViewController', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorHighlightedAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorHighlightedAccent' is used in nib 'PinSetupViewController', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'PinSetupViewController', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite8", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite8' is used in nib 'PinSetupViewController', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _PurchaseProviderPickerTableViewCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "PurchaseProviderPickerTableViewCell"

      static func validate() throws {
        if UIKit.UIImage(named: "iconAboutArrow", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconAboutArrow' is used in nib 'PurchaseProviderPickerTableViewCell', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconMoonPay", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconMoonPay' is used in nib 'PurchaseProviderPickerTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "color0x1D1D20", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'color0x1D1D20' is used in nib 'PurchaseProviderPickerTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'PurchaseProviderPickerTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _SelectionListViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "SelectionListViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _StakingMainViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "StakingMainViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _TitleWithSubtitleTableViewCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "TitleWithSubtitleTableViewCell"

      static func validate() throws {
        if UIKit.UIImage(named: "iconCheckmark", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconCheckmark' is used in nib 'TitleWithSubtitleTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorAlmostBlack", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorAlmostBlack' is used in nib 'TitleWithSubtitleTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorGray' is used in nib 'TitleWithSubtitleTableViewCell', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'TitleWithSubtitleTableViewCell', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _WalletAmountView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "WalletAmountView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _WalletCompoundDetailsView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "WalletCompoundDetailsView"

      static func validate() throws {
        if UIKit.UIImage(named: "iconCopy", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconCopy' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorBlack", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorBlack' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorDarkGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorDarkGray' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorGray' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorHighlightedAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorHighlightedAccent' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorLightGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorLightGray' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'WalletCompoundDetailsView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _WalletManagementViewController: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "WalletManagementViewController"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      fileprivate init() {}
    }

    struct _WalletSingleActionAccessoryView: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "WalletSingleActionAccessoryView"

      fileprivate init() {}
    }

    struct _WalletTokenView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "WalletTokenView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? UIKit.UIView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "iconInfoFilled", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconInfoFilled' is used in nib 'WalletTokenView', but couldn't be loaded.") }
        if UIKit.UIImage(named: "iconKsmSmallBg", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'iconKsmSmallBg' is used in nib 'WalletTokenView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "colorDarkGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorDarkGray' is used in nib 'WalletTokenView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorGreen", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorGreen' is used in nib 'WalletTokenView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorHighlightedAccent", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorHighlightedAccent' is used in nib 'WalletTokenView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorLightGray", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorLightGray' is used in nib 'WalletTokenView', but couldn't be loaded.") }
          if UIKit.UIColor(named: "colorWhite", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'colorWhite' is used in nib 'WalletTokenView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if UIKit.UIImage(named: "logo", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'logo' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if UIKit.UIImage(named: "novabg-splash", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'novabg-splash' is used in storyboard 'LaunchScreen', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
